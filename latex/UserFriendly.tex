Using \autoref{sec:leibniz} we can relate functionally equivalent structures, and using \autoref{sec:numrep} we can relate structurally similar structures. However, both have downsides; the former requires us to construct isomorphisms, and the latter wraps all components behind a layer of constructors.  In this section will alleviate these problems through generics and by alternative descriptions of equivalences.

In later sections we will construct many more equivalences between more complicated types than before, so we will dive right into the latter. Reflecting upon \autoref{sec:leibniz}, we see that when one establishes an equivalence, most of the time is spent working out a series of lemmas that prove the conversion functions are to be mutual inverses. We note that the functions themselves were, in fact, forced for a large part.  %We will reuse the machinery of Ko and Gibbons \cite{progorn} to illustrate how the definitions in \autoref{sec:leibniz} were actually forced for a large part.

First, we remark that \AgdaDatatype{μ} is internalization of the representation of simple\footnote{Of course, indexed datatypes are indexed W-types, mutually recursive datatypes are represented yet differently\dots} datatypes as W-types. Thus, we will assume that one of the sides of the equivalence is always represented as an initial algebra of a polynomial functor, and hence the \AgdaDatatype{μ} of a \AgdaDatatype{Desc′}.

\subsection{Well-founded monic algebras are initial}\label{ssec:wellfounded}
Unfortunately, the machinery developed by Ko and Gibbons \cite{progorn} relies on axiom K for a small but crucial part. To be precise, in a cubical setting, the type \AgdaDatatype{μ} as given stops being initial for its base functor! In this section, we will be working with a simplified and repaired version. Namely, we simplify \AgdaDatatype{Desc′} to 
\ExecuteMetaData[Extra/ProgOrn/Desc]{DescS}
To complete the definition of \AgdaDatatype{μ}
\ExecuteMetaData[Extra/ProgOrn/Desc]{mu}
we will need to implement \AgdaDatatype{Base}. We remark that in the original setup, the recursion of \AgdaFunction{mapFold} is a structural descent in \AgdaFunction{⟦ D' ⟧ (μ D)}. Because \AgdaFunction{⟦\_⟧} is a type computing function and not a datatype, this descent becomes invalid\footnote{Refer to the  \href{https://agda.readthedocs.io/en/latest/language/without-k.html\#restrictions-on-termination-checking}{without K} page.}, and \AgdaFunction{mapFold} fails the termination check. We resolve this by defining \AgdaDatatype{Base} as a datatype
\ExecuteMetaData[Extra/ProgOrn/Desc]{Base}
such that this descent is allowed by the termination checker without axiom K.\footnote{This has, again by the absence of axiom K, the consequence of pushing the universe levels up by one. However, this is not too troublesome, as equivalences can go between two levels, and indeed types are equivalent to their lifts.}

Recall that the \AgdaDatatype{Base} functors of descriptions are special polynomial functors, and the fixpoint of a base functor is its initial algebra. We are looking for sufficient conditions on $X$ to get the equivalence $e: X \cong \mu F$. Note that when $X \cong \mu F$, then there necessarily is an initial algebra $F X \to X$. Conversely, if the algebra $(X, f)$ is isomorphic to $(\mu F, \mathrm{con})$, then $X \cong \mu F$ would follow immediately, so it is equivalent to ask for the algebras to be isomorphic instead.

\begin{comment}
The situation so far is summarized by the diagram
% https://q.uiver.app/?q=WzAsMyxbMSwwLCJGXFxtdV9GIl0sWzEsMSwiXFxtdSBGIl0sWzAsMSwiWCJdLFswLDEsIlxcbWF0aHJte2Nvbn0iXSxbMiwxLCJlIiwyLHsic3R5bGUiOnsidGFpbCI6eyJuYW1lIjoiYXJyb3doZWFkIn0sImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dXQ==
\[\begin{tikzcd}[ampersand replacement=\&]
	\& {F\mu_F} \\
	X \& {\mu F}
	\arrow["{\mathrm{con}}", from=1-2, to=2-2]
	\arrow["e"', dashed, tail reversed, from=2-1, to=2-2]
\end{tikzcd}\]
\end{comment}
\subsubsection{Datatypes as initial algebras}
To characterize when such algebras are isomorphic, we reiterate some basic category theory, simultaneously rephrasing it in Agda terms.\footnote{We are not reusing a pre-existing category theory library for the simple reasons that it is not that much work to write out the machinery explicitly, and that such libraries tend to phrase initial objects in the correct way, which is too restrictive for us.}

Let $C$ be a category, and let $a, b, c$ be objects of $C$, so that in particular we have identity arrows $1_a : a \to a$ and for arrows $g : b \to c, f : a \to b$ composite arrows $gf : a \to c$ subject to associativity. In our case, $C$ is the category of types, with ordinary functions as arrows.

Recall that an endofunctor, which is simply a functor $F$ from $C$ to itself, assigns objects to objects and sends arrows to arrows
\ExecuteMetaData[Extra/Category]{RawFunctor}
These assignments are subject to the identity and composition laws
\ExecuteMetaData[Extra/Category]{Functor}
An $F$-algebra is just a pair of an object $a$ and an arrow $Fa \to a$
\ExecuteMetaData[Extra/Category]{Algebra}
Algebras themselves again form a category $C^F$. The arrows of $C^F$ are the arrows $f$ of $C$ such that the following square commutes% https://q.uiver.app/?q=WzAsNCxbMCwwLCJGYSJdLFsxLDAsIkZiIl0sWzAsMSwiYSJdLFsxLDEsImIiXSxbMiwzLCJmIiwyXSxbMCwyLCJVX2EiLDJdLFsxLDMsIlVfYiJdLFswLDEsIkZmIl1d
\[\begin{tikzcd}[ampersand replacement=\&]
	Fa \& Fb \\
	a \& b
	\arrow["f"', from=2-1, to=2-2]
	\arrow["{U_a}"', from=1-1, to=2-1]
	\arrow["{U_b}", from=1-2, to=2-2]
	\arrow["Ff", from=1-1, to=1-2]
\end{tikzcd}\]
So we define
\ExecuteMetaData[Extra/Category]{AlgSqr}
and
\ExecuteMetaData[Extra/Category]{AlgMap}
Note that we take the propositional truncation of the square, such that algebra maps with the same underlying morphism become propositionally equal
\ExecuteMetaData[Extra/Category]{AlgPath}
The identity and composition in $C^F$ arise directly from those of the underlying arrows in $C$.

Recall that an object $\emptyset$ is initial when for each other object $a$, there is a unique arrow $!: \emptyset \to a$. By reversing the proofs of initiality of \AgdaDatatype{μ} and the main result of this section, we obtain a slight variation upon the usual definition. Namely, unicity is often expressed as contractability of a type
\ExecuteMetaData[Tex/Snippets]{isContr}
Instead, we again use a truncation
\ExecuteMetaData[Extra/Category]{weakContr}
but note that this also, crucially, slightly stronger than connectedness. We define initiality for arbitrary relations
\ExecuteMetaData[Extra/Category]{Initial}
such that it closely resembles the definition of least element. Then, $A$ is an initial algebra when
\ExecuteMetaData[Extra/Category]{InitAlg}

By basic category theory (using the usual definition of initial objects), two initial objects $a$ and $b$ are always isomorphic;
namely, initiality guarantees that there are arrows $f : a \to b$ and $g : b \to a$, which by initiality must compose to the identities again.

Similarly, we get that
\ExecuteMetaData[Extra/Category]{InitAlg-equiv}
Because being an equivalence is a property, we can eliminate from the truncations to get the wanted result.

%Note that even though we warned ourselves, we are still talking about sections and retractions to establish that $f$ is an equivalence! However, this result also makes sure we will not have to speak of them again.

\subsubsection{Accessibility}
As a consequence, we get that $X$ is isomorphic to $\mu D$ when $X$ is an initial algebra for the base functor of $D$; $\mu D$ is initial by its fold, and by induction on $\mu D$ using the squares of algebra maps. 

\begin{remark}
    The fixpoint $\mu D$ is not in general a strict initial object in the category of algebras. For a strict initial object, having a map $a \to \emptyset$ implies $a \cong \emptyset$. This is not the case here: strict initial objects satisfy $a \times \emptyset \cong \emptyset$, but for the $X \mapsto 1 + X$-algebras $\mathbb{N}$ and $2^\mathbb{N}$ clearly $2^\mathbb{N} \times \mathbb{N} \cong \mathbb{N}$ does not hold. On the other hand, the ``obvious'' sufficient condition to let $C^F$ have strict initial objects is that $F$ is a left adjoint, but then the carrier of the initial algebra is simply $\bot$.
\end{remark}

Looking back at \autoref{sec:leibniz}, we see that \AgdaDatatype{Leibniz} is an initial $F: X \mapsto 1 + X$ algebra because for any other algebra, the image of \AgdaFunction{0b} is fixed, and by \AgdaFunction{bsuc} all other values are determined by chasing around the square. Thus, we are looking for a similar structure on $f : FX \to X$ that supports recursion.

We will need something stronger than $FX \cong X$, as in general a functor can have many fixpoints. For this, we define what it means for an element $x$ to be accessible by $f$. This definition uses a mutually recursive datatype as follows:
We state that an element $x$ of $X$ is accessible when there is an accessible $y$ in its fiber over $f$
\ExecuteMetaData[Extra/Category/Poly]{Acc}
Accessibility of an element $x$ of \AgdaFunction{Base A E} is defined by cases on $E$; if $E$ is \AgdaFunction{ṿ n} and $x$ is a \AgdaFunction{Vec A n}, then $x$ is accessible if all its elements are; if $x$ is \AgdaFunction{σ S E'}, then $x$ is accessible if \AgdaFunction{snd x} is
\ExecuteMetaData[Extra/Category/Poly]{Acc'}
Consequently, $X$ is well-founded for an algebra when all its elements are accessible
\ExecuteMetaData[Extra/Category/Poly]{Wf}

We can see well-foundedness as an upper bound on the size of $X$, if it were larger than $\mu D$, some of its elements would get out of reach of an algebra. \textit{Now} having $FX \cong X$ also gives us a lower bound, but note that having a well-founded injection $f: FX \to X$ is already sufficient, as accessibility gives a section of $f$, making it an iso. This leads us to claim
\begin{claim}\label{claim:wf-inj-init}
    If there is a mono $f : FX \to X$ and $X$ is well-founded for $f$, then $X$ is an initial $F$-algebra.
\end{claim}
\begin{proof}[Proof sketch of \autoref{claim:wf-inj-init}]
Suppose $X$ is well-founded for the mono $f : FX \to X$. To show that $(X, f)$ is initial, let us take another algebra $(Y, g)$, and show that there is a unique arrow $(X, f) \to (Y, g)$.\todo[inline]{This section is about as digestable as a brick.}

By \AgdaDatatype{Acc}-recursion and because all $x$ are accessible, we can define a plain map into $Y$
\ExecuteMetaData[Extra/Category/WellFounded]{Wf-rec}
This construction is an instance of the concept of ``well-founded recursion''\footnote{This is formalized in the \href{https://agda.github.io/agda-stdlib/Induction.WellFounded.html}{standard-library} with many other examples.}, so we use a similar strategy. In particular, we prove an irrelevance lemma
\ExecuteMetaData[Extra/Category/WellFounded]{Wf-rec-irr}
which implies the unfolding lemma
\ExecuteMetaData[Extra/Category/WellFounded]{Wf-rec-unfold}
The unfolding lemma ensures that the map we defined by \AgdaFunction{Wf-rec} is a map of algebras. The proof that this map is unique proceeds analogously to that in the proof that $\mu D$ is initial, but here we instead use \AgdaDatatype{Acc}-recursion
\ExecuteMetaData[Extra/Category/WellFounded]{Wf+inj=Init}
Thus, we conclude that $X$ is initial. The main result is then a corollary of initiality of $X$ and the isomorphism of initial objects
\ExecuteMetaData[Extra/Category/WellFounded]{Wf+inj=mu}
\end{proof}


\subsubsection{Example}
Let us redo the proof in \autoref{sec:leibniz}, now using this result. Recall the description of naturals \AgdaFunction{NatD}. To show that \AgdaFunction{Leibniz} is isomorphic to \AgdaFunction{Nat}, we will need a \AgdaFunction{NatD}-algebra and a proof of its well-foundedness. We define the algebra
\ExecuteMetaData[Tex/Leibniz2]{bsuc'}

For well-foundedness, we use something similar to view-patterns %[mcbride]
(the main difference being that we look through the entire structure, instead of a single layer)
\ExecuteMetaData[Tex/Leibniz2]{Peano-View}
where the mutually recursive proof of \AgdaFunction{view} is ``almost trivial''. Well-foundedness follows immediately
\ExecuteMetaData[Tex/Leibniz2]{Wf-bsuc}

Injectivity of \AgdaFunction{bsuc\_1} happens to be harder to prove from retractions than directly, so we prove it directly, from which the wanted statement follows
\ExecuteMetaData[Tex/Leibniz2]{L-is-mu-N}

In this case, we needed more lines of code to prove the same statement, however, the process of writing became more forced, and might be more amenable to automation.

