\documentclass{article}

\usepackage{comment}

\setlength{\marginparwidth}{2cm} % remove when done
\usepackage{todonotes}

\usepackage{xcolor}
\usepackage[hidelinks]{hyperref}
\usepackage{catchfilebetweentags}

\usepackage[links]{agda}
\AgdaNoSpaceAroundCode{}

% from: https://agda.readthedocs.io/en/v2.6.3/_downloads/59877ce886494c991a213f09e29b712c/article-luaxelatex-different-fonts.lagda.tex
\usepackage{fontspec}
\newfontfamily{\AgdaSerifFont}{Linux Libertine O}
\newfontfamily{\AgdaSansSerifFont}{Linux Biolinum O}
\newfontfamily{\AgdaTypewriterFont}{inconsolata}
\renewcommand{\AgdaFontStyle}[1]{{\AgdaSansSerifFont{}#1}}
\renewcommand{\AgdaKeywordFontStyle}[1]{{\AgdaSansSerifFont{}#1}}
\renewcommand{\AgdaStringFontStyle}[1]{{\AgdaTypewriterFont{}#1}}
\renewcommand{\AgdaCommentFontStyle}[1]{{\AgdaTypewriterFont{}#1}}
\renewcommand{\AgdaBoundFontStyle}[1]{\textit{\AgdaSerifFont{}#1}}

\usepackage[style=alphabetic]{biblatex}
\addbibresource{refs.bib}

\usepackage{subfiles} % load me last!



\newcommand{\investigate}[1]{\textcolor{gray}{\textit{#1}}}


\title{Running in circles in Agda\\ \small I'll have to grab a UU-template at some point}
\author{Samuel Klumpers\\6057314}

\begin{document}
\maketitle
\tableofcontents

This document is generated from a literate agda file!

\section{Introduction}
Most of the time when we are Agda-ing \cite{agda} we are trying to un-Haskell ourselves, e.g., not take the head of an empty list. In this example, we can make \AgdaFunction{head} total by switching to length-indexed lists: vectors. We have now effectively doubled the size of our code base, since functions like \AgdaFunction{\_++\_} which we had for lists, will also have to be reimplemented for vectors.

To make things worse; often, after coping with the overloaded names resulting from Agda-ing by shoving them into a different namespace, we also find out that lists nor vectors are efficient containers to begin with. Maybe binary trees are better. We now need four times the number of definitions to keep everything working, and, if we start proving things, we will also have to prove everything fourfold. (Not to mention that reasoning about trees is probably going to be harder than reasoning about lists).  This inefficiency has sparked (my) interest in ways to deal with the situation.

Following \cite{orntrans} and \cite{progorn}, we can describe the relation between list and vector using the mechanism of ornamentation. This leads them to define the concept of patches, which can aid us when defining \AgdaFunction{\_++\_} for the second time by forcing the new version to be coherent. In fact, the algebraic nature of ornaments can even get us the definition of the vector type for free, if we started by defining lists relative to natural numbers \cite{algorn}. Such constructions rely heavily on descriptions of datastructures and often come with limitations in their expressiveness. These descriptions in turn impose additional ballast on the programmer, leading us to investigate reflection like in \cite{practgen} as a means to bring datatypes and descriptions closer when possible.

From a different direction, \cite{calcdata} gives methods by which we can show two implementations of some structure to be equivalent. With this, we can simply transport all proofs about \AgdaFunction{\_++\_} we have for lists over to the implementation for trees, provided that we show them to be equivalent as appendable containers. This process can also be automated by some heavy generics, but instead, we resort to cubical; which hosts a range of research like \cite{iri} tailored to the problem describing equivalences of structures.

We can liken the situation to movement on a plane, where ornamentation moves us vertically by modifying constructors or indices, and structured equivalences move us horizontally to and from equivalent but more equivalent implementations.

Before we try to improve or generalize upon these approaches, let us clarify some parts of the enviroment we are working in, partially by going through some examples.


\section{How Cubical Agda helps our binary numbers (almost done)}
\subfile{Tex/CubicalAndBinary}


\section{Numerical representations (rough)}
\subfile{NumericalRepresentations}


\section{Ornamentation (unfinished)}
\subfile{Ornamentation}


\section{Equivalence from initiality (where does this go?)}



\section{Is equivalence too strong (finger trees)}



\section{Discussion and future work (aka the union of my to-do list and the actual future work section)}



\section{Temporary}
\listoftodos
%\subfile{Scratch.tex}


\printbibliography
\end{document}
