\documentclass{article}

\usepackage[style=alphabetic]{biblatex}
\addbibresource{refs.bib}

\usepackage{comment}

\setlength{\marginparwidth}{2cm} % remove when done

\usepackage{todonotes}
\usepackage{xcolor}
\usepackage[hidelinks]{hyperref}

%\hypersetup{
%    colorlinks=true,
%    linkcolor=cyan
%    }

\usepackage{catchfilebetweentags}
\usepackage{quiver} 
\usepackage{tabularx}
\usepackage{adjustbox}
\usepackage{longtable}
\usepackage{amsthm}
\usepackage{amsmath}


\theoremstyle{plain}% default
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{prop}[theorem]{Proposition}
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{remark}{Remark}[section]
\newtheorem{claim}{Claim}[section]

\renewcommand{\partautorefname}{Part}%
\renewcommand{\sectionautorefname}{Section}%
\renewcommand{\subsectionautorefname}{Subsection}%

\providecommand{\theoremautorefname}{Theorem}%
\providecommand{\lemmaautorefname}{Lemma}%
\providecommand{\propautorefname}{Proposition}%
\providecommand{\corautorefname}{Corollary}%

\providecommand{\defnautorefname}{Definition}%
\providecommand{\remarkautorefname}{Remark}%
\providecommand{\claimautorefname}{Claim}%


\usepackage[links]{agda}
\AgdaNoSpaceAroundCode{}

% from: https://agda.readthedocs.io/en/v2.6.3/_downloads/59877ce886494c991a213f09e29b712c/article-luaxelatex-different-fonts.lagda.tex
\usepackage{fontspec}

\usepackage{luaotfload}

\directlua{luaotfload.add_fallback
  ("myfallback",
    { "JuliaMono:style=Regular;"
    , "NotoSansMono:style=Regular;"
    , "NotoSansMath:style=Regular;"
    , "Segoe UI Emoji:mode=harf;"
    }
  )}
\defaultfontfeatures{RawFeature={fallback=myfallback}}

\setmainfont{Latin Modern Roman}

\newfontfamily{\AgdaSerifFont}{Linux Libertine O}
\newfontfamily{\AgdaSansSerifFont}{Linux Biolinum O}
\newfontfamily{\AgdaTypewriterFont}{inconsolata}
\renewcommand{\AgdaFontStyle}[1]{{\AgdaSansSerifFont{}#1}}
\renewcommand{\AgdaKeywordFontStyle}[1]{{\AgdaSansSerifFont{}#1}}
\renewcommand{\AgdaStringFontStyle}[1]{{\AgdaTypewriterFont{}#1}}
\renewcommand{\AgdaCommentFontStyle}[1]{{\AgdaTypewriterFont{}#1}}
\renewcommand{\AgdaBoundFontStyle}[1]{\textit{\AgdaSerifFont{}#1}}

\newcommand{\towrite}[1]{\todo[color=cyan]{#1}}
\newcommand{\toremove}[1]{\textcolor{red}{This is going to be (re)moved: ``#1''}}


% macros
\newcommand{\investigate}[1]{\par\vspace{1\baselineskip}\textcolor{gray}{\textit{#1}}\vspace{1\baselineskip}\par}

% symbols
\newcommand{\bN}{\AgdaDatatype{â„•}}
\newcommand{\bL}{\AgdaDatatype{Leibniz}}


\title{Ornaments and Proof Transport applied to Numerical Representations}
\author{Samuel Klumpers\\6057314}


\begin{document}
\maketitle

\begin{abstract}
\listoftodos
%This thesis explains the concepts of the structure identity principle, numerical representations, and ornaments, and aims to combine these to simplify the presentation and verification of finger trees, demonstrating the generalizability and improved compactness and security of the resulting code. Consequently, we also investigate to which extent ornaments, and other generic programs relying on axiom K, remain applicable in the cubical setting required for the structure identity principle.
\end{abstract}

\tableofcontents


\section{Introduction}\label{sec:intro}
\input{Introduction}

\subsection{The Problem}
The main question of this project is: \textit{can we describe finger trees \cite{fingertrees} in the frameworks of numerical representations and ornamentation \cite{progorn}, simplifying the verification of their properties as flexible two-sided arrays?}\todo{poke} This question generates a number of interesting subproblems, such as that the number system corresponding to finger trees has many representations for the same number, which we expect to describe using quotients \cite{cuagda} and reason about using representation independence \cite{iri}. %If this is accomplished or deemed infeasible at an early stage, we can generalize the results we have to other related problems; for example, we may view the problem of generating arbitrary values for testing as an instance of an enumeration problem.


\subsection{Contributions}
In this paper, we\todo{poke}
\begin{itemize}
    \item adapt ornaments to nested types
    \item allow ornaments to refer to sub-ornaments
    \item[x] define a small universe of typical number systems
    \item give a generic derivation of numerical representations as ornaments from these number systems
    \item instantiate a Structure Identity Principle for these representations.
\end{itemize}
We follow this up by enumerating these, and more structures. We
\begin{itemize}
    \item[x] define hierarchies to enumerate terms by levels
    \item[x] track the cardinalities of each level
    \item include parametrized datatypes into this setup
    \item modify this to include nested types
    \item adapt this approach to index-first datatypes
    \item iterate the accessible indices per level
\end{itemize}
Along the way, we also
\begin{itemize}
    \item[x] characterize identities of W-types
    \item[x] express heterogeneous variants of datastructures as ornaments.
\end{itemize}


\section{Background}
\input{Background}


\part{Numerical representations and ornaments}
\towrite{Adapt and split into background and actual work}

\section{Types from Specifications: Ornamentation and Calculation}\label{sec:numrep}
\input{TypeGeneration}

\section{Finger trees}
\input{Fingertrees}


\part{Enumeration}
\section{Enumeration}
\input{Enumeration}


\part{Temporary}
\include{Ornaments.tex}


\part{Related work}
\section{Related work}\label{sec:resources}
\towrite{Adapt this to the non-proposal form}

\subsection{The Structure Identity Principle}
If we write a program, and replace an expression by an equal one, then we can prove that the behaviour of the program can not change. Likewise, if we replace one implementation of an interface with another, in such a way that the correspondence respects all operations in the interface, then the implementations should be equal when viewed through the interface. Observations like these are instances of ``representation indepencence'', but even in languages with an internal notation of type equality, the applicability is usually exclusive to the metatheory.

In our case, moving from Agda's ``usual type theory'' to Cubical Agda, a cubical homotopy type theory, \textit{univalence} \cite{cuagda} lets us internalize a kind of representation independence known as the Structure Identity Principle \cite{iri}, and even generalize it from equivalences to quasi-equivalence relations. We will also be able to apply univalence to get a true ``equational reasoning'' for types when we are looking at numerical representations.

Still, representation independence in non-homotopical settings may be internalized in some cases \cite{tgalois}, and remains of interest in the context of generic constructions that conflict with cubical.

\subsection{Numerical Representations}
Rather than equating implementations after the fact, we can also ``compute'' datastructures by imposing equations. In the case of container types, one may observe similarities to number systems \cite{purelyfunctional} and call such containers numerical representations. One can then use these representations to prototype new datastructures that automatically inherit properties and equalities from their underlying number systems \cite{calcdata}.

From another perspective, numerical representations run by using representability as a kind of ``strictification'' of types, suggesting that we may be able to generalize the approach of numerical representations, using that any (non-indexed) infinitary inductive-recursive type supports a lookup operation \cite{glookup}.

% In the original setup \cite{calcdata}, the chains of equality reasoning over types had to be unfolded to transport a property from ``natural lookup tables'' to vectors. We expect that one might generalize the SIP to support indexed types, and use this to directly transport proofs from one side of the equality to the other.

\subsection{Ornamentation}
While we can derive datastructures from number systems by going through their index types \cite{calcdata}, we may also interpret numerical representations more literally as intstructions to rewrite a number system to a container type. We can record this transformation internally using ornaments, which can then be used to derive an indexed version of the container \cite{algorn}, or can be modified further to naturally integrate other constraints, e.g., ordering, into the resulting structure \cite{progorn}. Furthermore, we can also use the forgetful functions induced by ornaments to generate specifications for functions defined on the ornamented types \cite{orntrans}.

\subsection{Generic constructions}
Being able to define a datatype and reflect its structure in the same language opens doors to many more interesting constructions \cite{practgen}; a lot of ``recipes'' we recognize, such as defining the eliminators for a given datatype, can be formalized and automated using reflection and macros. We expect that other type transformations can also be interpreted as ornaments, like the extraction of heterogeneous binary trees from level-polymorphic binary trees \cite{hetbin}. 

\printbibliography

\part{Appendix}
\appendix



\section{More equivalences for less effort}\label{sec:userfriendly}
Noting that constructing equivalences directly or from isomorphisms as in \autoref{sec:leibniz} can quickly become challenging when one of the sides is complicated, we work out a different approach making use of the initial semantics of W-types instead. We claim that the functions in the isomorphism of \autoref{sec:leibniz} were partially forced, but this fact was not made use of.

First, we explain that if we assume that one of the two sides of the equivalence is a fixpoint or initial algebra of a polynomial functor (that is, the \AgdaDatatype{Î¼} of a \AgdaDatatype{Descâ€²}), this simplifies giving an equivalence to showing that the other side is also initial.

We describe how we altered the original ornaments \cite{progorn} to ensure that \AgdaDatatype{Î¼} remains initial for its base functor in Cubical Agda, explaining why this fails otherwise, and how defining base functors as datatypes avoids this issue.

In a subsection focussing on the categorical point of view, we show how we can describe initial algebras (and truncate the appropriate parts) in such a way that the construction both applies to general types (rather than only sets), and still produces an equivalence at the end. We explain how this definition, like the usual definition, makes sure that a pair of initial objects always induces a pair of conversion functions, which automatically become inverses. Finally, we explain that we can escape our earlier truncation by appealing to the fact that ``being an equivalence'' is a proposition.

Next, we describe some theory, using which other types can be shown to be initial for a given algebra. This is compared to the construction in \autoref{sec:leibniz}, observing that intuitively, initiality follows because the interpretation of the zero constructor is forced by the square defining algebra maps, and the other values are forced by repeatedly applying similar squares. This is clarified as an instance of recursion over a polynomial functor.

To characterize when this recursion is allowed, we define accessibility with respect to polynomial functors as a mutually recursive datatype as follows. This datatype is constructed using the fibers of the algebra map, defining accessibility of elements of these fibers by cases over the description of the algebra. Then we remark that this construction is an atypical instance of well-founded recursion, and define a type as well-founded for an algebra when all its elements are accessible.

We interpret well-foundedness as an upper bound on the size of a type, leading us to claim that injectivity of the algebra map gives a lower bound, which is sufficient to induce the isomorphism. We sketch the proof of the theorem, relating part of this construction to similar concepts in the formalization of well-founded recursion in the Standard Library. In particular, we prove an irrelevance and an unfolding lemma, which lets us show that the map into any other algebra induced by recursion is indeed an algebra map. By showing that it is also unique, we conclude initiality, and get the isomorphism as a corrolary. 

The theorem is applied and demonstrated to the example of binary naturals. We remark that the construction of well-foundedness looks similar to view-patterns. After this, we conclude that this example takes more lines that the direct deriviation in \autoref{sec:leibniz}, but we argue that most of this code can likely be automated.

\towrite{Merge}

\input{UserFriendly}

\end{document}
