Suppose that we started writing and verifying some code using a vector-based implementation of the two-sided flexible array interface, but later decide to reimplement more efficiently using trees. It would be a shame to lay aside our vector lemmas, and rebuild the correctness proofs for trees from scratch. Instead, we note that both vectors and trees can be represented by their \AgdaFunction{lookup} function. In fact, we can ask for more, and rather than defining an array-like type and then showing that it is represented by a lookup function, we can go the other way around and define types by insisting that they are equivalent to such a function. This approach, in particular the case in which one calculates a container with the same shape as a numeral system, was dubbed numerical representations by Okasaki \cite{purelyfunctional}, and has some formalized examples due to Hinze and Swierstra \cite{calcdata} and Ko and Gibbons \cite{progorn}. Numerical representations are our starting point for defining more complex datastructures based on simpler ones, so we demonstrate such a calculation. 

\section{From numbers to containers}\label{sec:numrep}
We can compute the type of vectors starting from \bN{}.\todo[inline]{Is there a simple twist or other interesting example that we can run through instead, or would anything else be too abrupt without starting from this simple case?}\footnote{This is adapted (and fairly abridged) from Calculating Datastructures \cite{calcdata}} For simplicity, we define them as a type computing function via the ``use-as-definition`` notation from before. We expect vectors to be represented by 
\ExecuteMetaData[Tex/NumRep]{Lookup}
where we use the finite type \AgdaDatatype{Fin} as an index into vector. Using this representation as a specification, we can compute both \AgdaDatatype{Fin} and a type of vectors. The finite type can be computed from the evident definition
\ExecuteMetaData[Tex/NumRep]{Fin-def}
using
\ExecuteMetaData[Tex/NumRep]{leq-split}
Likewise, vectors can be computed by applying a sequence of type isomorphisms
\ExecuteMetaData[Tex/NumRep]{Vec}
\investigate{SIP doesn't mesh very well with indexed stuff, does HSIP help?}

We can implement the following interface using \AgdaDatatype{Vec}
\ExecuteMetaData[Tex/NumRep]{Array}
and show that this satisfies some usual laws like
\ExecuteMetaData[Tex/NumRep]{Laws}
Since we defined \AgdaDatatype{Vec} such that it agrees with \AgdaDatatype{Lookup}, we can relate their implementations as well.

The implementation of arrays as functions is straightforward
\ExecuteMetaData[Tex/NumRep]{FunArray}
and clearly satisfies our interface
\ExecuteMetaData[Tex/NumRep]{FunLaw}
We can implement arrays based on \AgdaDatatype{Vec} as well\footnote{Note that, like any other type computing representation, we pay the price by not being able to pattern match directly on our type.}
\ExecuteMetaData[Tex/NumRep]{VecArray}
Now, rather than rederiving the laws for vectors, the equality allows us to transport them from \AgdaDatatype{Lookup} to \AgdaDatatype{Vec}.\footnote{Except that due to the simplicity of this case, the laws are trivial for \AgdaDatatype{Vec} as well.}
\investigate{As you can see, taking ``use-as-definition'' too literally prevents Agda from solving a lot of metavariables.}

%\section{Relating types by structure: Ornamentation (unfinished)}\label{sec:ornament}
\section{Numerical representations as ornaments}\label{sec:ornaments}
Reflecting on this derivation for \bN{}, we could perform the same computation for \bL{} to get Braun trees. However, we note that these computations proceed with roughly the same pattern: each constructor of the numeral system gets assigned a value, and is amended with a field holding a number of elements and subnodes using this value as a ``weight''. This kind of ``modifying constructors'' is formalized by ornamentation \cite{progorn}, which lets us formulate what it means for two types to have a ``similar'' recursive structure. This is achieved by interpreting (indexed inductive) datatypes from descriptions, between which an ornament is seen as a certificate of similarity, describing which fields or indices need to be introduced or dropped to go from one description to the other. \textit{Ornamental descriptions}, which act as one-sided ornaments, let us describe new datatypes by recording the modifications to an existing description.
\todo[inline]{Put some minimal definitions here.}

Looking back at \AgdaDatatype{Vec}, ornaments let us show that express that \AgdaDatatype{Vec} can be formed by introducing indices and adding a fields holding an elements to \bN{}.%\footnote{These and similar examples are also documented in \cite{progorn}} 
However, deriving \AgdaDatatype{List} from \bN{} generalizes to \bL{} with less notational overhead, so we tackle that case first. We use the following description of \bN{}
\ExecuteMetaData[Tex/NumRepOrn]{NatD}
Here, \AgdaInductiveConstructor{σ} adds a field to the description, upon which the rest of the description can vary, and \AgdaInductiveConstructor{ṿ} lists the recursive fields and their indices (which can only be \AgdaInductiveConstructor{tt}).
We can now write down the ornament which adds fields to the \AgdaFunction{suc} constructor
\ExecuteMetaData[Tex/NumRepOrn]{ListO}
Here, the \AgdaInductiveConstructor{σ} and \AgdaInductiveConstructor{ṿ} are forced to match those of \AgdaDatatype{NatD},
but the \AgdaInductiveConstructor{Δ} adds a new field. Using the least fixpoint and description extraction, we can then define \AgdaDatatype{List} from this ornamental description. Note that we cannot hope to give an unindexed ornament from \bL{}
\ExecuteMetaData[Tex/NumRepOrn]{LeibnizD}
into trees, since trees have a very different recursive structure! Thus, we must keep track at what level we are in the tree so that we can ask for adequately many elements:
\ExecuteMetaData[Tex/NumRepOrn]{TreeO}
We use the \AgdaFunction{power} combinator to ensure that the digit at position $n$, which has weight $2^n$ in the interpretation of a binary number, also holds its value times $2^n$ elements. This makes sure that the number of elements in the tree shaped after a given binary number also is the value of that  binary number.


\section{\added{}Generic numerical representations}\label{sec:trieo}
We will demonstrate how we can use ornamental descriptions to generically construct datastructures. The claim is that calculating a datastructure is actually an ornamental operation, so we might call our approach ``calculating ornaments''. 

We first define the kind of information constituting a type of ``natural numbers''
\ExecuteMetaData[Ornament/Numerical]{Number} 
which gets its semantics from the conversion to \bN{}
\ExecuteMetaData[Ornament/Numerical]{toN-type}
This conversion is defined by generalizing over the inner information bundle and folding using
\ExecuteMetaData[Ornament/Numerical]{toN-con}
Hence, a number can have a list of alternatives, which can be one of
\begin{itemize}
    \item a leaf with a fixed value $k$
    \item a recursive field $n$ and remainder $x$, which get a value of $kn + x$ for a fixed $k$
    \item a non-recursive field, which can add an arbitrary value to the remainder
    \item a field containing another number $r$, and a remainder $x$, which again get a value of $kr + x$ for a fixed $k$.
\end{itemize}
This restricts the numbers to the class of numbers which are interpreted by linear functions, which certainly does not include all interesting number systems, but does include almost all systems that have associated containers\footnote{Notably, polynomials still calculate datastructures, interpreting multiplication as precomposition.}. Note that an arbitrary number system of this kind is not necessarily isomorphic to \bN{}, as the system can still be incomplete (i.e., it cannot express some numbers) or redundant (it has multiple representations of some numbers).

Recall the calculation of vectors from \bN{} in \autoref{sec:numrep}. In this universe, we can encode \bN{} and its interpretation as
\ExecuteMetaData[Ornament/Numerical]{NatND}
In such a calculation, all we really needed was a translation between the type of numbers, and a type of shapes. This encoding precisely captures all information we need to form such a type of shapes.

The essence of the calculation of arrays is that given a number system, we can calculate a datastructure which still has the same shape, and has the correct number of elements. We can generalize the calculation to all number systems while proving that the shape is preserved by presenting the datastructure by an ornamental description.

We could directly compute indexed array, using the index for the proof of representability, and from it the correctness of numbers of elements. However, we give the unindexed array first: we can get the indexed variant for free \cite{algorn}\todo{no, rewrite this}!

\begin{conjecture}
    We claim then\todo{Currently, without proof} that the description given by
    \ExecuteMetaData[Ornament/Numerical]{TrieO-type}
    and the number of elements coincides with the underlying number, as given by \AgdaFunction{ornForget}.
\end{conjecture}
The hard work of \AgdaFunction{TrieO} is done by
\ExecuteMetaData[Ornament/Numerical]{TrieO-con-type}
Let us walk through the definition of \AgdaFunction{TrieO-Con}. Suppose we encounter a leaf of value $k$
\ExecuteMetaData[Ornament/Numerical]{TrieO-1}
then, the trie simply preserves the leaf, and adds a field with a vector of $k$ elements. Trivially the number of elements and the underlying number coincide.

When we encounter a recursive field
\ExecuteMetaData[Ornament/Numerical]{TrieO-rho}
we first preserve this field. The formula used is almost identical to the one in the case of a leaf, but because it is in a recursive parameter, it instead acts to multiply the parameter $A$ by $k$. Using that the number of elements and the underlying number of the recursive field correspond, let this be $r$, we see that we get $r$ times $A^k$. Then, we translate the remainder. It follows that we have $kr$ elements from the recursive field, and by the correctness of the remainder, the total number of elements in \AgdaInductiveConstructor{ρ} also corresponds to the underlying number.

The case for a non-recursive field is similar
\ExecuteMetaData[Ornament/Numerical]{TrieO-sigma}
except we preserve the field directly, and add a field containing its value number of elements. Translating the remainder, the number of elements and the underlying number of a \AgdaInductiveConstructor{σ} coincide.

Consider the case of a description field\footnote{Excuse the formula of \AgdaBoundFontStyle{f''}, it needs to be there for the ornament to work, but doesn't have much to do with the numbers.}
\ExecuteMetaData[Ornament/Numerical]{TrieO-delta}
We essentially rerun the recipe of \AgdaInductiveConstructor{ρ}, multiplying the elements of the field by $k$, but now pass it to the description \AgdaBoundFontStyle{R}. Again, correctness of \AgdaInductiveConstructor{δ} follows directly from the correctness of \AgdaBoundFontStyle{R} and the remainder.


\begin{example}
    
\end{example}
This ``proves'' our construction correct, but let us compare it to an existing numerical representation:
We see that applying \AgdaFunction{TrieO} to \AgdaFunction{NatND} gives us a description which corresponds almost directly to \AgdaFunction{ListD}, only replacing all fields with vectors of length 1.

The reader of \cite{algorn} might question why we are doing the work of \AgdaFunction{TrieOIx} ourselves, rather than making use of \AgdaFunction{ornAlg}.
\begin{remark}
Problems
\begin{enumerate}
    \item an algebra for D gives no algebras for the deltas in D,
    \item no delta means constructors explode.
\end{enumerate}

Solution 1: define other infrastructure for algebras that do have algebras for deltas

Solution 2:
\begin{enumerate}
    \item kill deltas by an intermediate form which explodes,
    \item give up on constructor lists and have big sigma.
\end{enumerate}

Solution 3:
\begin{enumerate}
    \item do deltas via mutual recursion,
    \item mutual recursion already has good algebras.
\end{enumerate}

\end{remark} 

\begin{remark}
    Also, variables are annoying
    \begin{itemize}
        \item centralize variable transforms into one place in deltas
        \item what are ornaments now
    \end{itemize} 

    \begin{itemize}
        \item package descriptions and their thinnings
        \item something happens
    \end{itemize}
\end{remark}

\towrite{Some goals: 1. Ix and paths. 2. Ix n -> A iso IxTrieO n A. 3. something about the correctness of TrieO}


\section{Temporary: future work}

\investigate{This implementation of TrieO always computes the random-access variant of the datastructure. Can we implement a variant which computes the ``Braun tree'' variant of the datastructure?}

\investigate{Index types are a simple ornament over number types: paths. This is not quite like \cite{glookup}.}

\investigate{Is Ix x -> A initial for the algebra of the algebraic ornament induced by TrieO? (This is \cite{calcdata}).}

\investigate{While evidently Ix x != Fin (toN x) for arbitrary number systems, does the expected iso Ix x -> A = Trie A x yield Traversable, for free?}
