Program verification is an indispensible aspect of programming, whether you're coding up your own Asteroids or you're developing a linear algebra library, it would be a waste of time to hunt for bugs which could have been uncovered by random testing. When testing does not offer enough certainty or cannot handle the complexity of the input, we can instead use formal program verification: it would be embarassing if someone else suffers the consequences of a bug in your library, so you might prove your library or parts of it correct in a proof assistant like Coq or Agda. In a more extreme example, you might code directly into a proof assistant, specifying the behaviour of your program beforehand, having it checked while you're implementing it.

Yet, program verification, especially of the last kind, is a double-edged sword: while it becomes easier to write code without bugs, it becomes harder to write code in the first place. A proof assistant has to enforce total and terminating programs (at least by default), as incomplete or circular steps would undermine the correctness of a proof. Non-total operations are abundant in most languages, like getting the first element of a list; such operations would require the programmer to provide evidence that the operation can not fail at each usage. In this example the evidence can be encoded by modifying a list to remember its length, and generally we can create variations on datastructures for use in correct-by-construction programs. 

This might prompt defining variations for each use case, and duplicating all operations on them, making little or no use of the fact that types like lists and vectors are strongly related. But this can be avoided, since a broad class of relations has been tamed by ornaments \cite{algorn, progorn}. Informally, an ornament describes the pieces of information necessary to construct a new type from an existing type.

However, we do not have to stop at relating lists and vectors. Just like vectors can be described as lists with more information, lists can be described as natural numbers with more information \cite{algorn}. This can be generalized to other datastructures, such as binary numbers and trees. The idea of instead constructing datastructures from number systems has been studied as numerical representations \cite{purelyfunctional, calcdata}. This provides a way to talk about datastructures using their underlying numbers, and allows one to mechanically calculate datastructures and some of their properties from these numbers, albeit manually.

By calculating a datastructure, one hopes to gain an isomorphism between the datatype represented as a lookup function, and the concrete version of the datatype. As the representation and the concrete type are equivalent, one can reason about properties of the concrete side by looking at the representation, which is often simpler. In the usual context, one would still have to manually convert proofs back and forth. More conveniently, we would like to apply representation independence; similarly to how equality of indiscernables ensures that exchanging equal terms cannot change the behaviour of a program, the same should hold for isomorphic types. While such results usually only exists in the meta-theory, or can only be applied on concrete types by manually weaving conversions through proofs, structured equivalences \cite{iri} can internalize this, at the cost of using Cubical Agda.

\begin{comment}
We will look at the more specific solution first. This solution is guided by the realization that even though \AgdaDatatype{List} and \AgdaDatatype{Tree} have different recursive structures, they have one commonality; namely, both resemble a number system. Lists and Braun trees\footnote{Braun trees are a kind of binary tree, of which the shape is determined by its size.} can both be presented by deriving them from unary and binary numbers respectively, as is made formal by Hinze and Swierstra \cite{calcdata}. One can then apply this \textit{numerical representation} \cite{purelyfunctional} to simplify or trivialize properties of these datastructures. We will also see that we can interpret numerical interpretations more literally, and construct the representation directly as an ornament.

In the general case, we can apply representation independence. Equality of indiscernables ensures that substituting terms for equal terms cannot change the behaviour of a program, and, as types are terms, the same should hold for types. If we consider two types implementing a given interface, with an operation-preserving isomorphism, then representation independence tells us that the implementations must be functionally equivalent. In the case of trees and lists, this states that since converting a list to a tree preserves \AgdaFunction{lookup}, the outcome of a program that only uses \AgdaFunction{lookup} cannot change when substituting trees for lists. While a proof of this statement usually either exists in the meta-theory, or is produced by manually weaving the conversions through our proofs, Cubical Agda allows us to internalize this independence \cite{iri}.  

We will first take a closer look at SIP \cite{iri} and give concrete examples of proof transport, which we can use to characterize equivalences of flexible two-sided arrays. Then we recall the constructions of numerical representations \cite{calcdata} and ornamentation \cite{progorn}, illustrating how we can define arrays from simpler types by providing interpretations into naturals. We will test these methods by using them to simplify the presentation of finger trees\footnote{A finger tree is a nested type representing a sequence, designed to support amortized constant time en-/dequeueing at both ends, and logarithmic time concatenation and lookup.} \cite{fingertrees}. After that, we will investigate other generic operations, such as the presentation of certain type transformations as ornaments, and the fair enumeration of recursive datatypes.

%merge this

\subsection{Program Verfication}
    %\todo[inline, color=red]{Spend some more time on the context}
    
    However, we can at least say that a good program necessarily ``does what it is supposed to''; which can mean one of many things, from ``my user interface does not hang'' to ``my arithmetic logic unit design computes correctly''. How easy it is to make mistakes also depends on the language one writes in. While in Javascript one might mistakenly add a number and a string, causing bugs down the line, this mistake would be reported during compilation in languages with stronger types, like Java. While in object-oriented languages type-casts are commonplace and form a source of errors, more restrictive systems forbid them or more flexible systems give safe ways around them, but ultimately types only guarantee that the grammar of a program is correct. We would still have to verify the behaviour of the program.
    
    Broadly speaking, program verification concerns itself with establishing program specifications, and verifying that programs behave according to their specifications. One can be confident that a program complies with its specification by testing it against a number of testcases. Simple testing may run the program on a set of inputs with known correct outputs, which is conventionally used to test the program on edge cases: the inputs which one finds most likely to produce incorrect outputs. In more intricate testing, the specification is typically separated from the inputs and is given as a function that computes whether an input-output pair is correct. The inputs can then still be taken from a set, or can be randomly drawn from generators constructed to produce sorts of input specific to the specification. Most of the work organizing these tests is best left to unit testing frameworks, such as QuickCheck, so that the program to be tested, the generators, and the specifications can be written in the same language; the framework can then assemble these into groups of testcases, combining the functionality of randomly generating the inputs, running the tests, and reporting the outcomes.
    
    However, unit testing does not give absolute certainty. Dijkstra (1970): ``Program testing can be used to show the presence of bugs, but never to show their absence!''. If the program fails a test, then we know the program is flawed; if it does not fail, then we have simply not yet found an input on which it fails. When unit testing does not give enough certainty, we can instead try to prove the program to be correct. While not without pitfalls, if we view a program as a composition of mathematical functions, then we may be able to show its correctness by applying sequences of accepted rewriting rules. For example, a program computing an integer function is certainly correct if it reduces to this function after applying arithmetical rules. While a proof promises a lot about the correctness of a program, it will certainly take more effort to produce than the corresponding unit test. Furthermore, the correctness of the proof itself, which typically lives ``on paper'', would now have to be verified as well.
    
    \subsection{Proof Assistants}
    To ensure correctness of proofs, we can turn to proof assistants: Agda \cite{agda} is a functional programming language and a proof assistant, taking inspiration from languages like Haskell and other proof assistants such as Coq. We can write programs as we would in Haskell, and then express and prove their properties all inside Agda. This allows us to demonstrate the correctness of programs by formal proof rather than by testing. However, this level of formality also trades-off the uncertainty of testing for a time-investment to produce these proofs. In this thesis, we will explore a variety of methods of proving properties of our programs, focusing on the problems that one may encounter, presenting solutions as they arise. Let us sketch some of these problems.
    
    %\towrite{Expand here about code generation/generics}
    % explain, the agda mindset endangers the conciseness of code in some situations
    
    \towrite{Expand here about List}
    
    First, merely adapting a program to Agda may already require changes to the datatypes used in it; for example, if a program manipulating a \AgdaDatatype{List} uses the unsafe \AgdaFunction{head} function, then one is forced to replace the \AgdaDatatype{List} by a datatype that ensures non-emptiness, such as a \AgdaDatatype{NonEmpty} list or a length-aware vector \AgdaDatatype{Vec}. On the other hand, there might be sections of a program where the concrete length is not relevant for correctness and only gets in the way. As a result, one might find themselves duplicating common functions like concatenation \AgdaFunction{\_++\_} to only alter their signatures.
    
    However, the ``new'' datatype (\AgdaDatatype{Vec}) is typically a simple variation on the old datatype (\AgdaDatatype{List}) making small adjustments to the existing constructors; in this case, we decorate the nil and cons constructors with natural numbers representing the length. 
    
    \subsection{Initial Semantics}
    \towrite{Expand here about initial algebras}
    
    This kind of modification of types falls in the framework of \emph{ornamentation} \cite{progorn}; if two types are reified to their \emph{descriptions}, then \emph{ornaments} express whether the types are ``similar'' by acting as a recipe to produce one type from the other. By restricting the operations to the copying of corresponding parts, and the introduction of fields or dropping of indices, the existence of such an ornament ensures that the types have the same recursive structure. In general, ornaments allow us to introduce invariants into existing types, so that, as an example, one can derive ordered versions of lists or trees from their ordinary variants. Furthermore, using \emph{patches} \cite{orntrans}, we can in one direction ensure that \AgdaFunction{\_++\_} on \AgdaDatatype{Vec} agrees with its version for \AgdaDatatype{List} under the ornament; in the other direction, a patch can also help us while defining this lifted variant.
    
    
    \subsection{Representation Independence}
    Using ornaments, we can organize similar datatypes using ornaments; but we will also make use of relations between dissimilar datatypes. It is conventional to prototype a program using simpler types or implementations, and only replace these with more performant alternatives in critical places. %knowing that this is eventually going to happen, one might as well prepare for it.
    While this may quickly turn into a refactoring nightmare in the general case, we can hope for a more satisfying transition if we restrict our attention to a narrower scope. As an example, we might start programming using \AgdaDatatype{List}s, but replace this with a \AgdaDatatype{Tree} if we notice that the program spends most of its time in \AgdaFunction{lookup} operations. To gain a speedup, we will have to reimplement the operations on \AgdaDatatype{Tree}. This would also double the number of necessary proofs; however, we have two ways to avoid this problem. 
    
    \towrite{Expand here about interfaces and normal representation independence}
    
    We will look at the more specific solution first. This solution is guided by the realization that even though \AgdaDatatype{List} and \AgdaDatatype{Tree} have different recursive structures, they have one commonality; namely, both resemble a number system. Lists and Braun trees\footnote{Braun trees are a kind of binary tree, of which the shape is determined by its size.} can both be presented by deriving them from unary and binary numbers respectively, as is made formal by Hinze and Swierstra \cite{calcdata}. One can then apply this \emph{numerical representation} \cite{purelyfunctional} to simplify or trivialize properties of these datastructures. We will also see that we can interpret numerical interpretations more literally, and construct the representation directly as an ornament.
    
    In the general case, we can apply representation independence. Equality of indiscernables ensures that substituting terms for equal terms cannot change the behaviour of a program, and, as types are terms, the same should hold for types. If we consider two types implementing a given interface, with an operation-preserving isomorphism, then representation independence tells us that the implementations must be functionally equivalent. In the case of trees and lists, this states that since converting a list to a tree preserves \AgdaFunction{lookup}, the outcome of a program that only uses \AgdaFunction{lookup} cannot change when substituting trees for lists. While a proof of this statement usually either exists in the meta-theory, or is produced by manually weaving the conversions through our proofs, 
    
    \towrite{Expand here about Cubical Agda.}
    
    Cubical Agda allows us to internalize this independence \cite{iri}.  
    
    We will first take a closer look at SIP \cite{iri} and give concrete examples of proof transport, which we can use to characterize equivalences of flexible two-sided arrays. Then we recall the constructions of numerical representations \cite{calcdata} and ornamentation \cite{progorn}, illustrating how we can define arrays from simpler types by providing interpretations into naturals. We will test these methods by using them to simplify the presentation of finger trees\footnote{A finger tree is a nested type representing a sequence, designed to support amortized constant time en-/dequeueing at both ends, and logarithmic time concatenation and lookup.} \cite{fingertrees}. After that, we will investigate other generic operations, such as the presentation of certain type transformations as ornaments, and the fair enumeration of recursive datatypes.
    
    
    %\section{\toremove{Introduction}}
    %The dependently typed functional programming language Agda \cite{agda} can, when restricted to its reasonable parts, be translated into readable and safe Haskell \cite{agda2hs}. However, the intrinsic safety of languages like Agda can also lead to code duplication by encouraging the use of multiple variants of the same datatype. As an example, the coverage check forces the \AgdaFunction{head} function on \AgdaDatatype{List} to return a \AgdaDatatype{Maybe}. This \AgdaDatatype{Maybe} can be avoided by moving to the length-indexed list type \AgdaDatatype{Vec}, at the cost of duplicating functions like \AgdaFunction{\_++\_}, which we need at both types.
    
    %Something similar happens when replacing an implementation with a more efficient one. For example, when implementing binary trees as a more efficient alternative to lists, the proofs of the same properties will differ between list and tree, and tend to be more difficult for the latter. Switching between implementations of an interface not only duplicates code, but also (and sometimes more than) doubles the effort required to verify both.\todo[inline, color=red]{concrete example?}
    
    %There is plenty of prior work dealing with problems like these. The work in \cite{orntrans} and \cite{progorn} provides the means to relate similar datatypes, such as lists and vectors, using the mechanism of ornamentation, letting us organize variants of the same datatype in a rigid framework.  %This leads them to define the concept of patches, which can aid us when defining \AgdaFunction{\_++\_} for the second time by forcing the new version to be coherent.
    %In fact, the algebraic nature of ornaments yields the definition of the vector type for free, provided we relate lists to natural numbers \cite{algorn}. %Such constructions rely heavily on descriptions of datastructures and often come with limitations in their expressiveness. These descriptions in turn impose additional ballast on the programmer, leading us to investigate reflection like in \cite{practgen} as a means to bring datatypes and descriptions closer when possible.
    
    %Other work like \cite{calcdata}\todo[inline, color=red]{don't use \textbackslash cite as noun} simplifies the proofs relating to certain containers directly, formally executing the way of though of numerical representations as noted in \cite{purelyfunctional}.
    %From another point of view, lists and trees are not so different at all, provided we look at them through the interface of one-sided flexible arrays; this idea noted in \cite{purelyfunctional} and formalized in \cite{calcdata} where both are shown to be instances of numerical representations by calculating them from a numeral system. 
    
    %When two types are isomorphic and equivalent under an interface, proofs of properties of these implementations should be interconvertible. By using structured equivalences and univalence, \cite{iri} characterizes equivalences under interfaces.
    %While this is achievable through meta-programming, substituting conversions to and from into the proof terms, this is internally expressible in Cubical Agda.
    
    %We can liken the situation to movement on a plane, where ornamentation moves us vertically by modifying constructors or indices, and structured equivalences move us horizontally to and from equivalent but more equivalent implementations. In this paper, we will investigate a variety of means of moving around structures and proofs, and ways to make this more efficient or less intrusive.
    
    %In \autoref{sec:leibniz}, we will follow \cite{iri}, and look at how proofs on unary naturals can be transported to the binary naturals. Then in \autoref{sec:numrep} we recall how numeral systems in particular induce container types in \cite{calcdata}, which we attempt to reformulate in the language of ornaments in \autoref{ssec:ornaments}, using the framework of \cite{progorn}. In \autoref{sec:userfriendly} we investigate how we can make the earlier methods more easily accessible to the user, and, ourselves, when we give a description of finger trees in \autoref{sec:fingertrees}.\todo[inline, color=red]{Ok, but make the research question more concrete}
\end{comment}

% https://q.uiver.app/?q=WzAsMTYsWzMsMSwiXFx0ZXh0e3ZlcmlmaWNhdGlvbn0iXSxbMiwyLCJcXHRleHR7bnVtZXJpY2FsIHJlcHJlc2VudGF0aW9uc30iXSxbMiw1LCJcXHRleHR7b3JuYW1lbnRzfSJdLFsxLDMsIlxcdGV4dHtTSVB9Il0sWzAsMiwiXFx0ZXh0e2VxdWl2YWxlbmNlc30iXSxbMSw0LCJcXHRleHR7ZGVzY3JpcHRpb25zfSJdLFszLDIsIlxcdGV4dHtmaW5nZXIgdHJlZXN9Il0sWzAsNSwiXFx0ZXh0e3BhdGhzIGJldHdlZW4gZml4cG9pbnRzfSJdLFsyLDYsIlxcdGV4dHtoZXRlcm9nZW5pemF0aW9ufSJdLFszLDMsIlxcdGV4dHtuZXN0ZWQgdHlwZXN9Il0sWzEsMiwiXFx0ZXh0e2N1YmljYWx9Il0sWzAsMCwiXFxidWxsZXQiXSxbMCwxLCJcXGJ1bGxldCJdLFsxLDAsIlxcYnVsbGV0Il0sWzEsMSwiXFxidWxsZXQiXSxbNCwyLCJcXHRleHR7ZW51bWVyYXRpb259Il0sWzEsMiwiIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzEsMywiIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzIsNV0sWzQsNywiIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzIsOCwiIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzYsOSwiIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzUsNywiIiwyLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoiZGFzaGVkIn19fV0sWzMsMTBdLFszLDRdLFsxMiwxMSwiXFx0ZXh0e3JlcXVpcmVzfSIsMl0sWzEzLDE0LCJcXHRleHR7bGVhZHMgdG8gfSIsMCx7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDEsIiIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDYsIiIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6ImRhc2hlZCJ9fX1dLFswLDE1LCIiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbMSw2LCIiLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XV0=
\begin{figure}
\[\adjustbox{max width=\textwidth}{\begin{tikzcd}
	\bullet & \bullet \\
	\bullet & \bullet && {\text{verification}} \\
	{\text{equivalences}} & {\text{cubical}} & {\text{numerical representations}} & {\text{finger trees}} & {\text{enumeration}} \\
	& {\text{SIP}} && {\text{nested types}} \\
	& {\text{descriptions}} \\
	{\text{paths between fixpoints}} && {\text{ornaments}} \\
	&& {\text{heterogenization}}
	\arrow[dashed, from=3-3, to=6-3]
	\arrow[dashed, from=3-3, to=4-2]
	\arrow[from=6-3, to=5-2]
	\arrow[dashed, from=3-1, to=6-1]
	\arrow[dashed, from=6-3, to=7-3]
	\arrow[dashed, from=3-4, to=4-4]
	\arrow[dashed, from=5-2, to=6-1]
	\arrow[from=4-2, to=3-2]
	\arrow[from=4-2, to=3-1]
	\arrow["{\text{requires}}"', from=2-1, to=1-1]
	\arrow["{\text{leads to }}", dashed, from=1-2, to=2-2]
	\arrow[dashed, from=2-4, to=3-3]
	\arrow[dashed, from=2-4, to=3-4]
	\arrow[dashed, from=2-4, to=3-5]
	\arrow[dashed, from=3-3, to=3-4]
\end{tikzcd}}\]
\caption{Temporary overview}
\end{figure}