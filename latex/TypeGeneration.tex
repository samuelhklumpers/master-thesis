Suppose that we started writing and verifying some code using a vector-based implementation of the two-sided flexible array interface, but later decide to reimplement more efficiently using trees. It would be a shame to lay aside our vector lemmas, and rebuild the correctness proofs for trees from scratch. Instead, we note that both vectors and trees can be represented by their \AgdaFunction{lookup} function. In fact, we can ask for more, and rather than defining an array-like type and then showing that it is represented by a lookup function, we can go the other way around and define types by insisting that they are equivalent to such a function. This approach, in particular the case in which one calculates a container with the same shape as a numeral system, was dubbed numerical representations by Okasaki \cite{purelyfunctional}, and has some formalized examples due to Hinze and Swierstra \cite{calcdata} and Ko and Gibbons \cite{progorn}. Numerical representations are our starting point for defining more complex datastructures based on simpler ones, so we demonstrate such a calculation. 

\subsection{From numbers to containers}\label{ssec:numrep}
We can compute the type of vectors starting from \bN{}.\todo[inline]{Is there a simple twist or other interesting example that we can run through instead, or would anything else be too abrupt without starting from this simple case?}\footnote{This is adapted (and fairly abridged) from Calculating Datastructures \cite{calcdata}} For simplicity, we define them as a type computing function via the ``use-as-definition`` notation from before. We expect vectors to be represented by 
\ExecuteMetaData[Tex/NumRep]{Lookup}
where we use the finite type \AgdaDatatype{Fin} as an index into vector. Using this representation as a specification, we can compute both \AgdaDatatype{Fin} and a type of vectors. The finite type can be computed from the evident definition
\ExecuteMetaData[Tex/NumRep]{Fin-def}
using
\ExecuteMetaData[Tex/NumRep]{leq-split}
Likewise, vectors can be computed by applying a sequence of type isomorphisms
\ExecuteMetaData[Tex/NumRep]{Vec}
\investigate{SIP doesn't mesh very well with indexed stuff, does HSIP help?}

We can implement the following interface using \AgdaDatatype{Vec}
\ExecuteMetaData[Tex/NumRep]{Array}
and show that this satisfies some usual laws like
\ExecuteMetaData[Tex/NumRep]{Laws}
Since we defined \AgdaDatatype{Vec} such that it agrees with \AgdaDatatype{Lookup}, we can relate their implementations as well.

The implementation of arrays as functions is straightforward
\ExecuteMetaData[Tex/NumRep]{FunArray}
and clearly satisfies our interface
\ExecuteMetaData[Tex/NumRep]{FunLaw}
We can implement arrays based on \AgdaDatatype{Vec} as well\footnote{Note that, like any other type computing representation, we pay the price by not being able to pattern match directly on our type.}
\ExecuteMetaData[Tex/NumRep]{VecArray}
Now, rather than rederiving the laws for vectors, the equality allows us to transport them from \AgdaDatatype{Lookup} to \AgdaDatatype{Vec}.\footnote{Except that due to the simplicity of this case, the laws are trivial for \AgdaDatatype{Vec} as well.}
\investigate{As you can see, taking ``use-as-definition'' too literally prevents Agda from solving a lot of metavariables.}

\investigate{This computation can of course be generalized to any arity zeroless numeral system; unfortunately beyond this set of base types, this ``straightforward'' computation from numeral system to container loses its efficacy. In a sense, the n-ary natural numbers are exactly the base types for which the required steps are convenient type equivalences like $(A + B) \to C = (A \to C) \times (B \to C)$?}

%\subsection{Relating types by structure: Ornamentation (unfinished)}\label{sec:ornament}
\subsection{Numerical representations as ornaments}\label{ssec:ornaments}
Reflecting on this derivation for \bN{}, we could perform the same computation for \bL{} to get Braun trees. However, we note that these computations proceed with roughly the same pattern: each constructor of the numeral system gets assigned a value, and is amended with a field holding a number of elements and subnodes using this value as a ``weight''. This kind of ``modifying constructors'' is formalized by ornamentation \cite{progorn}, which lets us formulate what it means for two types to have a ``similar'' recursive structure. This is achieved by interpreting (indexed inductive) datatypes from descriptions, between which an ornament is seen as a certificate of similarity, describing which fields or indices need to be introduced or dropped to go from one description to the other. \textit{Ornamental descriptions}, which act as one-sided ornaments, let us describe new datatypes by recording the modifications to an existing description.
\todo[inline]{Put some minimal definitions here.}

Looking back at \AgdaDatatype{Vec}, ornaments let us show that express that \AgdaDatatype{Vec} can be formed by introducing indices and adding a fields holding an elements to \bN{}.%\footnote{These and similar examples are also documented in \cite{progorn}} 
However, deriving \AgdaDatatype{List} from \bN{} generalizes to \bL{} with less notational overhead, so we tackle that case first. We use the following description of \bN{}
\ExecuteMetaData[Tex/NumRepOrn]{NatD}
Here, \AgdaInductiveConstructor{œÉ} adds a field to the description, upon which the rest of the description can vary, and \AgdaInductiveConstructor{·πø} lists the recursive fields and their indices (which can only be \AgdaInductiveConstructor{tt}).
We can now write down the ornament which adds fields to the \AgdaFunction{suc} constructor
\ExecuteMetaData[Tex/NumRepOrn]{ListO}
Here, the \AgdaInductiveConstructor{œÉ} and \AgdaInductiveConstructor{·πø} are forced to match those of \AgdaDatatype{NatD},
but the \AgdaInductiveConstructor{Œî} adds a new field. Using the least fixpoint and description extraction, we can then define \AgdaDatatype{List} from this ornamental description. Note that we cannot hope to give an unindexed ornament from \bL{}
\ExecuteMetaData[Tex/NumRepOrn]{LeibnizD}
into trees, since trees have a very different recursive structure! Thus, we must keep track at what level we are in the tree so that we can ask for adequately many elements:
\ExecuteMetaData[Tex/NumRepOrn]{TreeO}
We use the \AgdaFunction{power} combinator to ensure that the digit at position $n$, which has weight $2^n$ in the interpretation of a binary number, also holds its value times $2^n$ elements. This makes sure that the number of elements in the tree shaped after a given binary number also is the value of that  binary number.

%This ``folding in'' technique using the indices to keep track of structure seems to apply more generally. Let us explore this a bit further, and return later to the generalization of the pattern from numeral systems to datastructures.
% i.e. why did this even work?

\subsection{Heterogeneization}
The situation in which one wants to collect a variety of types is not uncommon, and is typically handled by tuples. However, if e.g., you are making a game in Haskell, you might feel the need to maintain a list of ``Drawables'', which may be of different types. Such a list would have to be a kind of ``heterogeneous list''. In Haskell, this can be resolved by using an existentially quantified list, which, informally speaking, can contain any type implementing a given constraint, but can only be inspected as if it contains the intersection of all types implementing this constraint. 

This ports directly to Agda, but becomes cumbersome quickly, and impractical if we want to be able to inspect the elements. The alternative is to split our heterogeneous list into two parts; one tracking the types, and one tracking the values. In practice, this means that we implement a heterogeneous list as a list of values indexed over a list of types. This approach and mainly its specialization to binary trees is investigated by Swierstra \cite{hetbin}.

We will demonstrate that we can express this ``lift a type over itself'' operation as an ornament. For this, we make a small adjustment to \AgdaDatatype{RDesc} to track a type parameter separately from the fields. Using this we define an ornament-computing function, which given a description computes an ornamental description on top of it:
\todo{Oops}
\ExecuteMetaData[Tex/Heterogenize]{HetO}
This ornament relates the original unindexed type to a type indexed over it; we see that this ornament largely keeps all fields and structure identical, only performing the necessary bookkeeping in the index, and adding extra fields before parameters.

As an example, we adapt the list description
\ExecuteMetaData[Tex/Heterogenize]{List}
which is easily heterogeneized to an \AgdaDatatype{HList}. In fact, \AgdaFunction{HetO} seems to act functorially; if we lift \AgdaDatatype{Maybe} like
\ExecuteMetaData[Tex/Heterogenize]{HMaybe}
then we can lift functions like \AgdaFunction{head} as
\ExecuteMetaData[Tex/Heterogenize]{hhead}


\begin{comment}
\subsection{Folding in}\label{ssec:flattening}
Let us describe this procedure of folding a complex recursive structure into a simpler structure more generally. In particular, we will demonstrate that for linear datatypes, such as \bN{} and \bL{}, and for a given unindexed datatype, there is always an indexed datatype isomorphic to it at some index, and an ornament from the linear type to the indexed type. 

Suppose we are given a description, the first thing we can do to simplify it is collect all fields in one place
\ExecuteMetaData[Tex/Flatten]{RField}
Next, we will certainly have to count the number of recursive occurrences we are tracking, so we define
\ExecuteMetaData[Tex/Flatten]{Number}
where \AgdaInductiveConstructor{ùüô} records that we are at the top level, and \AgdaInductiveConstructor{·πø} denotes that we are below a constructor with some number of recursive fields. This simplifies our task to implementing the types in
\ExecuteMetaData[Tex/Flatten]{nested}
such a way that we get an isomorphism 
\ExecuteMetaData[Tex/Flatten]{wish}
Thus, \AgdaDatatype{Fields} is forced to have a \AgdaInductiveConstructor{leaf} constructor like 
\ExecuteMetaData[Tex/Flatten]{Fields}
if \AgdaFunction{nested} is to work at \AgdaInductiveConstructor{ùüô}. The \AgdaInductiveConstructor{node} constructor makes sure that if we have collection of \AgdaDatatype{Fields}, then we can gather them in a field at a higher level. We can then count the subnodes of a given \AgdaDatatype{Fields} as
\ExecuteMetaData[Tex/Flatten]{subnodes}
where \AgdaFunction{RSize} counts the number of recursive fields of a particular branch
\ExecuteMetaData[Tex/Flatten]{RSize}
Note that \AgdaFunction{subnodes} effectively keeps the shape of the previous field, but unfolds the recursive fields at the bottom of the tree by one level.

\investigate{I then tried and realized how unpleasant even the functions from the original type to the nested type are to write.}

As a trivialty, we get that any type, interpreted as a container, always decomposes as an ornament over a ``numerical'' base type.\todo[inline]{Or at least, that was where I was trying to go with this, but I notice that this still is a bit further away.} This links to the construction of binary heaps in \cite{progorn}, as in hindsight, starting from the usual binary heaps would yield binary numbers and their binary heap ornament (in a much less useful package).
\end{comment}
