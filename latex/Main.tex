\documentclass[10pt]{article}

\usepackage[style=alphabetic]{biblatex}
\addbibresource{refs.bib}

\usepackage{comment}

\setlength{\marginparwidth}{2cm} % this makes \todo{}s explode less, remove when done

\usepackage{todonotes}
\usepackage{xcolor}
\usepackage[hidelinks]{hyperref}


\usepackage{catchfilebetweentags}
\usepackage{quiver} 
\usepackage{tabularx}
% \usepackage{adjustbox}
% \usepackage{longtable}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{listings}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{conjecture}{Conjecture}[section]
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{remark}{Remark}[section]
\newtheorem{claim}{Claim}[section]
\newtheorem{example}{Example}[section]

\renewcommand{\partautorefname}{Part}
\renewcommand{\sectionautorefname}{Section}
\renewcommand{\subsectionautorefname}{Subsection}

\providecommand{\theoremautorefname}{Theorem}
\providecommand{\lemmaautorefname}{Lemma}
\providecommand{\propautorefname}{Proposition}
\providecommand{\conjectureautorefname}{Conjecture}
\providecommand{\corautorefname}{Corollary}
\providecommand{\defnautorefname}{Definition}
\providecommand{\remarkautorefname}{Remark}
\providecommand{\exampleautorefname}{Example}
\providecommand{\claimautorefname}{Claim}


\usepackage[links]{agda}
% \AtBeginEnvironment{code}{\fontsize{8}{10}}
\AgdaNoSpaceAroundCode{}

\usepackage{fontspec}
\usepackage{luaotfload}

\directlua{luaotfload.add_fallback
  ("myfallback",
    { "JuliaMono:style=Regular;"
    , "NotoSansMono:style=Regular;"
    , "NotoSansMath:style=Regular;"
    , "Segoe UI Emoji:mode=harf;"
    }
  )}
\defaultfontfeatures{RawFeature={fallback=myfallback}}

\setmainfont{Latin Modern Roman}

\newfontfamily{\AgdaSerifFont}{JuliaMono Regular}[Scale=0.8]
\newfontfamily{\AgdaSansSerifFont}{JuliaMono Regular}[Scale=0.8]
\newfontfamily{\AgdaTypewriterFont}{JuliaMono Regular}[Scale=0.8]
\setmonofont{JuliaMono Regular}[Scale=0.8]
\renewcommand{\AgdaFontStyle}[1]{{\AgdaSansSerifFont{}#1}}
\renewcommand{\AgdaKeywordFontStyle}[1]{{\AgdaSansSerifFont{}#1}}
\renewcommand{\AgdaStringFontStyle}[1]{{\AgdaTypewriterFont{}#1}}
\renewcommand{\AgdaCommentFontStyle}[1]{{\AgdaTypewriterFont{}#1}}
\renewcommand{\AgdaBoundFontStyle}[1]{\textit{\AgdaSerifFont{}#1}}

\newcommand{\AF}[1]{\AgdaFunction{#1}}
\newcommand{\AD}[1]{\AgdaDatatype{#1}}
\newcommand{\AR}[1]{\AgdaRecord{#1}}
\newcommand{\AV}[1]{\AgdaBoundFontStyle{#1}}
\newcommand{\AIC}[1]{\AgdaInductiveConstructor{#1}}
\newcommand{\ARF}[1]{\AgdaField{#1}}

\definecolor{git-green}{HTML}{13A10E}
\definecolor{git-orange}{HTML}{C69026}
\definecolor{nondescriptyellow}{HTML}{D6B656}

\newcommand{\added}[1]{\textcolor{git-green}{+#1}}
\newcommand{\changed}[1]{\textcolor{git-orange}{$\bullet$#1}}
\newcommand{\towrite}[1]{\todo[color=cyan]{#1}}
\newcommand{\toremove}[1]{\textcolor{red}{This is going to be (re)moved: ``#1''}}

  
\lstnewenvironment{semicomment}{\color{gray}\lstset{breaklines=true}}{}
\lstnewenvironment{outline}{\color{nondescriptyellow}\lstset{breaklines=true}}{}

\newcommand{\investigate}[1]{\par\vspace{1\baselineskip}\textcolor{gray}{#1}\vspace{1\baselineskip}\par}

\newcommand{\bN}{\AgdaDatatype{ℕ}}
\newcommand{\bL}{\AgdaDatatype{Leibniz}}


\title{Ornaments and Proof Transport applied to Numerical Representations}
\author{Samuel Klumpers\\6057314}


\begin{document}
\maketitle

\begin{abstract}
The dependently typed functional programming language Agda encourages defining custom datatypes to write correct-by-construction programs with\todo{long}. In some cases, even those datatypes can be made correct-by-construction, by manually distilling them from a mixture of requirements, as opposed to pulling them out of thin air\todo{distracted}. This is in particular the case for numerical representations, a class of datastructures inspired by number systems, containing structures such as linked lists and binary trees. However, constructing datatypes in this manner, and establishing the necessary relations between them can quickly become tedious and duplicative.

In the general case, employing datatype-generic programming can curtail code-duplication by allowing the definition of constructions that can be instantiated to a class of types. Furthermore, ornaments make it possible to succinctly describe relations between structurally similar types.

In this thesis, we apply generic programming and ornaments to numerical representations, giving a recipe to compute such a representation from a provided number system.
For this, we describe a generic universe and a type of ornaments on it, allowing us to formulate the recipe as an ornament from a number system to the computed datatype.
\end{abstract}


\begin{comment}
This thesis explains the concepts numerical representations and ornaments, and aims to combine these to simplify the presentation and verification of finger trees. We demonstrate the generalizability and easier verification of the resulting code. Further, we also investigate to which extent descriptions and ornaments, and generic programs built on top of these, remain effective in a setting without axiom K.
\end{comment}
    

\tableofcontents

\listoftodos

\section{Introduction}\label{sec:introduction}
\input{Introduction}


\part*{Background}\label{part:background}
\addcontentsline{toc}{part}{\nameref{part:background}}
\todo{go emph pass}
\todo{go cite pass}
We extend upon existing work in the domain of generic programming and ornaments, so let us take a closer look at the nuts and bolts to see what all the concepts are about.

We will describe some common datatypes and how they can be used for programming, exploring how dependent types also let us use datatypes to prove properties of programs, or write programs that are correct-by-construction, leading us to discuss descriptions of datatypes and ornaments.
    
\input{Background}


\part{Descriptions}\label{part:ornament}
%outline:
%we explained why descriptions and ornaments are crucial to achieve our goals
%however, the descriptions we explained earlier are not powerful enough to house finger trees


%To capture finger trees as an ornament over a number system, we will need to describe ornaments over nested datatypes. In this section we will work out descriptions and ornaments suitable for nested datatypes.
If we are going to simplify working with complex sequence types %, such as finger trees,
by instantiating generic programs to them, we should first make sure that these types fit into the descriptions. We construct descriptions for nested datatypes by extending the encoding of parametric and indexed datatypes from \autoref{ssec:background-ix} with three features: information bundles, parameter transformation, and description composition. Also, to make sharing constructors easier, we introduce variable transformations. Transforming variables before they are passed to child descriptions allows both aggressively hiding variables and introducing values as if by let-constructs.

We base the encoding of off existing encodings \cite{sijsling,practgen}. The descriptions take shape as sums of products, enforce indices at leaf nodes, and have explicit parameter and variable telescopes. Unlike some other encodings \cite{effectfully, practgen}, we do not allow higher-order inductive arguments. We use \texttt{--type-in-type} and \texttt{--with-K} to simplify the presentation, noting that these can be eliminated respectively by moving to \AD{Typeω} and by implementing interpretations as datatypes, as described in \autoref{app:withoutk}.

\input{Descriptions}


\part{Ornaments}\label{part:ornament2_rename_the_other}
\input{Ornaments}


\part{Numerical representations}\label{part:numrep}
\input{GNumrep}

\part{Related work}\label{part:related}
\begin{comment}
\section{Descriptions and ornaments}
We compare our implementation to a selection of previous work, considering the following features


\begin{tabular}{c | c c c c c}
             & Haskell        & \cite{initenough} & \cite{levitation} & \cite{algorn} & \cite{progorn} \\
    \hline                                                                                             
    Fixpoint & yes*           & yes               & no                & yes?          & yes            \\
    Index    & —              & —                 & first**           & equality      & first          \\
    Poly     & yes            & 1                 & external          & external      & external       \\
    Levels   & —              & —                 & no                & no            & no             \\
    Sums     & list           & —                 & large             & large         & large          \\
    IndArg   & any            & any               & $\dots \to X\ i$  & $X\ i$        & $X\ i$         \\
    Compose  & yes            & yes               & no                & no            & no             \\
    Extension& —              & —                 & no                & —             & —              \\
    Ignore   & —              & —                 & —                 & —             & —              \\
    Set      & —              & —                 & —                 & —             & —              \\
\end{tabular}


\begin{tabular}{c | c c c c c}
             & \cite{sijsling} & \cite{effectfully} & \cite{practgen} & Shallow   & Deep (old) \\
    \hline   
    Fixpoint & yes             & yes                & no              & yes       & yes     \\
    Index    & equality        & equality           & equality        & equality  &         \\
    Poly     & telescope       & external           & telescope       & telescope &         \\
    Levels   & no***           & cumulative         & Typeω           & Type-in-Type &         \\
    Sums     & list            & large              & list            & list      &         \\
    IndArg   & $X\ pv\ i$      & $\dots\to X\ v\ i$ & $\dots\to X\ pv\ i$ & $X (f pv) i$ & ?1 \\
    Compose  & no              & yes?2              & no              & yes       &         \\
    Extension& —               & yes                & yes             & no        &         \\
    Ignore   & no              & ?                  & ?               & transform &         \\
    Set      & no              & no                 & no              & no        & yes     \\
\end{tabular}





\begin{itemize}
    \item IndArg: the allowed shapes of inductive arguments. Note that none other than Haskell, higher-order functors, and potentially ?1, allow full nested types!
    \item Compose: can a description refer to another description?
    \item Extension: do inductive arguments and end nodes, and sums and products coincide through a top-level extension?
    \item Ignore: can subsequent constructor descriptions ignore values of previous ones? (Either this, or thinnings, are essential to make composites work)
    \item Set: are sets internalized in this description?
\end{itemize}

\begin{itemize}
    \item[*] These descriptions are ``coinductive'' in that they can contain themselves, so the ``fixpoint'' is more like a deep interpretation.
    \item[**] This has no fixpoint, and the generalization over the index is external.
    \item[***] But you could bump the parameter telescope to Typeω and lose nothing.
    \item[*4] A variant keeps track of the highest level in the index.
    \item[?1] Deeply encoding all involved functors would remove the need for positivity annotations for full nested types like in other implementations.
    \item[?2] The ``simplicity'' of this implementation, where data and constructor descriptions coincide, automatically allows composite descriptions.
\end{itemize}

We take away some interesting points from this:
\begin{itemize}
    \item Levels are important, because index-first descriptions are incompatible with ``data-cumulativity'' when not emulating it using equalities! (This results in datatypes being forced to have fields of a fixed level).
    \item Coinductive descriptions can generate inductive types!
    \item Typeω descriptions can generate types of any level!
    \item Large sums do not reflect Agda (a datatype instantiated from a derived description looks nothing like the original type)! On the other hand, they make lists unnecessary, and simplify the definition of ornaments as well.
    \item We can group/collapse multiple signatures into one using tags, this might be nice for defining generic functions in a more collected way.
    \item Everything becomes completely unreadable without opacity.
\end{itemize}

\subsection{Merge me}


\subsubsection{Ornamentation}
While we can derive datastructures from number systems by going through their index types \cite{calcdata}, we may also interpret numerical representations more literally as instructions to rewrite a number system to a sequence type. We can record this transformation internally using ornaments, which can then be used to derive the associated type of arrays\cite{algorn}, or can be modified further to naturally integrate other constraints, e.g., ordering, into the resulting structure \cite{progorn}. Furthermore, we can also use the forgetful functions induced by ornaments to generate specifications for functions defined on the ornamented types \cite{orntrans}.

\subsubsection{Generic constructions}
Being able to define a datatype and reflect its structure in the same language opens doors to many more interesting constructions \cite{practgen}; a lot of ``recipes'' we recognize, such as defining the eliminators for a given datatype, can be formalized and automated using reflection and macros. We expect that other type transformations can also be interpreted as ornaments, like the extraction of heterogeneous binary trees from level-polymorphic binary trees \cite{hetbin}. 


\subsection{Takeways}
At the very least, descriptions will need sums, products, and recursive positions as well. While we could use coinductive descriptions, bringing normal and recursive fields to the same level, we avoid this as it also makes ornaments a bit more wild\footnote{For better or worse, an ornament could refer to a different ornament for a recursive field.}. We represent indexed types by parametrizing over a type $I$. Since we are aiming for nested types, external polymorphism\footnote{E.g., for each type $A$ a description of lists of $A$ à la \cite{progorn}} does not suffice: we need to let descriptions control their contexts.

We describe parameters by defining descriptions relative to a context. Here, a context is a telescope of types, where each type can depend on all preceding types:
\[ \dots \]
Much like the work Escot and Cockx \cite{practgen} we shove everything into \AgdaFunction{Typeω}, but we do not (yet) allow parameters to depend on previous values, or indices on parameters\footnote{I do not know yet what that would mean for ornaments.}.

We use equalities to enforce indices, simply because index-first types are not honest about being finite, and consequently mess up our levels. For an index type and a context a description represents a list of constructors:
\[ \dots \]
These represent lists of alternative constructors, which each represent a list of fields:
\[ \dots \]
We separate mere fields from ``known'' fields, which are given by descriptions rather than arbitrary types. Note that we do not split off fields to another description, as subsequent fields should be able to depend on previous fields
\[ \dots. \]


We parametrize over the levels, because unlike practical generic, we stay at one level.

Q: what happens when you precompose a datatype with a function? E.g. (List . f) A = List (f A) 

Q: practgen is cool, compact, and probably necessary to have all datatypes. Note that in comparison, most other implementations (like Sijsling) do not allow functions as inductive arguments. Reasonably so.

Q: I should probably update my Agda and make use of the new opaque features to make things readable when refining


\towrite{Adapt this to the non-proposal form.}

\section{The Structure Identity Principle}
If we write a program, and replace an expression by an equal one, then we can prove that the behaviour of the program can not change. Likewise, if we replace one implementation of an interface with another, in such a way that the correspondence respects all operations in the interface, then the implementations should be equal when viewed through the interface. Observations like these are instances of ``representation independence'', but even in languages with an internal notation of type equality, the applicability is usually exclusive to the metatheory.

In our case, moving from Agda's ``usual type theory'' to Cubical Agda, \textit{univalence} \cite{cuagda} lets us internalize a kind of representation independence known as the Structure Identity Principle \cite{iri}, and even generalize it from equivalences to quasi-equivalence relations. 
%a cubical homotopy type theory,
We will also be able to apply univalence to get a true ``equational reasoning'' for types when we are looking at numerical representations.

Still, representation independence in may be internalized outside the homotopical setting in some cases \cite{tgalois}, and remains of interest in the context of generic constructions that conflict with cubical type theory.

\section{Numerical Representations}
Rather than equating implementations after the fact, we can also ``compute'' datastructures by imposing equations. In the case of container types, one may observe similarities to number systems \cite{purelyfunctional} and call such containers numerical representations. One can then use these representations to prototype new datastructures that automatically inherit properties and equalities from their underlying number systems \cite{calcdata}.

From another perspective, numerical representations run by using representability as a kind of ``strictification'' of types. %This suggests that we may be able to generalize the approach of numerical representations, using that any (non-indexed) infinitary inductive-recursive type supports a lookup operation \cite{glookup}.

\end{comment}

\part{Discussion}
\begin{comment}
\begin{example}    
    This ``proves'' our construction correct, but let us compare it to an existing numerical representation:
    We see that applying \AgdaFunction{TrieO} to \AgdaFunction{NatND} gives us a description which corresponds almost directly to \AgdaFunction{ListD}, only replacing all fields with vectors of length 1.
\end{example}

The reader of \cite{algorn} might question why we are doing the work of \AgdaFunction{TrieOIx} ourselves, rather than making use of \AgdaFunction{ornAlg}.
\begin{remark}
Problems
\begin{enumerate}
    \item an algebra for D gives no algebras for the deltas in D,
    \item no delta means constructors explode.
\end{enumerate}

Solution 1: define other infrastructure for algebras that do have algebras for deltas

Solution 2:
\begin{enumerate}
    \item kill deltas by an intermediate form which explodes,
    \item give up on constructor lists and have big sigma.
\end{enumerate}

Solution 3:
\begin{enumerate}
    \item do deltas via mutual recursion,
    \item mutual recursion already has good algebras.
\end{enumerate}

\end{remark} 

\begin{remark}
    Also, variables are annoying
    \begin{itemize}
        \item centralize variable transforms into one place in deltas
        \item what are ornaments now
    \end{itemize} 

    \begin{itemize}
        \item package descriptions and their thinnings
        \item something happens
    \end{itemize}
\end{remark}

\begin{remark}
    Not all functions $\mu D \to X$ come from algebras $[D] X \to X$. Consider the function $\mathrm{pred} : N \to N$, sending $\mathrm{suc} n$ to $n$ and 0 to 0.
    % https://q.uiver.app/#q=WzAsNyxbMCwwLCIxK04iXSxbMCwxLCJOIl0sWzEsMSwiTiJdLFsxLDAsIjErTiJdLFsyLDAsIk4iXSxbMywxLCJOIl0sWzMsMCwiTiJdLFswLDEsIlxcbWF0aHJte3N1Y30iLDJdLFszLDIsIj8iLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbMCwzLCIxK1xcbWF0aHJte3ByZWR9Il0sWzEsMiwiXFxtYXRocm17cHJlZH0iLDJdLFswLDIsIlxcbGFuZ2xlMCwgXFxtYXRocm17aWR9XFxyYW5nbGUiLDFdLFs0LDUsIlxcbWF0aHJte2lkfSIsMV0sWzQsNiwiXFxtYXRocm17cHJlZH0iXSxbNiw1LCIhISEiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkb3R0ZWQifX19XV0=
    \[\begin{tikzcd}
        {1+N} & {1+N} & N & N \\
        N & N && N
        \arrow["{\mathrm{suc}}"', from=1-1, to=2-1]
        \arrow["{?}", dashed, from=1-2, to=2-2]
        \arrow["{1+\mathrm{pred}}", from=1-1, to=1-2]
        \arrow["{\mathrm{pred}}"', from=2-1, to=2-2]
        \arrow["{\langle0, \mathrm{id}\rangle}"{description}, from=1-1, to=2-2]
        \arrow["{\mathrm{id}}"{description}, from=1-3, to=2-4]
        \arrow["{\mathrm{pred}}", from=1-3, to=1-4]
        \arrow["{!!!}", dotted, from=1-4, to=2-4]
    \end{tikzcd}\]
    We see that $\mathrm{pred}$ cannot come from a map $1 + N \to N$, as that map would be a retraction, while $\mathrm{pred}$ is not mono.
\end{remark}

\towrite{Some goals: 1. Ix and paths. 2. Ix n -> A iso IxTrieO n A. 3. something about the correctness of TrieO}

\begin{outline}
:warning: the trie ornament is hard to prove about

:warning: nesting rather than branching

:warning: folds don't give folds over parts

:warning: composites complicate the indexed variant

:warning: the index type becomes more awkward than with big sigmas
\end{outline}


\section{Temporary: future work (\autoref{part:ornament})}
\begin{remark}
    Note that this allows us to express datatypes like finger trees, but not rose trees. Such datatypes would need a way to place a functor ``around the \AgdaInductiveConstructor{ρ}'', which then also requires a description of strictly positive functors. In our setup, this could only be encoded by separating general descriptions from strictly positive descriptions. The non-recursive fields of these strictly positive descriptions then need to be restricted to only allow compositions of strictly positive context functions. 
\end{remark} % \investigate{This setup does not allow nesting over recursive fields, which is necessary for structures like rose trees. This is actually kind of essential for enumeration. Nesting over a recursive field is problematic: we can incorporate it by adding ``this'' implicitly to a \AgdaInductiveConstructor{δ}, but then the \AgdaBoundFontStyle{R} needs to be strictly positive in its last argument, meaning we need to split \AgdaDatatype{Desc} into a strictly positive part and normal part. The strictly positive part should then only allow strictly positive parameter transforms in recursive and non-recursive fields, requiring an embedding of transforms.}

\begin{remark}
    Variable transforms are not essential in these descriptions, but there are a couple of reasons for keeping them. In particular, they make it possible to reuse a description in multiple contexts, and save us from writing complex expressions in the indices of our ornaments. On the other hand, the transforms still make defining ornaments harder (the majority of the commuting squares are from variables). Isolating them into a single constructor of \AgdaDatatype{Desc}, call it \AgdaInductiveConstructor{v}, seems like a good middle ground, but raises some odd questions, like ``why is there no ornament between \AgdaBoundFontStyle{v (g ∘ f) C} and \AgdaBoundFontStyle{v g (v f C)}''. (Furthermore, this also does not simplify the indices of ornaments).
\end{remark} %\investigate{Variable transforms are both less essential and less troublesome than I first thought. We can move variable transforms into a new former, and it probably simplifies the definition of ornaments a lot.}

\begin{remark}
    Rather, ornaments themselves could act as information bundles. If there was a description for \AgdaDatatype{Desc}, that is. Such a scheme of levitation would make it easier to switch between being able to actively manipulate information, and not having to interact with it at all. However, the complexity of our descriptions makes this a non-trivial task; since our \AgdaDatatype{Desc} is given by mutual recursion and induction-recursion, the descriptions, and the ornaments, would have to be amended to encode both forms of recursion as well.
\end{remark} % \investigate{If we levitate, then informed descriptions become ornaments over \AgdaDatatype{Desc}. This gives us the best of both worlds (modulo reflecting the description into a datatype): in plain descriptions, information does not even exist, and in informed descriptions, it is explicit. For levitation, we likely need induction-recursion and mutual recursion.}

\begin{remark}\label{rem:orn-lift}
    Rather than having the user provide two indices and show that the square commutes, we can ask for a ``lift'' $k$
    % https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXGJ1bGxldCJdLFsxLDAsIlxcYnVsbGV0Il0sWzAsMSwiXFxidWxsZXQiXSxbMSwxLCJcXGJ1bGxldCJdLFswLDEsImUiXSxbMiwzLCJmIiwyXSxbMiwwLCJqIl0sWzMsMSwiaSIsMl0sWzMsMCwiayIsMV1d
    \[\begin{tikzcd}
        \bullet & \bullet \\
        \bullet & \bullet
        \arrow["e", from=1-1, to=1-2]
        \arrow["f"', from=2-1, to=2-2]
        \arrow["j", from=2-1, to=1-1]
        \arrow["i"', from=2-2, to=1-2]
        \arrow["k"{description}, from=2-2, to=1-1]
    \end{tikzcd}\]
    and derive the indices as $i = ek, j = kf$. However, this is more restrictive, unless $f$ is a split epi, as only then pairs $i,j$ and arrows $k$ are in bijection. In addition, this makes ornaments harder to work with, because we have to hit the indices definitionally, whereas asking for the square to commute gives us some leeway (i.e., the lift would require the user to transport the ornament). 
\end{remark}




\begin{remark}
    Comparing SOP and computational sigmas. In particular, \texttt{s N (\ n -> v (replicate n tt))} is not in SOP without full nesting. SOP is good for generics in both directions (the conversion in both ways keeps the datatype like it is supposed to). On the other hand, computational sigmas make writing and proving about \texttt{Path} a lot easier.
\end{remark}


\section{Temporary: future work (\autoref{part:numrep})}

\investigate{This implementation of TrieO always computes the random-access variant of the datastructure. Can we implement a variant which computes the ``Braun tree'' variant of the datastructure?}

\investigate{Index types are a simple ornament over number types: paths. This is not quite like \cite{glookup}.}

\investigate{Is Ix x -> A initial for the algebra of the algebraic ornament induced by TrieO? (This is \cite{calcdata}).}

\investigate{While evidently Ix x != Fin (toN x) for arbitrary number systems, does the expected iso Ix x -> A = Trie A x yield Traversable, for free?}
\end{comment}


\printbibliography

\part{Appendix}
\input{Appendix}


\end{document}
