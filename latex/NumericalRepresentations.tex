\section{Generic numerical representations}\label{sec:trieo}
In this section, we will demonstrate how we can use the ornamental descriptions to generically compute numerical representations. 

The reasoning here proceeds differently from the calculation of \AD{Vec} from \bN{}. Indeed, here we will directly construct datatypes via ornamental descriptions, rather than deriving them step-by-step using isomorphism reasoning. Nevertheless, the choices of fields depending on the analysis of a number system follow the same strategy. We will first present the unindexed numerical representations, explaining case-by-case which fields it adds and why. Then, we will demonstrate the indexed numerical representations as an ornament on top of the unindexed variant, and how the indices built up incrementally as we descend over the structure of the number system.

Recall the ``natural numbers''-information \AF{Number}, which gets its semantics from the conversion to \bN{}:
\ExecuteMetaData[Ornament/Numerical]{toN-type}
which is defined by generalizing over the inner information bundle and folding using
\ExecuteMetaData[Ornament/Numerical]{toN-con}
The choice of interpretation restricts the numbers to the class of numbers which are evaluated as linear combinations of digits\footnote{An arbitrary \AF{Number} system is not necessarily isomorphic to \bN{}, as the system can still be incomplete (i.e., it cannot express some numbers) or redundant (it has multiple representations of some numbers).}. This class certainly does not include all interesting number systems, but does include many systems that have associated arrays\footnote{Notably, arbitrary polynomials also have numerical representations, interpreting multiplication as precomposition.}. 

\todo{Explain better from here}
We let this interpretation into \bN{} guide the construction of the associated numerical representation. In each case, we follow the computation in \AF{value} by inserting vectors of sizes corresponding to the weights of the number system:
\ExecuteMetaData[Ornament/Numerical]{trieifyOD}
In the case of a leaf \AIC{ùüô} of weight \AV{k}, we insert a vector of size \AV{k}. Similarly, in a field \AIC{œÉ}, where the weight is determined by a value \AV{s} of \AV{S}, we insert a vector of the weight corresponding to the value of \AV{s}. Note that the actual value/number of elements a leaf or field contributes depends on the preceding multipliers of recursive fields: a recursive field of a number can have a weight \AV{k}, so we multiply the number of elements in a recursive sequence by wrapping the parameter in a vector of size \AV{k}. By roughly the same reasoning we pass the trieification of a subdescription \AV{R} the parameter wrapped in a vector, which we compose into the current numerical description by using the ornament \AIC{‚àôŒ¥}. Since \AV{R} can have a different \AD{Info}, we generalized the whole construction over \AV{œï}\ \AV{:} \AD{InfoF}\ \AV{If}\ \AF{Number}.

As an example, let us define \AF{PhalanxD} as a number system and walk through the computation of its \AF{trieifyOD}. We define
\ExecuteMetaData[Ornament/Numerical]{PhalanxND}
Now, we see that applying \AF{trieifyOD} sends leaves with a value of \AV{k} to \AD{Vec}\ \AV{A}\ \AV{k}, so applying it to \AF{DigitND} yields
\ExecuteMetaData[Ornament/Numerical]{DigitOD-2}
which is equivalent to the \AF{DigitOD} from before, up to expanding a vector of \AV{k} elements into \AV{k} fields. The same happens for the first two constructors of \AF{PhalanxND}, replacing them with an empty vector and a one-element vector respectively. The \AF{ThreeND} in the last constructor gets trieified to \AF{DigitOD‚Ä≤} and composed by \AF{O‚àôŒ¥+}, and the recursive field gets replaced by a recursive field nesting over vectors of length. Again, this is equivalent to \AF{FingerOD}, up to wrapping values in length one vectors, replacing \AD{Pair} with a two-element vector, and inserting empty vectors.

\todo{Explain better until here}


Like how \AD{List} has an ornament \AF{VecOD} to its \bN{}-indexed variant \AD{Vec}, the numerical representation \AF{trieifyOD}\ \AV{D} has an ornament \AF{itrieifyOD}\ \AV{D} to its \AV{D}-indexed variant:
\ExecuteMetaData[Ornament/Numerical]{itrieify-type}
Continuing the analogy to \AF{VecOD}, this ornament adds fields reflecting the recursive indices, and threads the partially applied constructor \AV{n} of \AV{N} through the resulting description. In addition to generalizing over \AV{If} to facilitate the \AIC{Œ¥} case, as in \AF{trieifyOD}, we also generalize over the index type \AV{N'}. When mapping over descriptions, the choice of constructor also selects the corresponding constructor of \AV{N'}
\ExecuteMetaData[Ornament/Numerical]{itrieify-desc}
We define \AF{itrie-con} by induction on \AV{C}, consuming bound values one-by-one as arguments for the selected constructor \AV{n}, which will then produce the actual indices at the leaves. Since we are continuing where \AF{trie-con} left off, we can copy most fields
\ExecuteMetaData[Ornament/Numerical]{itrieify-con}
Only in the case for \AIC{œÅ} and \AIC{Œ¥} do we add fields, which are both promptly passed as expected indices to the next field using \AV{Œª \{ (p , w , i) ‚Üí i \}}. For \AIC{Œ¥}, since \AF{itrie-desc}\ \AV{R} will be \AV{R}-indexed, we add a field of \AV{R} rather than \AV{N'}. The values of all fields, including \AIC{œÉ} are passed to \AV{n}; since \AV{n} starts as one constructor \AV{C} of \AV{N'}, when we arrive at \AIC{ùüô}, the final argument of \AV{n} can be filled with simply \AIC{refl} to determine the actual index.

Since the \AV{N'}-index bound in the \AIC{œÅ} case forces the number of elements in the recursive field, the value in the \AIC{œÉ} case corresponds to the number of elements added after this field, and the \AV{R}-index bound in the \AIC{Œ¥} case likewise forces the number of elements in the subdescription, we know that when we arrive at \AIC{ùüô}, the total number of elements is exactly given by \AV{n}, and thus \AF{itrie-con} is correct. In turn, we conclude that \AF{itrie-desc} and \AF{itrieifyOD} correctly construct indexed numerical representations.\lowprio{Proof is left as exercise to the reader. Hint $\Sigma$-descriptions will come in handy.} 

\lowprio{Example? I think the explanation of itrieifyOD is extensive enough to not warrant a repetition of fingerod in the indexed case.}

\towrite{This concludes a bunch of things, including this thesis. Combine conclusion and discussion? ``We did X, but there still are many improvements that could be made''}

