\section{Î´ is conservative}\label{sec:redundant-delta}
We define our universe \AD{DescI} with \AIC{Î´} as a former of fields with known descriptions, because this makes it easier to write down \AF{trieifyOD}, even though \AIC{Î´} is redundant. If more concise universes and ornaments are preferable, we can actually get all the features of \AIC{Î´} and ornaments like \AIC{âˆ™Î´} by describing them using \AIC{Ïƒ}, annotations, and other ornaments.

Indeed, rather than using \AIC{Î´} to add a field from a description \AV{R}, we can simply use \AIC{Ïƒ} to add \AV{S}\ \AV{=}\ \AD{Î¼}\ \AV{R}, and remember that \AV{S} came from \AV{R} in the information
\ExecuteMetaData[Tex/Discussion]{Delta-Info}
We can then define \AIC{Î´} as a pattern synonym matching on the \AIC{just} case, and \AIC{Ïƒ} matching on the \AIC{nothing} case.

Recall that the ornament \AIC{âˆ™Î´} lets us compose an ornament from \AV{D} to \AV{D'} with an ornament from \AV{R} to \AV{R'}, yielding an ornament from \AIC{Î´}\ \AV{D}\ \AV{R} to \AIC{Î´}\ \AV{D'}\ \AV{R'}. This ornament can be modelled by first adding a new field \AD{Î¼}\ \AV{R'}, and then deleting the original \AD{Î¼}\ \AV{R} field. The ornament \AIC{âˆ‡} \cite{kophd} allows one to provide a default value for a field, deleting it from the description. Hence, we can model \AIC{âˆ™Î´} by binding a value \AV{r'} of \AD{Î¼}\ \AV{R'} with \AF{OÎ”Ïƒ+} and deleting the field \AD{Î¼}\ \AV{R} using a default value computed by \AF{ornForget}.


\section{Indices do not depend on parameters}\label{sec:no-dep-ix}
In \AD{DescI}, we represent the indices of a description as a single constant type, as opposed to an extension of the parameter telescope \cite{practgen}. This simplification keeps the treatment of ornaments and numerical representations more to the point, but rules out types like the identity type \AD{â‰¡}. Another consequence of not allowing indices to depend on parameters is that algebraic ornaments \cite{algorn} can not be formulated in \AD{OrnDesc} in their fully general form.

By replacing index computing functions \AV{Î“}\ \AF{\&}\ \AV{V}\ \AF{âŠ¢}\ \AV{I} with dependent functions
\ExecuteMetaData[Tex/Discussion]{index-interpretation}
we can allow indices to depend on parameters in our framework. As a consequence, we have to modify nested recursive fields to ask for the index type \AF{âŸ¦}\ \AV{I}\ \AF{âŸ§tel} precomposed with \AV{g :}\ \AF{Cxf}\ \AV{Î“ Î“}, and we have to replace the square like \AV{i}\ \AF{âˆ˜}\ \AV{jâ€²}\ \AF{âˆ¼}\ \AV{iâ€²}\ \AF{âˆ˜}\ \AF{over}\ \AV{v} in the definition of ornaments with heterogeneous squares.


\section{Î£-descriptions are more natural for expressing finite types}\label{sec:closed-universe}
Due to our representation of types as sums of products, representing the finite types of arbitrary number systems quickly becomes hard. Consider the binary numbers from before
\ExecuteMetaData[Tex/Discussion/Sigma-Desc]{Leibniz}
for which the finite type
\ExecuteMetaData[Tex/Discussion/Sigma-Desc]{FinB}
has more constructors than the numbers themselves. In general, the number of constructors of a finite type depends both on the multipliers and constants in all fields and leaves of the number system, which prevents us from constructing the finite type by simple recursion on \AD{DescI} (that is, without passing around lists of constructors instead). Furthermore, since our definition of ornaments insists a type and an ornament on it have the same number of constructors, there can also not be a generic ornament from numbers to their finite types. 

The apparent mismatch of number systems and their finite types stems from the treatment of the field-former \AIC{Ïƒ} in \AD{DescI}. In such a sums-of-products universe \cite{practgen,sijsling}, a \AIC{Ïƒ}\ \AV{S}\ \AV{C} represents a field of type \AV{S}, where the subsequent fields described by \AV{C} have their context extended by \AV{S}. In contrast, a Î£-descriptions universe \cite{effectfully,progorn,algorn} (in the terminology of \cite{sijsling}) encodes a dependent field \AV{(s : S)} by asking for a function \AV{C} assigning values \AV{s} to descriptions.

In comparison, a sums-of-products universe keeps out some more exotic descriptions\footnote{Consider the constructor \AIC{Ïƒ}\ \bN{}\ \AV{Î»}\ \AV{n}\ \AV{â†’}\ \AF{power}\ \AIC{Ï}\ \AV{n}\ \AIC{ðŸ™} which takes a number \AV{n} and asks for \AV{n} recursive fields (where \AF{power}\ \AV{f}\ \AV{n}\ \AV{x} applies \AV{f} \AV{n} times to \AV{x}). This description, resembling a rose tree, does not (trivially) lie in a sums-of-products universe.} which do not have an obvious associated Agda datatype. As a consequence, this also prevents us from introducing new branches inside a constructor.

If we instead started from Î£-descriptions, taking functions into \AD{DescI} to encode dependent fields, we could compute a ``type of paths'' in a number system by adding and deleting the appropriate fields. Consider the universe
\ExecuteMetaData[Tex/Discussion/Sigma-Desc]{Sigma-Desc}
In this universe we can present the binary numbers as
\ExecuteMetaData[Tex/Discussion/Sigma-Desc]{LeibnizD}
The finite type for these numbers can be described by
\ExecuteMetaData[Tex/Discussion/Sigma-Desc]{FinBD}
Since this description of \AF{FinB} largely has the same structure as \AF{Leibniz}, and as a consequence also the numerical representation associated to \AF{Leibniz}, this would simplify proving that the indexed numerical representation is indeed equivalent to the representable representation (the maps out of \AF{FinB}). In a more flexible framework ornaments, we can even describe the finite type as an ornament on the number system.


\section{Indexed numerical representations are not algebraic ornaments}\label{sec:ix-not-alg}
From the theory of algebraic ornaments \cite{algorn}, we find that the type \AD{Vec} as an indexed variant of \AD{List}, can also be seen as an algebraic ornament. This construction takes an ornament between types \AV{A} and \AV{B}, and returns an ornament from \AV{B} to a type indexed over \AV{A}, representing ``\AV{B}s of a given underlying \AV{A}''. Instantiating this for naturals, lists and vectors, the algebraic ornament takes the ornament from naturals to lists, and returns an ornament from lists to vectors, by which vectors are lists of a fixed length.

While we gave an explicit ornament from the unindexed to the indexed numerical representations, we might expect that ornament to be the algebraic ornament of \AF{trieifyOD}. However, this fails if we want to describe composite types like \AD{FingerTree} (unless we first flatten \AD{Digit} into the description of \AD{FingerTree}): Since the algebraic ornament (obviously) preserves a \AIC{Ïƒ}, it can not convert the unindexed numerical representation under a \AIC{Î´} to the indexed variant. This means that the algebraic ornament on \AD{FingerTree} (given by \AF{toDesc}\ \AF{trieifyOD}) would only index the outer structure, leaving the \AD{Digit} fields unindexed.

Nevertheless, we expect that a modifying the inlining ornamental algebras into algebraic ornaments, in the same way that \AF{itrieifyOD} diverges from the algebraic ornament, yields a variant of \AF{aOoA} which does coincide with \AF{itrieifyOD}.


\section{Branching numerical representations}
The numerical representations we construct via \AF{itrieifyOD} come in the form of heaps. Like random-access lists and finger trees, these numerical representations typically look like spines, storing elements in ever-growing trees hanging off this spine.

This is much in contrast with the Braun trees Hinze and Swierstra \cite{calcdata} compute. We can modify our construction of \AF{itrieifyOD} using 
\ExecuteMetaData[Tex/Discussion]{power}
to apply \AIC{Ï} \AV{k}-fold in the case of \AIC{Ï}\ \AV{\{if = k\}}, rather than applying \AIC{Ï} by nesting with a \AV{k}-element vector. \todo{Is that all there is to say? No algorn, no unindexed variant?}


\section{No RoseTrees}
In \AD{DescI}, we encode nested types by allowing nesting over a function of parameters \AF{Cxf}\ \AV{Î“}\ \AV{Î“}. This is less expressive than full nested types, which may also nest a recursive field under a strictly positive functor. For example, rose trees
\ExecuteMetaData[Tex/Discussion]{RoseTree}
cannot be directly expressed as a \AD{DescI}\footnote{And, since we do not have higher-order inductive arguments like Escot and Cockx \cite{practgen}, we can also not give an essentially equivalent definition.}. We can still describe a similar datatype of ``fixed-height'' rose trees
\ExecuteMetaData[Tex/Discussion]{almost-RoseTree}
which nests on the inside instead. Since lists can be empty, the rose trees are not necessarily of an actual fixed-height, and still coincide with rose trees.

If we were to describe full nested types, by allowing application functors over recursive arguments, we would need to convince Agda that these functors are indeed positive through, for example polarity annotations. Alternatively, we could encode strictly positive functors in a separate universe, which only allows to applications of parameters strictly positive contexts \cite{sijsling}. Finally, we could modify \AD{DescI} in such a way that we can decide if a description uses a parameter strictly positively, which would have to involve modifying \AIC{Ï} and \AIC{Ïƒ}, or adding variants of those formers only allowing strictly positive usage of parameters.


\section{No levitation}
Since our encoding does not support higher-order inductive arguments, let alone definitions by induction-recursion, \AD{DescI} certainly does not have a \AD{DescI}. Such self-describing universes have been described by Chapman et al. \cite{levitation}, and we expect that the other features of \AD{DescI}, parameters, nesting, and composition, would not obstruct a similar levitating variant of \AD{DescI}. Due to the work of Dagand and McBride \cite{orntrans}, ornaments might even be generalized to inductive-recursive descriptions.

If that is the case, then a part of our definitions and constructions could be expressed inside such a framework, rather than by modifying the universe to suit our needs. In particular, rather than describing \AD{DescI} to describe datatypes with even more information, \AD{DescI} should be expressible as an ornament on plain descriptions, in contrast to how \AD{Desc} is an instance of \AD{DescI} in our framework. This would allow treating information explicitly in \AD{DescI}, and not at all in \AD{Desc}.

Furthermore, constructions like \AF{trieifyOD}, which have the recursive structure of a fold over \AD{DescI}, could indeed be expressed by instantiating \AF{fold} to \AD{DescI}.\todo{Maybe a bit too dreamy.}


%\section{Variables slightly later}
%package them with the constructor descriptions rather than only after a sigma
% separate substitutions -> probably 


%\section{Less commutative squares}
%\autoref{rem:orn-lift} -> Discussion
% \begin{remark}\label{rem:orn-lift}
%     Rather than having the user provide two indices and show that the square commutes, we can ask for a ``lift'' $k$
%     % https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXGJ1bGxldCJdLFsxLDAsIlxcYnVsbGV0Il0sWzAsMSwiXFxidWxsZXQiXSxbMSwxLCJcXGJ1bGxldCJdLFswLDEsImUiXSxbMiwzLCJmIiwyXSxbMiwwLCJqIl0sWzMsMSwiaSIsMl0sWzMsMCwiayIsMV1d
%     \[\begin{tikzcd}
%         \bullet & \bullet \\
%         \bullet & \bullet
%         \arrow["e", from=1-1, to=1-2]
%         \arrow["f"', from=2-1, to=2-2]
%         \arrow["j", from=2-1, to=1-1]
%         \arrow["i"', from=2-2, to=1-2]
%         \arrow["k"{description}, from=2-2, to=1-1]
%     \end{tikzcd}\]
%     and derive the indices as $i = ek, j = kf$. However, this is more restrictive, unless $f$ is a split epi, as only then pairs $i,j$ and arrows $k$ are in bijection. In addition, this makes ornaments harder to work with, because we have to hit the indices definitionally, whereas asking for the square to commute gives us some leeway (i.e., the lift would require the user to transport the ornament). 
% \end{remark}



%\section{Î´ is conservative over Desc and Orn}
%If we include the ornament \AIC{âˆ‡Ïƒ} dropping a field by giving a default value \AV{V}\ \AF{âŠ§}\ \AV{S} in place of a \AIC{Ïƒ}:
%\ExecuteMetaData[Tex/Discussion]{nabla-sigma}
%then we can also represent \AIC{âˆ™Î´} without further modifying \AD{ConOrnDesc}. Namely
%\ExecuteMetaData[Tex/Discussion]{comp-delta-nabla-sigma}
%This emulates the \AIC{âˆ™Î´} over an ornament \AV{RRâ€²}, by first adding a field of \AD{Î¼}\ (\AF{toDesc}\ \AV{RRâ€²}) and then fixing a default value for \AD{Î¼}\ \AV{R} by using \AF%{ornForget}.
%This makes the presentation of the descriptions and ornaments, and the interpretations of both simpler. However, this has the downside of needing a transport (or, %with-abstraction) for each pattern match on a value which would otherwise be a \AIC{Î´}.


%\section{Reconcile calculating and trieifyOD}
%\begin{outline}
%    In the computation of generic numerical representations, we gave \AF{trieifyOD} directly, rather than as the consequence of a calculation. %\todo{This is simply because a) %the wheels would come off very soon b) trieifyOD is not a definition but rather describes one.}
%
%    By abstracting \AF{Def} over a function, we can elegantly describe the kind of object we are looking for
%    \[ ... \]
%    but because we factor through an interpretation into \AD{Type}, we still have to give the definition before we can construct the isomorphism.
%
%    Maybe this works better for trieifyOD itself, where the isomorphism is really a composition of smaller isomorphisms by analyzing the descriptions, rather than one global %isomorphism as is the case when comparing Lookup and VecD.
%
%    See Tex.Disussion.Def-cong
%\end{outline}



%\section{?}
%While evidently Ix x != Fin (toN x) for arbitrary number systems, does the expected iso Ix x -> A = Trie A x yield Traversable, for free?

%\section{Odd numerical representations} % mark: but that's not _my_ problem is it?
%the numerical representation of 2-3 fingertrees is a bit odd, or trivial.
%I do not know whether there is a datastructure (let alone numerical representation) which has amortized constant append on both sides, and has logarithmic lookup, but uses only simple nesting (i.e., nesting over a functor with only products and no sums).

% is fold and map really valid and terminating? -> the whole --cubical --safe not being safe really undermines this


