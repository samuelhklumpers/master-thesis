\documentclass[10pt]{article}

\usepackage[style=alphabetic]{biblatex}
\addbibresource{refs.bib}

\usepackage{comment}

\setlength{\marginparwidth}{2cm} % this makes \todo{}s explode less, remove when done

\usepackage{todonotes}
\usepackage{xcolor}
\usepackage[hidelinks]{hyperref}


\usepackage{catchfilebetweentags}
\usepackage{quiver} 
\usepackage{tabularx}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{listings}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{conjecture}{Conjecture}[section]
\newtheorem*{cor}{Corollary}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{remark}{Remark}[section]
\newtheorem{claim}{Claim}[section]
\newtheorem{example}{Example}[section]

\renewcommand{\partautorefname}{Part}
\renewcommand{\sectionautorefname}{Section}
\renewcommand{\subsectionautorefname}{Subsection}

\providecommand{\theoremautorefname}{Theorem}
\providecommand{\lemmaautorefname}{Lemma}
\providecommand{\propautorefname}{Proposition}
\providecommand{\conjectureautorefname}{Conjecture}
\providecommand{\corautorefname}{Corollary}
\providecommand{\defnautorefname}{Definition}
\providecommand{\remarkautorefname}{Remark}
\providecommand{\exampleautorefname}{Example}
\providecommand{\claimautorefname}{Claim}


\usepackage[links]{agda}
\AgdaNoSpaceAroundCode{}

\usepackage{fontspec}
\usepackage{luaotfload}

\directlua{luaotfload.add_fallback
  ("myfallback",
    { "JuliaMono:style=Regular;"
    , "NotoSansMono:style=Regular;"
    , "NotoSansMath:style=Regular;"
    , "Segoe UI Emoji:mode=harf;"
    }
  )}
\defaultfontfeatures{RawFeature={fallback=myfallback}}

\setmainfont{Latin Modern Roman}

\newfontfamily{\AgdaSerifFont}{JuliaMono Regular}[Scale=0.8]
\newfontfamily{\AgdaSansSerifFont}{JuliaMono Regular}[Scale=0.8]
\newfontfamily{\AgdaTypewriterFont}{JuliaMono Regular}[Scale=0.8]
\setmonofont{JuliaMono Regular}[Scale=0.8]
\renewcommand{\AgdaFontStyle}[1]{{\AgdaSansSerifFont{}#1}}
\renewcommand{\AgdaKeywordFontStyle}[1]{{\AgdaSansSerifFont{}#1}}
\renewcommand{\AgdaStringFontStyle}[1]{{\AgdaTypewriterFont{}#1}}
\renewcommand{\AgdaCommentFontStyle}[1]{{\AgdaTypewriterFont{}#1}}
\renewcommand{\AgdaBoundFontStyle}[1]{\textit{\AgdaSerifFont{}#1}}

\newcommand{\AF}[1]{\AgdaFunction{#1}}
\newcommand{\AD}[1]{\AgdaDatatype{#1}}
\newcommand{\AR}[1]{\AgdaRecord{#1}}
\newcommand{\AV}[1]{\AgdaBoundFontStyle{#1}}
\newcommand{\AIC}[1]{\AgdaInductiveConstructor{#1}}
\newcommand{\ARF}[1]{\AgdaField{#1}}

\definecolor{git-green}{HTML}{13A10E}
\definecolor{git-orange}{HTML}{C69026}
\definecolor{nondescriptyellow}{HTML}{D6B656}

\newcommand{\added}[1]{\textcolor{git-green}{+#1}}
\newcommand{\changed}[1]{\textcolor{git-orange}{$\bullet$#1}}
\newcommand{\towrite}[1]{\todo[color=cyan]{#1}}
\newcommand{\toremove}[1]{\textcolor{red}{This is going to be (re)moved: ``#1''}}

  
\lstnewenvironment{semicomment}{\color{gray}\lstset{breaklines=true}}{}
\lstnewenvironment{outline}{\color{nondescriptyellow}\lstset{breaklines=true}}{}

\newcommand{\investigate}[1]{\par\vspace{1\baselineskip}\textcolor{gray}{#1}\vspace{1\baselineskip}\par}

\newcommand{\bN}{\AgdaDatatype{ℕ}}
\newcommand{\bL}{\AgdaDatatype{Leibniz}}


\title{Ornaments and Proof Transport applied to Numerical Representations}
\author{Samuel Klumpers\\6057314}


\begin{document}
\maketitle

\begin{abstract}
The dependently typed functional programming language Agda encourages defining custom datatypes to write correct-by-construction programs with\todo{long}. In some cases, even those datatypes can be made correct-by-construction, by manually distilling them from a mixture of requirements, as opposed to pulling them out of thin air\todo{distracted}. This is in particular the case for numerical representations, a class of datastructures inspired by number systems, containing structures such as linked lists and binary trees. However, constructing datatypes in this manner, and establishing the necessary relations between them can quickly become tedious and duplicative.

In the general case, employing datatype-generic programming can curtail code-duplication by allowing the definition of constructions that can be instantiated to a class of types. Furthermore, ornaments make it possible to succinctly describe relations between structurally similar types.

In this thesis, we apply generic programming and ornaments to numerical representations, giving a recipe to compute such a representation from a provided number system.
For this, we describe a generic universe and a type of ornaments on it, allowing us to formulate the recipe as an ornament from a number system to the computed datatype.
\end{abstract}


\begin{comment}
This thesis explains the concepts numerical representations and ornaments, and aims to combine these to simplify the presentation and verification of finger trees. We demonstrate the generalizability and easier verification of the resulting code. Further, we also investigate to which extent descriptions and ornaments, and generic programs built on top of these, remain effective in a setting without axiom K.
\end{comment}
    

\tableofcontents

\listoftodos

\section{Introduction}\label{sec:introduction}
% outline:
%
\input{Introduction}


\part*{Background}\label{part:background}
\addcontentsline{toc}{part}{\nameref{part:background}}
% outline:
% 
\todo{go emph pass}
\todo{go cite pass}
We extend upon existing work in the domain of generic programming and ornaments, so let us take a closer look at the nuts and bolts to see what all the concepts are about.

We will describe some common datatypes and how they can be used for programming, exploring how dependent types also let us use datatypes to prove properties of programs, or write programs that are correct-by-construction, leading us to discuss descriptions of datatypes and ornaments.
    
\input{Background}


\part{Descriptions}\label{part:ornament}
% outline:
% we explained why descriptions and ornaments are crucial to achieve our goals
% however, the descriptions we explained earlier are not powerful enough to house finger trees
% To capture finger trees as an ornament over a number system, we will need to describe ornaments over nested datatypes. In this section we will work out descriptions and ornaments suitable for nested datatypes.
If we are going to simplify working with complex sequence types by instantiating generic programs to them, we should first make sure that these types fit into the descriptions. We construct descriptions for nested datatypes by extending the encoding of parametric and indexed datatypes from \autoref{ssec:background-ix} with three features: information bundles, parameter transformation, and description composition. Also, to make sharing constructors easier, we introduce variable transformations. Transforming variables before they are passed to child descriptions allows both aggressively hiding variables and introducing values as if by let-constructs.

We base the encoding of off existing encodings \cite{sijsling,practgen}. The descriptions take shape as sums of products, enforce indices at leaf nodes, and have explicit parameter and variable telescopes. Unlike some other encodings \cite{effectfully, practgen}, we do not allow higher-order inductive arguments. We use \texttt{--type-in-type} and \texttt{--with-K} to simplify the presentation, noting that these can be eliminated respectively by moving to \AD{Typeω} and by implementing interpretations as datatypes, as described in \autoref{app:withoutk}.

\input{Descriptions}


\part{Ornaments}\label{part:ornament2_rename_the_other}
% outline:
% 
In the framework of \AD{DescI} in the last section, we can write down a number system and its meaning as the starting point of the construction of a numerical representation. To write down the generic construction of those numerical representations, we will need a language in which we can describe modifications on the number systems.

In this section, we will describe the ornamental descriptions for the \AD{DescI} universe, and explain their working by means of (plenty of) examples. We omit the definition of the ornaments, since we will only construct new datatypes, rather than relate pre-existing types\todo{Maybe, I will throw the ornaments into the appendix along with the conversion from ornamental description to ornament}.

\todo{do we need to remark more?}

\input{Ornaments}


\part{Numerical representations}\label{part:numrep}
% outline:
% 
The ornamental descriptions of the last section, together with the descriptions and number systems from before, complete the toolset we will use to construct numerical representations as ornaments.

To summarize, we will use the descriptions with information of \AF{Number} to represent numbers. We then seek to present the calculation of \autoref{sec:desc-numrep} as an ornament rather than a bare definition. In fact, we have already seen ornaments to numerical representations before, such as \AF{ListOD} and \AF{RandomOD}. Generalizing those ornaments, we construct numerical representations by means of an ornament-computing function, sending number systems to the ornamental descriptions which describe their numerical representations. 

\changed{Redo (or check) the Agda snippets below here.}
\changed{Somewhat final version above, draft/notes/rough comments/outline below.}
\input{NumericalRepresentations}

%\part{Related work}\label{part:related}
% outline: let's just work this into the discussion to avoid making a mess ok?
% 
% \input{RelatedWork}

\part{Discussion}
% outline:
% 









\input{Discussion}


\printbibliography

\part{Appendix}
% outline:
% 
\input{Appendix}


\end{document}
