In conclusion, we described a universe encoding \AD{DescI} such that we can describe number systems in \AD{DescI}\ \AF{Number}. Then we adapted the language of ornamental descriptions \AD{OrnDesc} to \AD{DescI}, such that the numerical representations of the number systems could be seen as ornaments on top of the number systems. Finally, we implemented the generic programs \AF{TreeOD} and \AF{TrieOD} which, from a number system compute the associated (un)indexed numerical representation, and informally outlined proofs of correctness of the descriptions generated by \AF{TreeOD} and \AF{TrieOD}. 

While it is possible to write down a direct proof of correctness for \AF{TrieOD} by comparing it to \AF{Lookup} via \AF{value}, and from this extract a proof of correctness for \AF{TreeOD}, one might expect there to be a more useful and less laborious angle of attack. 

Namely, we expect that if we define \AF{PathOD} as a generic ornament from a \AD{DescI}\ \AF{Number} to the corresponding finite type (such that \AF{PathOD}\ \AV{ND}\ \AV{n} is equivalent to \AD{Fin}\ (\AF{value}\ \AV{n})), then we can show that \AF{TrieOD}\ \AV{ND}\ \AV{n} has a \AF{tabulate}/\AF{lookup} pair for \AF{PathOD}\ \AV{ND}\ \AV{n}, from which it follows that \AF{TrieOD}\ \AV{ND}\ \AV{n}\ \AV{A} is equivalent to \AF{PathOD}\ \AV{ND}\ \AV{n}\ \AV{‚Üí}\ \AV{A}, and in consequence \AF{TrieOD}\ \AV{ND} corresponds to \AD{Vec}. %From an analogy of the \AF{Recomputation} lemma \cite{algorn} it follows that the index \AV{n} of \AF{TrieOD}\ \AV{ND}\ \AV{n} corresponds to applying \AF{ornForget} twice.

Due to the \AF{remember}-\AF{forget} isomorphism \cite{algorn}, we have that \AF{TreeOD}\ \AV{ND} is equivalent to \AV{Œ£}\ (\AD{Œº} \AV{ND})\ (\AF{TrieOD}\ \AV{ND}), whence \AF{TreeOD}\ \AV{ND} is a normal functor (also referred to as Traversable). This yields traversability of \AF{TreeOD}\ \AV{ND}, with as consequences \AF{toList}\footnote{Note that the foldable structure we get from the generic \AF{fold} is significantly harder to work with for this purpose.} and properties such as that \AF{toList} is a lifting of \AF{value} (again in the sense of \cite{orntrans}).

However, it turns out that \AF{PathOD} is not so easy to define, as we can see by an example.

\subsection{Œ£-descriptions are more natural for expressing finite types}\label{sec:closed-universe}
%\lowprio{Proof is left as exercise to the reader. Hint $\Sigma$-descriptions will come in handy.} 
Due to our representation of types as sums of products, representing the finite types of arbitrary number systems quickly becomes hard. Consider the binary numbers from before
\ExecuteMetaData[Tex/Discussion/Sigma-Desc]{Leibniz}
The finite type associated to \AD{Leibniz} then has more constructors than \AD{Leibniz}:
\ExecuteMetaData[Tex/Discussion/Sigma-Desc]{FinB}
In general, given a description of a number system \AV{N}, the number of constructors of the finite type \AD{FinN} of \AV{N} depends directly on the interpretation of \AV{N}, preventing the construction \AD{FinN} by simple recursion on \AD{DescI} (that is, without passing around lists of constructors instead). Furthermore, since our definition of ornaments insists ornaments preserve the number of constructors, there cannot be an ornament from an arbitrary number system to its finite type. 

The apparent asymmetry between number systems and finite types stems from the definition of \AIC{œÉ} in \AD{DescI}. In \AD{DescI} and similar sums-of-products universes \cite{practgen,sijsling}, the remainder of a constructor \AV{C} after a \AIC{œÉ}\ \AV{S} simply has its context extended by \AV{S}. In contrast, a \emph{Œ£-descriptions} universe \cite{effectfully,progorn,algorn} (in the terminology of \cite{sijsling}) encodes a dependent field \AV{(s : S)} by asking for a function \AV{C} assigning values \AV{s} to descriptions.

In comparison, a sums-of-products universe keeps out some more exotic descriptions\footnote{Consider the constructor \AIC{œÉ}\ \bN{}\ \AV{Œª}\ \AV{n}\ \AV{‚Üí}\ \AF{power}\ \AIC{œÅ}\ \AV{n}\ \AIC{ùüô} which takes a number \AV{n} and asks for \AV{n} recursive fields (where \AF{power}\ \AV{f}\ \AV{n}\ \AV{x} applies \AV{f} \AV{n} times to \AV{x}). This description, resembling a rose tree, does not (trivially) lie in a sums-of-products universe.} which do not have an obvious associated Agda datatype. As a consequence, this also prevents us from introducing new branches inside a constructor.

If we instead started from Œ£-descriptions, taking functions into \AD{DescI} to encode dependent fields, we could compute a ``type of paths'' in a number system by adding and deleting the appropriate fields. Consider the universe
\ExecuteMetaData[Tex/Discussion/Sigma-Desc]{Sigma-Desc}
In this universe we can present the binary numbers as
\ExecuteMetaData[Tex/Discussion/Sigma-Desc]{LeibnizD}
The finite type for these numbers can be described by
\ExecuteMetaData[Tex/Discussion/Sigma-Desc]{FinBD}
Since this description of \AF{FinB} largely has the same structure as \AF{Leibniz}, and as a consequence also the numerical representation associated to \AF{Leibniz}, this would simplify proving that the indexed numerical representation is indeed equivalent to the representable representation (the maps out of \AF{FinB}). In a more flexible framework ornaments, we can even describe the finite type as an ornament on the number system.


\subsection{Branching numerical representations}
The numerical representations we construct via \AF{trieifyOD} look like random-access lists and finger trees: the structures have central chains, storing the elements of a node in trees of which the depth increases with the level of the node.

In contrast, structures like Braun trees, as Hinze and Swierstra \cite{calcdata} compute from binary numbers, reflect the weight of a node by branching themselves. Because this kind of branching is uniform, i.e., each branch looks the same, we can still give an equivalent construction. By combining \AF{trieifyOD} and \AF{itrieifyOD}, and using 
\ExecuteMetaData[Tex/Discussion]{power}
to apply \AIC{œÅ} \AV{k}-fold in the case of \AIC{œÅ}\ \AV{\{if = k\}}, rather than over \AV{k}-element vectors, we can replicate the structure of a Braun tree from \AF{BinND}. However, if we use the Œ£-descriptions we discussed above, we can more elegantly present these structures by adding an internal branch over \AD{Fin}\ \AV{k}.

\subsection{Indices do not depend on parameters}\label{sec:no-dep-ix}
In \AD{DescI}, we represent the indices of a description as a single constant type, as opposed to an extension of the parameter telescope \cite{practgen}. This simplification keeps the treatment of ornaments and numerical representations more to the point, but rules out types like the identity type \AD{‚â°}. Another consequence of not allowing indices to depend on parameters is that \emph{algebraic ornaments} \cite{algorn} can not be formulated in \AD{OrnDesc} in their fully general form.

By replacing index computing functions \AV{Œì}\ \AF{\&}\ \AV{V}\ \AF{‚ä¢}\ \AV{I} with dependent functions
\ExecuteMetaData[Tex/Discussion]{index-interpretation}
we can allow indices to depend on parameters in our framework. As a consequence, we have to modify nested recursive fields to ask for the index type \AF{‚ü¶}\ \AV{I}\ \AF{‚üßtel} precomposed with \AV{g :}\ \AF{Cxf}\ \AV{Œì Œì}, and we have to replace the square like \AV{i}\ \AF{‚àò}\ \AV{j‚Ä≤}\ \AF{‚àº}\ \AV{i‚Ä≤}\ \AF{‚àò}\ \AF{over}\ \AV{v} in the definition of ornaments with heterogeneous squares.


\subsection{Indexed numerical representations are not algebraic ornaments}\label{sec:ix-not-alg}
\begin{outline}
    
Algebraic ornaments \cite{algorn}, generalize observations such as that \AD{Vec} is an indexed variant of \AD{List}, in a single definition \AF{aOoA} (the algebraic ornament of the ornamental algebra). The construction of that ornament takes an ornament between types \AV{A} and \AV{B}, and returns an ornament from \AV{B} to a type indexed over \AV{A}, representing ``\AV{B}s of a given underlying \AV{A}''. Instantiating this for natural numbers, lists and vectors, the algebraic ornament takes the ornament from natural numbers to lists, and returns an ornament from lists to vectors, by which vectors are lists of a fixed length.

While we gave an explicit ornament \AF{itrieifyOD} on \AF{trieifyOD}, we might expect \AF{itrieifyOD} to be the algebraic ornament of \AF{trieifyOD}. However, this fails if we want to describe composite types like \AD{FingerTree} (unless we first flatten \AD{Digit} into the description of \AD{FingerTree}): The algebraic ornament (obviously) preserves a \AIC{œÉ}, so it cannot convert the unindexed numerical representation under a \AIC{Œ¥} to the indexed variant. This means that the algebraic ornament on \AD{FingerTree}\ \AV{=}\ \AF{toDesc}\ (\AF{trieifyOD}\ \AF{PhalanxND}) would only index the outer structure, leaving the \AD{Digit} fields unindexed.
\todo{Note, we don't bind deltas anymore}
Nevertheless, we expect that if one defines \AF{indexO} by inlining \AF{ornAlg} into \AF{aOoA}, the definition of \AF{indexO} can be modified to apply itself in the case of \AIC{‚àôŒ¥}. Then, applying \AF{indexO} to \AF{trieifyOD} should coincide with \AF{itrieifyOD}.

\end{outline}

\subsection{No RoseTrees}
In \AD{DescI}, we encode nested types by allowing nesting over a function of parameters \AF{Cxf}\ \AV{Œì}\ \AV{Œì}. This is less expressive than full nested types, which may also nest a recursive field under a strictly positive functor. For example, rose trees
\ExecuteMetaData[Tex/Discussion]{RoseTree}
cannot be directly expressed as a \AD{DescI}\footnote{And, since \AD{DescI} does not allow for higher-order inductive arguments like Escot and Cockx \cite{practgen}, we can also not give an essentially equivalent definition.}.

%We can still describe a similar datatype of ``fixed-height'' rose trees
%\ExecuteMetaData[Tex/Discussion]{almost-RoseTree}
%which nests on the inside instead. Since lists can be empty, the rose trees are not necessarily of an actual fixed-height, and still coincide with rose trees.

If we were to describe full nested types, allowing applications of functors in the types of recursive arguments, we would have to convince Agda that these functors are indeed positive, possibly by using polarity annotations\footnote{\url{https://github.com/agda/agda/pull/6385}}. Alternatively, we could encode strictly positive functors in a separate universe, which only allows using parameters in strictly positive contexts \cite{sijsling}. Finally, we could modify \AD{DescI} in such a way that we can decide if a description uses a parameter strictly positively, for which we would modify \AIC{œÅ} and \AIC{œÉ}, or add variants of \AIC{œÅ} and \AIC{œÉ} restricted to strictly positive usage of parameters.


\subsection{No levitation}
Since our encoding does not support higher-order inductive arguments, let alone definitions by induction-recursion, there is no code for \AD{DescI} in itself. Such self-describing universes have been described by Chapman et al. \cite{levitation}, and we expect that the other features of \AD{DescI}, such as parameters, nesting, and composition, would not obstruct a similar levitating variant of \AD{DescI}. Due to the work of Dagand and McBride \cite{orntrans}, ornaments might even be generalized to inductive-recursive descriptions.

If that is the case, then modifications of universes like \AD{Meta} could be expressed internally. In particular, rather than defining \AD{DescI} such that it can describe datatypes with the information of, e.g., number systems, \AD{DescI} should be expressible as an ornamental description on \AD{Desc}, in contrast to how \AD{Desc} is an instance of \AD{DescI} in our framework. This would allow treating information explicitly in \AD{DescI}, and not at all in \AD{Desc}.

Furthermore, constructions like \AF{trieifyOD}, which have the recursive structure of a fold over \AD{DescI}, could indeed be expressed by instantiating \AF{fold} to \AD{DescI}.


\subsection{Œ¥ is conservative}\label{sec:redundant-delta}
We define our universe \AD{DescI} with \AIC{Œ¥} as a former of fields with known descriptions, because this makes it easier to write down \AF{trieifyOD}, even though \AIC{Œ¥} is redundant. If more concise universes and ornaments are preferable, we can actually get all the features of \AIC{Œ¥} and ornaments like \AIC{‚àôŒ¥} by describing them using \AIC{œÉ}, annotations, and other ornaments.

Indeed, rather than using \AIC{Œ¥} to add a field from a description \AV{R}, we can simply use \AIC{œÉ} to add \AV{S}\ \AV{=}\ \AD{Œº}\ \AV{R}, and remember that \AV{S} came from \AV{R} in the information
\ExecuteMetaData[Tex/Discussion]{Delta-Meta}
We can then define \AIC{Œ¥} as a pattern synonym matching on the \AIC{just} case, and \AIC{œÉ} matching on the \AIC{nothing} case.

Recall that the ornament \AIC{‚àôŒ¥} lets us compose an ornament from \AV{D} to \AV{D'} with an ornament from \AV{R} to \AV{R'}, yielding an ornament from \AIC{Œ¥}\ \AV{D}\ \AV{R} to \AIC{Œ¥}\ \AV{D'}\ \AV{R'}. This ornament can be modelled by first adding a new field \AD{Œº}\ \AV{R'}, and then deleting the original \AD{Œº}\ \AV{R} field. The ornament \AIC{‚àá} \cite{kophd} allows one to provide a default value for a field, deleting it from the description. Hence, we can model \AIC{‚àôŒ¥} by binding a value \AV{r'} of \AD{Œº}\ \AV{R'} with \AF{OŒîœÉ+} and deleting the field \AD{Œº}\ \AV{R} using a default value computed by \AF{ornForget}.


\subsection{No sparse numerical representations}\label{sec:discussion-no-sparse}
\begin{outline}
\footnote{Consequently, this excludes the skew binary numbers \cite{oka95b} in their useful sparse representation, but this functionality can be regained by allowing for addition \emph{and} variable multiplication in a \AIC{œÉ}. While not worked out in this thesis, this extension is compatible with the later constructions.}.
%The choice of interpretation restricts the numbers to the class of numbers which are evaluated as linear combinations of digits.
\footnote{An arbitrary \AF{Number} system is not necessarily isomorphic to \bN{}, as the system can still be incomplete (i.e., it cannot express some numbers) or redundant (it has multiple representations of some numbers).}. This class certainly does not include all interesting number systems, but does include many systems that have associated arrays\footnote{Notably, arbitrary polynomials also have numerical representations, interpreting multiplication as precomposition.}. 
\end{outline}
    



%\subsection{Variables slightly later}
%package them with the constructor descriptions rather than only after a sigma
% separate substitutions -> probably 


%\subsection{Less commutative squares}
%\autoref{rem:orn-lift} -> Discussion
% \begin{remark}\label{rem:orn-lift}
%     Rather than having the user provide two indices and show that the square commutes, we can ask for a ``lift'' $k$
%     % https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXGJ1bGxldCJdLFsxLDAsIlxcYnVsbGV0Il0sWzAsMSwiXFxidWxsZXQiXSxbMSwxLCJcXGJ1bGxldCJdLFswLDEsImUiXSxbMiwzLCJmIiwyXSxbMiwwLCJqIl0sWzMsMSwiaSIsMl0sWzMsMCwiayIsMV1d
%     \[\begin{tikzcd}
%         \bullet & \bullet \\
%         \bullet & \bullet
%         \arrow["e", from=1-1, to=1-2]
%         \arrow["f"', from=2-1, to=2-2]
%         \arrow["j", from=2-1, to=1-1]
%         \arrow["i"', from=2-2, to=1-2]
%         \arrow["k"{description}, from=2-2, to=1-1]
%     \end{tikzcd}\]
%     and derive the indices as $i = ek, j = kf$. However, this is more restrictive, unless $f$ is a split epi, as only then pairs $i,j$ and arrows $k$ are in bijection. In addition, this makes ornaments harder to work with, because we have to hit the indices definitionally, whereas asking for the square to commute gives us some leeway (i.e., the lift would require the user to transport the ornament). 
% \end{remark}



%\subsection{Œ¥ is conservative over Desc and Orn}
%If we include the ornament \AIC{‚àáœÉ} dropping a field by giving a default value \AV{V}\ \AF{‚äß}\ \AV{S} in place of a \AIC{œÉ}:
%\ExecuteMetaData[Tex/Discussion]{nabla-sigma}
%then we can also represent \AIC{‚àôŒ¥} without further modifying \AD{ConOrnDesc}. Namely
%\ExecuteMetaData[Tex/Discussion]{comp-delta-nabla-sigma}
%This emulates the \AIC{‚àôŒ¥} over an ornament \AV{RR‚Ä≤}, by first adding a field of \AD{Œº}\ (\AF{toDesc}\ \AV{RR‚Ä≤}) and then fixing a default value for \AD{Œº}\ \AV{R} by using \AF%{ornForget}.
%This makes the presentation of the descriptions and ornaments, and the interpretations of both simpler. However, this has the downside of needing a transport (or, %with-abstraction) for each pattern match on a value which would otherwise be a \AIC{Œ¥}.


%\subsection{Reconcile calculating and trieifyOD}
%\begin{outline}
%    In the computation of generic numerical representations, we gave \AF{trieifyOD} directly, rather than as the consequence of a calculation. %\todo{This is simply because a) %the wheels would come off very soon b) trieifyOD is not a definition but rather describes one.}
%
%    By abstracting \AF{Def} over a function, we can elegantly describe the kind of object we are looking for
%    \[ ... \]
%    but because we factor through an interpretation into \AD{Type}, we still have to give the definition before we can construct the isomorphism.
%
%    Maybe this works better for trieifyOD itself, where the isomorphism is really a composition of smaller isomorphisms by analyzing the descriptions, rather than one global %isomorphism as is the case when comparing Lookup and VecD.
%
%    See Tex.Disussion.Def-cong
%\end{outline}



%\subsection{?}
%While evidently Ix x != Fin (toN x) for arbitrary number systems, does the expected iso Ix x -> A = Trie A x yield Traversable, for free?

%\subsection{Odd numerical representations} % mark: but that's not _my_ problem is it?
%the numerical representation of 2-3 fingertrees is a bit odd, or trivial.
%I do not know whether there is a datastructure (let alone numerical representation) which has amortized constant append on both sides, and has logarithmic lookup, but uses only simple nesting (i.e., nesting over a functor with only products and no sums).

% is fold and map really valid and terminating? -> the whole --cubical --safe not being safe really undermines this

% + The use of 2-3 trees as opposed to pairs is essential: one can prove a lower
% bound of Œ©(‚àön) for insertion and deletion if the data structure is uniquely
% determined by its size
% - ralf

% Yeah it might be nicer to have metadata outside of the descriptions like in Generics.SOP. This is easy enough to implement, but requires a bit of simultaneous induction for generic definitions. 