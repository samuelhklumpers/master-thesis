\section{Agda}\label{sec:background-agda}
\changed{Note to self: add more citations and then double check them below here}
\changed{Also, type in type: we know that nothing breaks with universe polymorphism \cite{practgen}, but it does not make things easier to read.}
We formalize all of our work in the programming language Agda \cite{agda}. While we will only occasionally reference Haskell, those more familiar with Haskell may look at Agda as an extension of Haskell (in a rough approximation). Agda is a total functional programming language with dependent types, where totality means that functions of a given type always terminate in a value of that type, ruling out non-terminating (and not obviously terminating) programs. Using the dependent types we can use Agda as a proof assistant, allowing us to state and prove theorems about our datastructures and programs. 

In this section, we will explain and highlight some parts of Agda which will be necessary to discuss the work in later sections.


\section{Data in Agda}\label{sec:background-data}
At the level of ordinary (i.e., generalized algebraic) datatypes, Agda is close to Haskell. In both languages, one can define objects using data declarations, and interact with them using function declarations. For example,
\ExecuteMetaData[Tex/Background]{Bool}
The constructors of this type tell us we can make values of \AD{Bool} in exactly two ways, \AIC{false} and \AIC{true}. We can then define (non-trivial) functions on \AD{Bool} by pattern matching. As an example, we can define the conditional operator as
\ExecuteMetaData[Tex/Background]{conditional}
When pattern matching, we must provide definitions for each possible case of the pattern matched type\footnote{This is enforced by the coverage checker.}. 
%Take note that each line reads as an equality by definition, which agda also uses to discharge obvious equalities we will see later when proving equalities

We can also define a type representing numbers as a datatype
\ExecuteMetaData[Tex/Background]{Nat}
such that \bN{} always has a \AF{zero} element, and for each element $n$ the constructor \AIC{suc} expresses that there is also an element representing $n + 1$. In conclusion, \bN{} represents the positive integers, henceforth naturals. Similarly, we can pattern match on \bN{} to define the comparison operator
\ExecuteMetaData[Tex/Background]{lt}
Now one of the cases contains a recursive instance of \bN{}, the coverage checker and termination checker ensure that we still define $n < m$ for all possible combinations of $n$ and $m$. Essentially, these checks make sure that any valid definition by pattern matching corresponds to a valid proof by cases and induction\footnote{Also note that in this case we actually have a simultaneous induction on two arguments. This is tolerated when the arguments decrease lexicographically. In other words, a simultaneous induction is valid iff the clauses can be permuted to become a nested sequence of valid inductions.}.

We could now directly define lists of natural numbers, but then we would have to also repeat this for lists of booleans, and all other types. Using parameters, we can define lists as a family of types instead:
\ExecuteMetaData[Tex/Background]{List}
defining a type of lists for each type. Introducing a parameter in a datatype corresponds to abstracting the body of the type over a free variable, by applying this abstraction one gets a type for each value of the parameter.
We can work with lists by inserting some elements, and extracting them later:
\ExecuteMetaData[Tex/Background]{lookup-list}
However, the type of this function is a bit weaker than we might like, as we are relying on the type
\ExecuteMetaData[Tex/Background]{Maybe}
to handle the case where the index falls outside the list, and we cannot return an element. Note that checking whether
\ExecuteMetaData[Tex/Background]{length}
satisfies \AV{n}\ \AF{<}\ \AF{length}\ \AV{xs} beforehand amounts to the same, and only gives us \AIC{false} when we would otherwise get \AIC{nothing}.

If we know the length of the list, then we also know for which indices \AF{lookup} will succeed, and for which it will not. To encode and use this information we will need indexed types. Like parameters, indices add a variable to the context of a datatype, but unlike parameters, indices can influence the availability of constructors. This difference can be used to constrain the possible values of a variable from the type level. As an example, we can index \AD{Bool} over itself:
\ExecuteMetaData[Tex/Background]{HBool}
This defines a singleton type, in which knowing the type of a variable of uniquely fixes its value: \AD{HBool}\ \AIC{true} can only be \AIC{htrue}, while \AD{HBool}\ \AIC{false} can only be \AIC{hfalse}.

Applying this idea to naturals and lists, we create the following pair of types:
\ExecuteMetaData[Tex/Background]{Fin-Vec}
Here, \AD{Fin}\ \AIC{zero} contains no elements, and the only vector in \AD{Vec}\ \AIC{zero} is the empty vector \AIC{[]}, containing no elements. Likewise, \AD{Fin}\ (\AIC{suc}\ \AV{n}) contains one more element than \AD{Fin}\ \AV{n}, and a vector of type \AD{Vec}\ (\AIC{suc}\ \AV{n}) is necessarily a vector \AD{Vec}\ \AV{n} with one more element. From this we conclude that \AD{Fin}\ \AV{n} is exactly the type of suitable indices into a \AD{Vec}\ \AV{n}. Note that we can still interconvert between lists and vectors, in one direction dropping the index
\ExecuteMetaData[Tex/Background]{toList}
Dependent functions let us bind variables in type signatures, and use them in later types. With them, we can convert in the other direction, recomputing the index:
\ExecuteMetaData[Tex/Background]{toVec}
We can also define
\ExecuteMetaData[Tex/Background]{lookup}
as a dependent function by letting the size of the index type vary with the length of the vector. The case in which we would return \AIC{nothing} for lists, is now actually impossible and can be discarded. Lookup always succeeds for vectors, demonstrating that vectors are correct-by-construction. However, this does not yet prove that \AF{lookup} always returns the right element. We will need some more logic to verify this.

\section{Proving in Agda}\label{sec:background-proving}
When defining vectors, we saw how knowing the index of a variable constrains the values it can assume. We can use this to define a datatype in which the index actually determines whether there is any value, or none at all:
\ExecuteMetaData[Tex/Background]{equiv}
Here, we have \AIC{refl} of type \AD{Eq}\ \AV{a}\ \AV{b} if and only if \AV{a} is \AV{b}, whence the \AD{\_≡\_} symbol. We can use this type to describe the behaviour of functions like \AF{lookup}: If we can insert elements into a vector
\ExecuteMetaData[Tex/Background]{insert}
we can express the correctness of \AF{lookup} as
\ExecuteMetaData[Tex/Background]{lookup-insert-type}
To prove this, we proceed as when defining any other function, by pattern matching as the equivalent of induction. %For example, by induction on \AD{\_equiv\_} we can prove:
%:memo: trans
%This proof uses that pattern matching on \AIC{refl} unifies \AV{a} and \AV{b}, such that the type of \AV{q} unifies with the goal \AV{a}\ \AD{\_equiv\_}\ \AV{c}.
By simultaneous induction on the index and vector of \AF{lookup-insert-type} we get
\ExecuteMetaData[Tex/Background]{lookup-insert}
Other than \AD{\_≡\_}, we can encode many more logical operations into datatypes. For example, we can encode disjunctions (the logical or operation) as
\ExecuteMetaData[Tex/Background]{uplus}
While we generally do not directly use these explicit encodings, we will appeal to the logical content of some types in later sections. The disjunction, together with some other types form a correspondence between types and logic, known as the Curry-Howard isomorphism.

The other components of this isomorphism are as follows. Conjunction (logical and) can be interpreted by\footnote{A (inductive) record type is almost equivalent to a datatype with one constructor. One advantage of records is that, e.g., $(a, b) = (c , d) \iff a = c \land b = d$ holds automatically.}
\ExecuteMetaData[Tex/Background]{product}
True and false are represented by
\ExecuteMetaData[Tex/Background]{true}
and respectively
\ExecuteMetaData[Tex/Background]{false}
Interpreting logical implication as the function type, we also get negation in terms of implication and false
\ExecuteMetaData[Tex/Background]{not}

Quantifiers require dependent types to implement. In
\ExecuteMetaData[Tex/Background]{exists}
if \AV{P} is a formula containing a variable of type \AV{A}, the existential quantifier represents that there is an element \AV{fst} of \AV{A} for which \AV{P}\ \AV{a} is true. The universal quantifier
\ExecuteMetaData[Tex/Background]{forall}
represents that for each \AV{a} of type \AV{A} the formula \AV{P}\ \AV{a} is true.

More generally, we can read function types as chains of implications and universal quantifications. Furthermore, datatypes can be read as conjunctions of their constructors, each of which can be seen as a combination of conjunctions (unbound fields) and existentials (bound fields). 


\section{Numerical representations}\label{sec:background-numerical}
In the previous section, we saw that \AD{Vec} equipped with \AF{lookup} and \AF{insert} satisfies a useful container law. In fact, the definitions of \AF{lookup} and \AF{insert}, as well as the proof of \AF{lookup-insert} are almost trivial. From this, we might deduce that \AD{Vec} is quite a natural container for \bN{}, which we can make formal by comparing \AD{Vec} to the most natural, and trivial, container.

This trivial container, also known as representable, is obtained by reading \AF{lookup} as a prescript:
\ExecuteMetaData[Tex/Background]{Lookup}
One can see that for \AD{Lookup}, we can define \AF{lookup} as the identity. If a container law is consistent, then \AD{Lookup} will also satisfy it, which we can use to simplify the verification of the same laws for \AD{Vec}, or other containers: if a container is equivalent to \AD{Lookup}, then it automatically is correct as a container.

To describe such equivalences, we import the notion of isomorphisms into types:
\ExecuteMetaData[Tex/Background]{Iso}
which expresses that \AV{A} and \AV{B} are isomorphic if we can go back and forth between them, and doing so brings you back where you started\footnote{Which is equivalent to the other notion of equivalence: one has a conversion $f : A \to B$, and for each \AV{b} in \AV{B} there is exactly one \AV{a} in \AV{A} for which $f(a) = b$.}.

Rather than defining \AD{Vec} ``out of the blue'' and proving that it is correct or isomorphic to \AD{Lookup}, we can also turn the isomorphism on its head. Instead, we can start from the equation that \AD{Vec} is equivalent to \AD{Lookup}, and then calculate \AD{Vec} as if solving that equation \cite{calcdata}. We can also derive \AD{Fin}: the finite type \AD{Fin}\ \AV{n} should actually contain \AV{n} elements, and thus be isomorphic to \AV{Σ[ m ∈ ℕ ] m < n}.

For the equational reasoning, we will use the ``use-as-definition''\footnote{Appendix} and equality reasoning notation\footnote{Agda Cubical, but I think this is readable.}. As a bonus, this allows us to break up the construction of harder isomorphisms into multiple small and easy-to-read steps. The equalities we will need are 
\ExecuteMetaData[Tex/NumRep]{Fin-lemmas}
We then put these together, constructing \AD{Fin}:
\ExecuteMetaData[Tex/NumRep]{Fin-def}
This definition of \AD{Fin} can then be used to define \AD{Lookup}. Using\footnote{Compare these to the algebra laws: $A^0 = 1$, $A^1 = A$ and $C^{A + B} = C^A C^B$.}
\ExecuteMetaData[Tex/NumRep]{Vec-lemmas}
we derive the type of vectors:
\ExecuteMetaData[Tex/NumRep]{Vec}


\section{Descriptions}\label{sec:background-descriptions}
In the previous sections we completed a quadruple of types (\bN{}, \AD{List}, \AD{Vec}, \AD{Fin}), even computing the latter two from \bN{}. These types also have nice interactions (\AF{length}, \AF{toList}, \AF{lookup}). This construction works because \bN{}, \AD{List}, \AD{Vec}, and \AD{Fin} all have the same shape, and one can expect it to work for similar quadruples. However, shape is not (yet) defined inside our language, so in this section, we will set out to explain the groundwork making this expectation sensible.

Before we can describe the shape of a datatype, we must describe what a datatype is. To this end, we define a type of descriptions. Comparing this to the terminology of Martin-L{\"{o}}f type theory, in which a type of types like \AD{Type} is known as a universe, we can think of a type of descriptions as an internal universe. Each description, or code, should then represent a type via an interpretation $U \to \mathrm{Type}$. 

Let us walk through some concrete universe constructions. We will start from a rather simple universe, building our way up to more general types, until we reach a universe in which we can describe the (\bN{}, \AD{List}, \AD{Vec}, \AD{Fin}) quadruple, which, as a bonus, gives some insight into the meaning of datatypes.

\subsection{Finite types}\label{ssec:background-fin}
As a start, we define a basic universe with two codes 0 and 1, respectively representing the types \AD{⊥} and \AD{⊤}, and the requirement that the universe is closed under sums and products:
\ExecuteMetaData[Tex/Background]{U-fin}
which we interpret as:
\ExecuteMetaData[Tex/Background]{int-fin}
In this universe, we can encode the type of booleans simply as 
\ExecuteMetaData[Tex/Background]{BoolD}
The types \AIC{𝟘} and \AIC{𝟙} are finite, and sums and products of finite types are also finite, which is why we call \AD{U-fin} the universe of finite types. Consequently, the type of naturals \bN{} cannot fit in \AD{U-fin}.

\subsection{Polynomial functors}\label{ssec:background-rec}
To accommodate \bN{}, we need to be able to express recursive types. By adding a code \AIC{ρ} to \AD{U-fin} representing recursive type occurrences, we can express those types: 
\ExecuteMetaData[Tex/Background]{U-rec}
However, the interpretation cannot be defined like in the previous example: when interpreting (\AIC{𝟙}\ \AIC{⊕}\ \AIC{ρ}), we need to know that the whole type was \AIC{𝟙}\ \AIC{⊕}\ \AIC{ρ} while processing \AIC{ρ}. Thus, we split the interpretation into types in two phases. First, we interpret the descriptions into polynomial functors
\ExecuteMetaData[Tex/Background]{int-rec}
By viewing such a functor as a type with a free type variable, the functor can model a recursive type by setting the variable to the type itself:
\ExecuteMetaData[Tex/Background]{mu-rec}
Recall the definition of \bN{}, which can be read as the declaration that \AD{ℕ} is a fixpoint: \AD{ℕ}\ \AD{≡}\ \AV{F}\ \AD{ℕ} for \AV{F X = ⊤ ⊎ X}. This makes representing \bN{} as simple as:
\ExecuteMetaData[Tex/Background]{NatD}

%[ :warning: mu is actually pretty fundamental (the mathematical way of viewing it) ]: #

\subsection{Sums of products}\label{ssec:background-sop}
A downside of \AD{U-rho} is that the definitions of types do not mirror their equivalent definitions in user-written Agda. We can define a similar universe using that polynomials can always be canonically written as sums of products. For this, we split the descriptions into a stage in which we can form sums, on top of a stage where we can form products.
\ExecuteMetaData[Tex/Background]{U-sop}
%need a bit more here
When doing this, we can also let the left-hand side of a product be any type, allowing us to represent ordinary fields:
%(footnote:warning: yes this is a problem and yes we fix this when parameters).
\ExecuteMetaData[Tex/Background]{Con-sop}
The interpretation of this universe, while analogous to the one in the previous section, is also split into two parts:
\ExecuteMetaData[Tex/Background]{int-sop}
In this universe, we can define the type of lists as a description quantified over a type:
\ExecuteMetaData[Tex/Background]{ListD-bad}
Using this universe requires us to split functions on descriptions into multiple parts, but makes interconversion between representations and concrete types straightforward.

\subsection{Parametrized types}\label{ssec:background-par}
The encoding of fields in \AD{U-sop} makes the descriptions large. In contrast to the universes before, this makes \AD{U-sop} not foldable. By introducing parameters in the right way\footnote{The right way for us, that is. If a foldable universe means nothing to you, there are simpler encodings for parameters and indices, which are recorded in the appendix\footnote{(ref)}.}, we can restore the foldability of the universe as a bonus.

In the last section, we saw that we could define the parametrized type \AD{List} by quantifying over a type. However, in some cases, we will want to be able to inspect or modify the parameters belonging to a type\footnote{For example, deriving Traversable for parametrized types as functions would not be possible (without macros), as one could not decide whether the signature of a type in a field is compatible.}. To represent the parameters of a type, we will need a new gadget. The parameters could, of course, be represented like \AD{List}\ \AD{Type}, but this excludes types like the existential quantifier \AD{Σ\_}. In a general parametrized type, parameters can refer to bound values of preceding parameters. The parameters of a type are thus a sequence of types depending on each other, which we call telescopes. We define telescopes using induction-recursion:
\ExecuteMetaData[Tex/Background]{Tel-simple}
A telescope can either be empty, or be formed from a telescope and a type in the context of that telescope. Here, we used the meaning of a telescope \AF{⟦\_⟧tel} to define types in the context of a telescope. This meaning represents the valid assignment of values to parameters:
\ExecuteMetaData[Tex/Background]{int-simple}
interpreting a telescope into the dependent product of all the parameter types.

This definition of telescopes would let us write down the type of \AD{Σ}:
\ExecuteMetaData[Tex/Background]{sigma-tel}
but is not sufficient to give its definition, as we need to be able to bind a value \AV{a} of \AV{A} and reference it in the field \AV{P}\ \AV{a}. By quantifying telescopes over a type, we can represent bound arguments using almost the same setup \cite{practgen}:
\ExecuteMetaData[Tex/Background]{Tel-type}
A \AD{Tel}\ \AV{P} then represents a telescope for each value of \AV{P}, which we can view as a telescope in the context of \AV{P}. For readability, we redefine values in the context of a telescope as:
\ExecuteMetaData[Tex/Background]{entails}
so we can define telescopes and their interpretations as:
\ExecuteMetaData[Tex/Background]{Tel-def}
Of course, by setting \AV{P}\ =\ \AD{⊤}, we recover the previous definition of parameter-telescopes. We can then define an extension of a telescope as a telescope in the context of a parameter telescope:
\ExecuteMetaData[Tex/Background]{ExTel}
An \AD{ExTel}\ \AV{Γ} represents a telescope of variables over the fixed parameter-telescope \AV{Γ}, and can be extended independently of the parameters. Extensions can be interpreted as follows:
\ExecuteMetaData[Tex/Background]{int-ExTel}
where we interpret the parameter part first, and then interpret the variables for the given interpretation of the parameters.
We modify the codes of \AD{U-sop} to make use of the new telescopes
\ExecuteMetaData[Tex/Background]{U-par}
The function \AV{S →}\ \AD{U-sop} is now replaced by \AD{U-par}\ (\AV{V}\ \AIC{▷}\ \AV{S}), preserving the dependence in the variable-telescope, while avoiding the higher order argument. The interpretation is then given as:
\ExecuteMetaData[Tex/Background]{int-par}
We can describe lists using a one-type telescope:
\ExecuteMetaData[Tex/Background]{ListD}
Using the variable bound in \AIC{σ}, we can also define the existential quantifier:
\ExecuteMetaData[Tex/Background]{SigmaD}

\subsection{Indexed types}\label{ssec:background-ix}
Lastly, we can integrate indexed types into the universe by abstracting over indices. Recall that in native Agda datatypes, a choice of constructor can fix the indices of the recursive fields and the resultant type, so we encode\footnote{We could also use a telescope for indices, but we do not.}:
\ExecuteMetaData[Tex/Background]{U-ix}
The in most cases, the index is simply threaded through the interpretation, allowing for a choice in the relevant codes. If we are constructing a term of some indexed type, then the previous choices of constructors and arguments build up the actual index of this term. This actual index must then match the index we expected in the declaration of this term. This means that in the case of a leaf, we have to replace the unit type with the necessary equality between the expected and actual indices:
\ExecuteMetaData[Tex/Background]{int-ix}
In this universe, we can define finite types and vectors as:
\ExecuteMetaData[Tex/Background]{FinD}
and
\ExecuteMetaData[Tex/Background]{VecD}
We can now compare the structures in the quadruple (\bN{}, \AD{List}, \AD{Fin}, \AD{Vec}) by looking at their descriptions.

As a bonus, we can also use \AD{U-ix} for generic programming. For example, by a long construction which can be found in the appendix\footnote{the appendix}, we can define the generic fold operation:
\ExecuteMetaData[Tex/Background]{fold-type}
\todo{maybe explain why this does not give you foldr or sum for lists}

%\input{Background/Desc.tex}

\section{Ornaments}\label{sec:background-ornaments}
In this section we will introduce the concept of an ornament, used to compare descriptions, and give a simplified definition. Since we settled on \AD{U-ix} as our universe (for now), we redefine and rename a couple of things for readability and reusability:
\ExecuteMetaData[Tex/Background]{new-Nat-List}
Purely looking at their descriptions, \bN{} and \AD{List} are rather similar, except that \AD{List} has a parameter and an extra field \bN{} does not have. We could say that we can form the type of lists by starting from \bN{} and adding this parameter and field, while keeping everything else the same. In the other direction, we see that each list corresponds to a natural by stripping this information. Likewise, the type of vectors is almost identical to \AD{List}, can be formed from it by adding indices, and each vector corresponds to a list by dropping the indices.

These and similar observations can be generalized using ornaments \cite{algorn}, which define a language or binary relation, describing which datatypes can be formed by decorating others. Conceptually, an ornament from a type \AV{A} to a type \AV{B} represents that \AV{B} can be formed from \AV{A} by adding information or making the indices more specific. Consequently, for each ornament from \AV{A} to \AV{B}, we expect to get a function from \AV{B} to \AV{A} erasing this information and reverting to less specific indices.

If the indices \AV{J} (analogously, parameters \AV{Δ}) of \AV{B} are more specific than the indices \AV{I} (and parameters \AV{Γ}) of \AV{A}, we require functions from \AV{J} to \AV{I} and from \AV{Δ} to \AV{Γ}. Our ornaments
\ExecuteMetaData[Tex/Background]{Orn-type}
should then come equipped with a function:
\ExecuteMetaData[Tex/Background]{ornForget-type}
where we define \AF{Cxf} as the type of functions between (the interpretations of) \AV{Δ} and \AV{Γ}.

Since we are working with sums of products descriptions, we can decide that ornaments cannot change the number or order of constructors, and the actual work happens in the constructor ornaments:
\ExecuteMetaData[Tex/Background]{ConOrn-type}
and we define ornaments as lists of ornaments for all constructors:
\ExecuteMetaData[Tex/Background]{Orn}
(Similarly, we use \AF{Cxf′} as the type of functions between variables, respecting \AV{g}.)

To (readably) write down \AD{ConOrn}, we use a couple of helpers to manipulate telescopes:
\ExecuteMetaData[Tex/Background]{ConOrn-helpers}
% these only serve to add noise to this picture and appease the type checker. conceptually, you can view them as the ``natural'' conversions between some slightly different telescopes
These mostly interconvert some values between similar telescopes. But notably, if \AV{S} is of type \AV{V ⊢ Type}, then \AV{S} is a type in the context of \AV{V}, while \AV{V ⊧ S} is the type of values of \AV{S} in the context of \AV{V}.

Now we can define \AD{ConOrn}. Of course, we expect that adding nothing gives the identity ornament, which is encoded in the first three constructors of \AD{ConOrn}.
\ExecuteMetaData[Tex/Background]{ConOrn}
However, since the parameters, indices, and variables need not be identical on both sides (in particular, the variables can diverge even more depending on the preceding ornament), we have to ask that for \AIC{𝟙} and \AIC{ρ}, these are related by a structure respecting conversion, or more graphically, a commuting square\footnote{While for \AIC{σ}, we bake the relatedness of the fields in by letting the resulting descriptions only differ by the conversion \AV{v}.}. In fact, we will soon see that these pieces of information are exactly what we need to complete \AF{ornForget}.

The other two constructors, \AIC{∆} and \AIC{∇}, state that we can add fields, and remove fields if we provide a default value, respectively. Again, the constructor \AIC{∆} which adds a field depending on the variables requires some manner of commuting square.

We can now formulate the formation of \AD{List} from \bN{} as an ornament:
\ExecuteMetaData[Tex/Background]{NatD-ListD}
Using that \bN{} has no parameters or indices, we see that \AD{List} has more specific parameters, namely a single type parameter, and also no indices. Because of this, all commuting squares factor through the unit type and are hence (fortunately) trivial. This ornament preserves most structure of \bN{}, only adding a field of the type parameter of \AD{List} using \AIC{∆}.

We can also ornament \AD{List} to become \AD{Vec}, for which the index is more informative,
but the ornament does equally little:
\ExecuteMetaData[Tex/Background]{ListD-VecD}
Now the commuting square for the indices is equally trivial, but while the square for the parameters is still trivial, it is now an identity square, rather than a constant one.

We deferred the definition of \AF{ornForget}, so let us give it now. The process is split into two steps: first, we define a function to strip off a single layer of ornamentation:
\ExecuteMetaData[Tex/Background]{ornErase-type}
which uses the commutativity squares we required earlier to revert some values (and parameters, indices, and variables) to the unornamented type. For example, in the case of the \AIC{𝟙} preserving ornament\footnote{The rest, appendix.}:
\ExecuteMetaData[Tex/Background]{ornErase}
This function defines an algebra for the functor associated to a description \AV{E}:
\ExecuteMetaData[Tex/Background]{ornAlg}
We can now make good use of the generic fold we defined in \autoref{ssec:background-ix}!
\ExecuteMetaData[Tex/Background]{ornForget}
The function \AF{ornForget} also makes it easy to generalize relations of functions between similar types. For example, if we instantiate \AF{ornForget} for \AF{ℕD-ListD}, then the statement that list concatenation preserves length can equivalently be expressed as the commutation of concatenation and \AF{ornForget}.

%[ also, recomputation, but appendix ]: #
%[ remark, ornForget is never epi because of \sigma 0 ]: #

%\input{Background/Ornaments.tex}