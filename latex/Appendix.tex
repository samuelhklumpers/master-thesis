%\section{Appendices}

\begin{appendix}
\section*{Appendices}
\addcontentsline{toc}{section}{Appendices}
\renewcommand{\thesubsection}{\Alph{subsection}}
    
\todo{When all appendices are done, shuffle them into the order they are referenced in}

\subsection{Folding}\label{app:gfold}
In \autoref{ssec:generic-programming} and \autoref{sec:background-ornaments} we use \AF{fold}; we will give the complete definition of \AF{fold} here, but for \AD{DescI}, since it is essentially the same. We define the folding operation in what is effectively two steps to help out the termination checker, mutually defining \AF{fold} and a \AF{mapDesc}, representing the composition of the \AF{map} over interpretations (which we otherwise do not use and therefore did not define) and \AF{fold}:
\ExecuteMetaData[Tex/Background]{mapFold}
Here \AF{mapDesc} (and \AF{mapCon}) simply peel off and reassemble all non-recursive structure, applying \AF{fold} to the recursive fields; \AF{fold} is then defined in the usual way by applying its algebra \AV{f} to itself mapped over \AV{x}.

\subsection{Folding without Axiom K}\label{app:withoutk}
It could be interesting to study ornaments in the context of univalence or cubical type theory; currently, the theory of ornaments produces a lot of isomorphisms from relations between types, but these are not yet as powerful as they could be when comparing properties between related types. Univalence gives us the means to turn equivalences\footnote{Which are the same as isomorphisms for all datatypes we could discuss without \AV{--cubical} anyway} into equalities, allowing us to put an isomorphism between types to work by transporting properties over it.

Unfortunately, a direct port of ornaments into \AV{--cubical} is quickly stumped by the lack of Axiom K, as one would discover that the definitions of \AF{mapDesc} and \AF{mapCon} illegally pattern match on interpretations\footnote{Refer to \url{https://agda.readthedocs.io/en/v2.6.4.1-rc1/language/without-k.html} for the reason this is illegal; shortly put, recursion on a type which is not a datatype, and in our case the result of a function, can be used to derive \AD{⊥}.}.

This can be remedied by presenting interpretations as datatypes, albeit a bit dubiously; at the time of writing, this is also how you can circumvent a restriction on pattern matching emplaced by \AV{--cubical-compatible}\footnote{\href{https://github.com/agda/agda/issues/5910\#issuecomment-1601301237}{Relevant GitHub issue}}. However, our case is not really that profound, as it simply uses the duality between type computing functions and indexed types. Furthermore, since \AD{Desc} and \AD{Con} are unindexed types, they cannot accidentally carry equational content, and pattern matching on them does not generate transports in \AF{⟦\_⟧D} and \AF{⟦\_⟧C} anyway, so that the definition of \AF{fold} was already (morally speaking) safe to begin with.

With that out of the way, we can define the interpretations as indexed types
\ExecuteMetaData[Appendix/Intp]{Intp}
on which we are allowed to pattern match when defining \AF{mapDesc} and \AF{mapCon} in a way that is accepted:
\ExecuteMetaData[Appendix/Intp]{mapDesc}


\subsection{Random and friends \textit{do} live in U-ix}\label{app:unnested}
Some injustice to \AD{U-ix} has been done, and we can actually give equivalent encodings for some types we claimed it could not encode effectively or at all. This of course relies on the word ``equivalent'' to do most of the work. \todo{To be expanded, or removed.}



\begin{comment}
Use \AF{power} and indices.

Can still do an encoding of rosetrees.

\todo{write me}

\begin{outline}
Kun je aannemelijk maken dat er geen dependently typed encoding bestaat van Finger Trees? Voor binary random access lijsten, perfect trees, en lambda termen bestaan die wel... Of is de constructie te omslachtig?
\end{outline}

\subsection{Index-first}

\subsection{Sigma descriptions}\label{app:large-sigma}
\autoref{app:withoutk}

\subsection{ornForget and ornErase in full}\label{app:ornforget}

    \subsection{Heterogenization}
    %\input{Heterogenization.tex}
    
\footnote{If a foldable universe means nothing to you, there are simpler encodings for parameters and indices, which are recorded in \autoref{app:large-sigma}.}
    

\ExecuteMetaData[Ornament/OrnDesc]{toOrn} -> Appendix if at all

    \subsection{More equivalences for less effort}\label{sec:userfriendly}
    Noting that constructing equivalences directly or from isomorphisms as in \autoref{ssec:leibniz} can quickly become challenging when one of the sides is complicated, we work out a different approach making use of the initial semantics of W-types instead. We claim that the functions in the isomorphism of \autoref{ssec:leibniz} were partially forced, but this fact was unused there.
    
    First, we explain that if we assume that one of the two sides of the equivalence is a fixpoint or initial algebra of a polynomial functor (that is, the \AgdaDatatype{μ} of a \AgdaDatatype{Desc′}), this simplifies giving an equivalence to showing that the other side is also initial.
    
    We describe how we altered the original ornaments \cite{progorn} to ensure that \AgdaDatatype{μ} remains initial for its base functor in Cubical Agda, explaining why this fails otherwise, and how defining base functors as datatypes avoids this issue.
    
    In a subsection focussing on the categorical point of view, we show how we can describe initial algebras (and truncate the appropriate parts) in such a way that the construction both applies to general types (rather than only sets), and still produces an equivalence at the end. We explain how this definition, like the usual definition, makes sure that a pair of initial objects always induces a pair of conversion functions, which automatically become inverses. Finally, we explain that we can escape our earlier truncation by appealing to the fact that ``being an equivalence'' is a proposition.
    
    Next, we describe some theory, using which other types can be shown to be initial for a given algebra. This is compared to the construction in \autoref{ssec:leibniz}, observing that intuitively, initiality follows because the interpretation of the zero constructor is forced by the square defining algebra maps, and the other values are forced by repeatedly applying similar squares. This is clarified as an instance of recursion over a polynomial functor.
    
    To characterize when this recursion is allowed, we define accessibility with respect to polynomial functors as a mutually recursive datatype as follows. This datatype is constructed using the fibers of the algebra map, defining accessibility of elements of these fibers by cases over the description of the algebra. Then we remark that this construction is an atypical instance of well-founded recursion, and define a type as well-founded for an algebra when all its elements are accessible.
    
    We interpret well-foundedness as an upper bound on the size of a type, leading us to claim that injectivity of the algebra map gives a lower bound, which is sufficient to induce the isomorphism. We sketch the proof of the theorem, relating part of this construction to similar concepts in the formalization of well-founded recursion in the Standard Library. In particular, we prove an irrelevance and an unfolding lemma, which lets us show that the map into any other algebra induced by recursion is indeed an algebra map. By showing that it is also unique, we conclude initiality, and get the isomorphism as a corollary. 
    
    The theorem is applied and demonstrated to the example of binary natural numbers. We remark that the construction of well-foundedness looks similar to view-patterns. After this, we conclude that this example takes more lines that the direct derivation in \autoref{ssec:leibniz}, but we argue that most of this code can likely be automated.
    
\end{comment}

\end{appendix}