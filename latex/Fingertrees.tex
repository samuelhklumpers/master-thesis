%\towrite{Can we prove that the time complexity of head is always less than cons, similarly for lookup and insert?}
We know that some datastructures can be presented as non-redundant numerical representations, for example lists by unary numbers, random access lists by binary numbers \cite{calcdata}, and, skew binary heaps by skew binary numbers \cite{progorn}. So far, some of these examples do support amortized constant time \AgdaFunction{cons}, but they have at best logarithmic time \AgdaFunction{snoc}. This is reflected by their number systems, for which either the natural successor operation is logarithmic time, or is constant time, but can only act at the front. Instead, we will look at more redundant number systems, and refine these step-by-step to produce structures similar to finger trees. This gives us datastructures with fast access to both ends, and some of their properties for free.

\subsection{Binary finger trees}
If a datastructure has a numerical representation, we see that the operations on the datastructure must be coherent with the number system. Hence, if we want to have constant time \AgdaFunction{cons} and \AgdaFunction{snoc}, we must first have constant time \AgdaFunction{suc} anc \AgdaFunction{cus}. By starting from a symmetric number system, we can ensure good performance for both.

Note that such a system is necessarily redundant: if \AgdaFunction{suc} and \AgdaFunction{cus} both are amortized constant time, there must be cases where neither recurses (otherwise, there is a value and a sequence of \AgdaFunction{suc}s and \AgdaFunction{cus}s which cannot be amortized constant). On the other hand, both must clearly yield different values!

Symmetric unary numbers could be represented by a pair of Peano naturals, but would lead to a linear time \AgdaFunction{lookup}. 
By using a binary backbone for the numbers, we can get good \AgdaFunction{suc} and \AgdaFunction{lookup}
\ExecuteMetaData[FingerTrees/Simple]{bin-bad}
However, this shape is still not ideal. We can see that for values like
\ExecuteMetaData[FingerTrees/Simple]{bad-1}
applying \AgdaFunction{suc} would give
\ExecuteMetaData[FingerTrees/Simple]{bad-2}
Applying \AgdaFunction{pred} would take us back, so composing the two always takes logarithmic time \cite{ftanew}. To avoid this, we can give the numbers bigger digits (the system merely goes from redundant to slightly more redundant)
\ExecuteMetaData[FingerTrees/Simple]{bin-good}
Now applying \AgdaFunction{suc} to the pathological case
\ExecuteMetaData[FingerTrees/Simple]{good-1}
produces
\ExecuteMetaData[FingerTrees/Simple]{good-2}
instead, for which both \AgdaFunction{suc} and \AgdaFunction{pred} are constant time \footnote{More formally, we can use recursive slowdown \cite{purelyfunctional,recursiveslowdown} to show that any sequence of operations amortizes to constant time.}. We interpret this number system as
\ExecuteMetaData[FingerTrees/Simple]{interpret}
To extract the datastructure, we must find a suitable index type for these numbers. Since the numbers are redundant, we can also get trees of different shapes with the same size, each having a different and incompatible index type. However, the trees of a fixed shape are represented by functions, and the isomorphisms will still hold.

The computation of the index type from the interpretation of the numbers is straightforward. We first compute the indices for digits, which yields the indices for the numbers
\ExecuteMetaData[FingerTrees/Simple]{ix}
This represents simple finger trees as
\ExecuteMetaData[FingerTrees/Simple]{rep}
To define the basic array operations like \AgdaFunction{cons} on these functions as datastructures, we again construct a \AgdaFunction{Fin}-like view for the indices. For this we produce values corresponding to zero
\ExecuteMetaData[FingerTrees/Simple]{izero}
and induce the successor on the indices using
\ExecuteMetaData[FingerTrees/Simple]{isucc}
The view is similarly defined by
\ExecuteMetaData[FingerTrees/Simple]{iview}
letting us define
\ExecuteMetaData[FingerTrees/Simple]{ops}
We can again trieify this to get a concrete datastructure\footnote{I'll probably not do this manually, because it is theoretically analogous to the other trees, but hellish in practice}
\ExecuteMetaData[FingerTrees/Simple]{trieified}
Consequently, the concrete version will now obey all the relations the representable arrays obey as well. For example, for representable arrays we can easily see 
\ExecuteMetaData[FingerTrees/Simple]{head-cons}
hence, the concrete arrays obey this as well.

On the other hand, as
\ExecuteMetaData[FingerTrees/Simple]{succ-noncomm}
does not generally hold for symmetric binary, \AgdaFunction{cons} will not interchange with \AgdaFunction{snoc} for finger trees either\footnote{For starters, the types are different}; it seems that binary finger trees are not a very nice array type. Likewise, indexing into the finger trees is impractical, as changing shapes would require inefficient re-indexing. 

\subsection{Restoring efficient lookup}
Can we restore lookup? We can probably do something similar to the original finger trees, and maintain the sizes internally (hopelessly breaking the isomorphism\footnote{Or would it stay intact, since the shape determines the size anyway?}). Then we could state that a fingertree of a given size is just a finger tree of a shape paired with a proof that this shape has the right size.

\begin{comment}
We would like to quotient the redundancy of the number type away, which would also alleviate our issues related to indexing.

We can do this by imposing the following relation on the numbers
\[ \dots \]
and turning the number system into a setoid. This ensures that numbers with equal interpretetations are related, e.g.,
\[ \dots \]
Eliminating from this setoid should then respect this relation, so for example, we have to prove
\[ \dots \]

Similarly, we can keep the implementation of the binary finger trees, but also put this under an appropriate relation
\[ \dots \]
which ensures that the construction of the trees respects the relation on the number as well.
\end{comment}