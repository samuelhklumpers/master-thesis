\todo[inline, color=red]{Spend some more time on the context}
Agda \cite{agda} is a functional programming language and a proof assistant, taking inspiration from languages like Haskell and other proof assistants such as Coq. We can write programs as we would in Haskell, and then express and prove their properties all inside Agda. This allows us to demonstrate the correctness of programs by formal proof rather than by testing. 

However, this level of formality also trades-off the uncertainty of testing for a time-investment to produce these proofs. In this thesis, we will explore a variety of methods of proving properties of our programs, focussing on the problems that one may encounter, presenting solutions as they arise. Let us sketch some of these problems.

First, merely adapting a program to Agda may already require changes to the datatypes used in it; for example, if a program manipulating a \AgdaDatatype{List} uses the unsafe \AgdaFunction{head} function, then one is forced to replace the \AgdaDatatype{List} by a datatype that ensures non-emptiness, such as a \AgdaDatatype{NonEmpty} list or a length-aware vector \AgdaDatatype{Vec}. On the other hand, there might be sections of a program where the concrete length is not relevant for correctness and only gets in the way. As a result, one might find themselves duplicating common functions like concatenation \AgdaFunction{\_++\_} to only alter their signatures.

However, the ``new'' datatype (\AgdaDatatype{Vec}) is typically a simple variation on the old datatype (\AgdaDatatype{List}) making small adjustments to the existing constructors; in this case, we decorate the nil and cons constructors with natural numbers representing the length. This kind of modification of types falls in the framework of ornamentation as described by Ko and Gibbons \cite{progorn}; if two types are reified to their \textit{descriptions}, then \textit{ornaments} express whether the types are ``similar'' by acting as a recipe to produce one type from the other. By restricting the operations to the copying of corresponding parts, and the introduction of fields or dropping of indices, the existence of such an ornament ensures that the types have the same recursive structure.

\towrite{Something about patches.}

\towrite{For each invariant a new datatype? Still ornaments}

Now that we know we can organize similar datatypes using ornaments, it is time to look at dissimilar datatypes. It is conventional to prototype a program using simpler types or implementations, and only replace these with more performant alternatives in critical places; knowing that this is eventually going to happen, one might as well prepare for it. While this may quickly turn into a refactoring nightmare in the general case, we can hope for a more satisfying transition if we restrict our attention to a narrower scope. As an example, we might start programming using \AgdaDatatype{List}s, but replace this with a \AgdaDatatype{Tree} if we notice that the program spends most of its time in \AgdaFunction{lookup} operations. To gain a speedup, we will have to reimplement the operations on \AgdaDatatype{Tree}. This would also double the number of necessary proofs; however, we have two ways to avoid this problem. 

We will look at the more specific solution first. This solution is guided by the realization that \AgdaDatatype{List} and \AgdaDatatype{Tree}, like most other containers, still have similarities if their recursive structure is very different. That is, both resemble a number system, and, Okasaki \cite{purelyfunctional} notes that this resemblance to number systems is ``surprisingly common''. In the case of lists and Braun trees\footnote{Braun trees are a kind of binary tree, of which its shape is determined by its size.}, one can present both by deriving them from unary and binary numbers respectively, as is made formal by Hinze and Swierstra \cite{calcdata}. One can then apply this \textit{numerical representation} to simplify or make trivial the proofs of the properties we hesitated to duplicate before.

\towrite{If we instead hide our datatypes behind interfaces, we can use proof transport as an alternative.}

\towrite{Something about fingertrees, leading into the research question and proposed work}


\section{\toremove{Introduction}}
%The dependently typed functional programming language Agda \cite{agda} can, when restricted to its reasonable parts, be translated into readable and safe Haskell \cite{agda2hs}. However, the intrinsic safety of languages like Agda can also lead to code duplication by encouraging the use of multiple variants of the same datatype. As an example, the coverage check forces the \AgdaFunction{head} function on \AgdaDatatype{List} to return a \AgdaDatatype{Maybe}. This \AgdaDatatype{Maybe} can be avoided by moving to the length-indexed list type \AgdaDatatype{Vec}, at the cost of duplicating functions like \AgdaFunction{\_++\_}, which we need at both types.

Something similar happens when replacing an implementation with a more efficient one. For example, when implementing binary trees as a more efficient alternative to lists, the proofs of the same properties will differ between list and tree, and tend to be more difficult for the latter. Switching between implementations of an interface not only duplicates code, but also (and sometimes more than) doubles the effort required to verify both.\todo[inline, color=red]{concrete example?}

%There is plenty of prior work dealing with problems like these. The work in \cite{orntrans} and \cite{progorn} provides the means to relate similar datatypes, such as lists and vectors, using the mechanism of ornamentation, letting us organize variants of the same datatype in a rigid framework.  %This leads them to define the concept of patches, which can aid us when defining \AgdaFunction{\_++\_} for the second time by forcing the new version to be coherent.
%In fact, the algebraic nature of ornaments yields the definition of the vector type for free, provided we relate lists to natural numbers \cite{algorn}. %Such constructions rely heavily on descriptions of datastructures and often come with limitations in their expressiveness. These descriptions in turn impose additional ballast on the programmer, leading us to investigate reflection like in \cite{practgen} as a means to bring datatypes and descriptions closer when possible.

Other work like \cite{calcdata}\todo[inline, color=red]{don't use \textbackslash cite as noun} simplifies the proofs relating to certain containers directly, formally executing the way of though of numerical representations as noted in \cite{purelyfunctional}.
%From another point of view, lists and trees are not so different at all, provided we look at them through the interface of one-sided flexible arrays; this idea noted in \cite{purelyfunctional} and formalized in \cite{calcdata} where both are shown to be instances of numerical representations by calculating them from a numeral system. 

When two types are isomorphic and equivalent under an interface, proofs of properties of these implementations should be interconvertible. By using structured equivalences and univalence, \cite{iri} characterizes equivalences under interfaces.
%While this is achievable through meta-programming, substituting conversions to and from into the proof terms, this is internally expressible in Cubical Agda.

%We can liken the situation to movement on a plane, where ornamentation moves us vertically by modifying constructors or indices, and structured equivalences move us horizontally to and from equivalent but more equivalent implementations. In this paper, we will investigate a variety of means of moving around structures and proofs, and ways to make this more efficient or less intrusive.

In \autoref{sec:leibniz}, we will follow \cite{iri}, and look at how proofs on unary naturals can be transported to the binary naturals. Then in \autoref{sec:numrep} we recall how numeral systems in particular induce container types in \cite{calcdata}, which we attempt to reformulate in the language of ornaments in \autoref{ssec:ornaments}, using the framework of \cite{progorn}. In \autoref{sec:userfriendly} we investigate how we can make the earlier methods more easily accessible to the user, and, ourselves, when we give a description of finger trees in \autoref{sec:fingertrees}.\todo[inline, color=red]{Ok, but make the research question more concrete}

