Let us quickly review some features of Cubical Agda \cite{cuagda} that we will use in this section.

%Of course, this downside is more than offset by the benefits of changing our primitive notion of equality, which we will see makes it easier to show that ``equivalent'' structures behave identically. 
In Cubical Agda, the primitive notion of equality arises not (directly) from the indexed inductive definition we are used to, but rather from the presence of the interval type \AgdaPrimitiveType{I}. This type represents a set of two points \AgdaInductiveConstructor{i0} and \AgdaInductiveConstructor{i1}, which are considered ``identified'' in the sense that they are connected by a path. To define a function out of this type, we also have to define the function on all the intermediate points, which is why we call such a function a ``path''. Terms of other types are then considered identified when there is a path between them.

While the benefits are overwhelming for us\todo[inline, color=red]{Which?}, this is not completely without downsides, such as that
%\ExecuteMetaData[Tex/CubicalAndBinary]{cubical}% \todo[inline]{Not sure if it would be helpful to have a more extensive introduction covering all features used.} % at this moment, probably not, as the cubical usage is rather tame, so I'll probably stick to introducing stuff as it becomes necessary. % TODO then write that somewhere
the negation of axiom K complicates both some termination checking and some universe levels.\footnote{In particular, this prompts rather far-reaching (but not fundamental) changes to the code of previous work, such as to the machinery of ornaments \cite{progorn} in \autoref{sec:userfriendly}.} Furthermore, if we use certain homotopical constructions, and we wish to eliminate from our types as if they were sets, then we will also have to prove that they actually are sets.

On the positive side, this different perspective gives intuitive interpretations to some proofs of equality, like
\ExecuteMetaData[Tex/CubicalAndBinary]{sym}
where \AgdaFunction{∼\_} is the interval reversal, swapping \AgdaInductiveConstructor{i0} and \AgdaInductiveConstructor{i1}, so that \AgdaFunction{sym} simply reverses the given path.

Furthermore, because we can now interpret paths in record and function types in a new way, we get a host of ``extensionality'' for free. For example, a path in $A \to B$ is indeed a function which takes each $i$ in \AgdaPrimitiveType{I} to a function $A \to B$. Using this, function extensionality becomes tautological 
\ExecuteMetaData[Tex/CubicalAndBinary]{funExt}

Finally, %while in ``non-univalent'' Agda bijections or isomorphisms do not play such a central role,
much of our work will rest on equivalences, as the ``HoTT-compatible'' generalization of bijections. This is because in Cubical Agda, we have the univalence theorem 
%the \AgdaPrimitiveType{Glue} type tells us that equivalent types fit together in a new type, in a way that guarantees univalence
\ExecuteMetaData[Tex/CubicalAndBinary]{ua}
stating that ``equivalent types are identified'', such that type isomorphisms like $1 \to A \simeq A$ actually become paths $1 \to A \equiv A$, making it so that we can transport proofs along them. We will demonstrate this by a slightly more practical example in the next section.


\subsection{Unary numbers are binary numbers}\label{ssec:binary}
Let us demonstrate an application of univalence by exploiting the equivalence of the ``Peano'' naturals and the ``Leibniz'' naturals. Recall that the Peano naturals are defined as 
\ExecuteMetaData[Tex/CubicalAndBinary]{Peano}
This definition enjoys a simple induction principle and is well-covered in most libraries. However, the definition is also impractically slow, since most arithmetic operations defined on \bN{} have time complexity in the order of the value of the result.

As an alternative we can use the more performant binary numbers, for which for example addition has logarithmic time complexity. It would seem like these are less comprehensively proven about in typical libraries, but fortunately, this does not have to be a problem: the \bN{} naturals and the binary numbers should be equivalent after all!

Let us make this formal. We define the Leibniz naturals as follows:
\ExecuteMetaData[Leibniz/Base.tex]{Leibniz}
Here, the \AgdaInductiveConstructor{0b} constructor encodes 0, while the \AgdaInductiveConstructor{\_1b} and \AgdaInductiveConstructor{\_2b} constructors respectively add a 1 and a 2 bit, under the usual interpretation of binary numbers:
\ExecuteMetaData[Leibniz/Base.tex]{toN}
\ExecuteMetaData[Leibniz/Base.tex]{toN-2}
This defines one direction of the equivalence from \bN{} to \bL{}, for the other direction, we can interpret a number in \bN{} as a binary number by repeating the successor operation on binary numbers:
\ExecuteMetaData[Leibniz/Base.tex]{bsuc}
\ExecuteMetaData[Leibniz/Base.tex]{fromN}
To show that \AgdaFunction{toℕ} is an isomorphism, we have to show that it is the inverse of \AgdaFunction{fromℕ}. By induction on \bL{} and basic arithmetic on \bN{} we see that
\ExecuteMetaData[Leibniz/Properties.tex]{toN-suc}
so \AgdaFunction{toℕ} respects successors. Similarly, by induction on \bN{} we get
\ExecuteMetaData[Leibniz/Properties.tex]{fromN-1}
and % I can't get the code blocks to stick together lol
\ExecuteMetaData[Leibniz/Properties.tex]{fromN-2}
so that \AgdaFunction{fromℕ} respects even and odd numbers. We can then prove that applying \AgdaFunction{toℕ} and \AgdaFunction{fromℕ} after each other is the identity by repeating these lemmas
\ExecuteMetaData[Leibniz/Properties.tex]{N-iso-L}
This isomorphism can be promoted to an equivalence
\ExecuteMetaData[Leibniz/Properties.tex]{N-equiv-L}
which, finally, lets us identify \bN{} and \bL{} by univalence
\ExecuteMetaData[Leibniz/Properties.tex]{N-is-L}
The path \AgdaFunction{ℕ≡L} then allows us to transport properties from \bN{} directly to \bL{}; as an example, we have not yet shown that \bL{} is discrete, i.e., has decidable equality. Using substitution, we can quickly derive this\footnote{Of course, this gives a rather inefficient equality test, but for the homotopical consequences this is not a problem.}
\ExecuteMetaData[Leibniz/Properties.tex]{DiscreteL}
This can be generalized even further to transport proofs about operations from \bN{} to \bL{}.

\subsection{Functions from specifications}\label{ssec:useas}
As an example, we will define addition of binary numbers. We could transport \AgdaFunction{\_+\_} as a binary operation
\ExecuteMetaData[Extra/Algebra]{BinOp}
from \bN to \bL to get
\ExecuteMetaData[Tex/CubicalAndBinary]{badplus}
Unfortunately this is rather inefficient, incurring an $O(n + m)$ overhead when adding $n$ and $m$. It is more efficient to define addition on \bL{} directly, making use of the binary nature of \bL{}, while agreeing with the addition on \bN{}. Such a definition can be derived from the specification ``agrees with \AgdaFunction{\_+\_}'', so we implement a syntax for giving definitions by equational reasoning, inspired by the ``use-as-definition'' notation used by Hinze and Swierstra \cite{calcdata}: Using an implicit pair type
\ExecuteMetaData[Prelude/UseAs.tex]{isigma}
we define
\ExecuteMetaData[Prelude/UseAs.tex]{Def}
which extracts a definition as the right endpoint of a given path.
% \investigate{As of now, I am unsure if this reduces the effort of implementing a coherent function, or whether it is more typically possible to give a smarter or shorter proof by just giving a definition and proving an easier property of it\footnote{I will put the alternative in the appendix for now}}

With this we can define addition on \bL{} and show it agrees with addition on \bN{} in one motion
\ExecuteMetaData[Leibniz/Properties.tex]{plus-def}
Now we can easily extract the definition of \AgdaFunction{plus} and its correctness with respect to \AgdaFunction{\_+\_} 
\ExecuteMetaData[Leibniz/Properties.tex]{plus-good}

We remark that \AgdaFunction{Def} is close in concept to refinement types\footnote{À la \href{https://agda.github.io/agda-stdlib/Data.Refinement.html}{Data.Refinement}.}, but extracts the value from the proof, rather than requiring it before. \footnote{Unfortunately, normalizing an application of a \AgdaFunction{defined-by} function also causes a lot of unnecessary wrapping and unwrapping, so \AgdaFunction{Def} is mostly only useful for presentation.} %for now..


\subsection{The Structure Identity Principle}
We point out that \bN{} with \AgdaFunction{N.+} and \bL{} with \AgdaFunction{plus} form magmas. That is, inhabitants of
\[ magmaa \]
Using the well-known fact that a path in a \AgdaDatatype{Σ} type is just a \AgdaDatatype{Σ} of paths, we get a path from (\bN{}, \AgdaFunction{N.+}) to (\bL{}, \AgdaFunction{plus}). %More generally, a magma is simply a type $X$ with some structure, which is a function $f: X \to X \to X$ in the case of a magma. We can see that paths between magmas correspond to paths $p$ between the underlying types $X$ and paths over $p$ between their operations $f$.
This observation is further generalized by the Structure Identity Principle (SIP) as a form of representation indepence \cite{iri}. Given a structure, which in our case is just a binary operation
\ExecuteMetaData[Extra/Algebra.tex]{MagmaStr}
this principle produces an appropriate definition ``structured equivalence'' $\iota$. The $\iota$ is such that if structures $X, Y$ are $\iota$-equivalent, then they are identified. In the case of \AgdaFunction{MagmaStr}, the $\iota$ asks us to provide something with the same type as \AgdaFunction{plus-coherent}, so we have just shown that the \AgdaFunction{plus} magma on \bL{}
\ExecuteMetaData[Leibniz/Properties.tex]{magmaL}
and the \AgdaFunction{\_+\_} magma on \bN{} and are identical
\ExecuteMetaData[Leibniz/Properties.tex]{magma-equal}
As a consequence, properties of \AgdaFunction{\_+\_} directly yield corresponding properties of \AgdaFunction{plus}. For example,
\ExecuteMetaData[Leibniz/Properties.tex]{assoc-transport}\todo[inline, color=red]{Express what this accomplishes, and why this is impressive compared to without univalence}