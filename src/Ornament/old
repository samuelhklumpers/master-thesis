
{- -- older, direct attempt at indexed tries
TrieO-1  : (D : DescI If âˆ… âŠ¤) â†’ InfoF If Number â†’ OrnDesc Plain (âˆ… â–· const Type) ! (Î¼ D tt _) ! D

module _ {D' : DescI If âˆ… âŠ¤} where
  TrieO  : (D : DescI If âˆ… âŠ¤) â†’ InfoF If Number â†’ (âŸ¦ D âŸ§ (Î¼ D') tt _ â†’ Î¼ D' tt _) â†’ OrnDesc Plain (âˆ… â–· const Type) ! (Î¼ D' tt _) ! D
  TrieOC : âˆ€ {V} {W : ExTel (âˆ… â–· const Type)} {f : VxfO ! W V} (C : ConI If âˆ… âŠ¤ V) â†’ InfoF If Number â†’ (âˆ€ {p} w â†’ âŸ¦ C âŸ§ (Î¼ D') (tt , f {p = p} w) _ â†’ Î¼ D' tt _) â†’ ConOrnDesc Plain {W = W} {K = Î¼ D' tt _} f ! C
  TrieO-forget : âˆ€ {Ifâ€²} {iff : InfoF Ifâ€² If} (R : DescI Ifâ€² âˆ… âŠ¤) {p' : Î£ âŠ¤ (Î» x â†’ Type)} (Ï• : InfoF If Number) (q : Î¼ R tt tt) {if : â„•} s â†’
                 q â‰¡ ornForget (toOrn (TrieO-1 R (Ï• âˆ˜InfoF iff))) (tt , Vec (projâ‚‚ p') if) {i = q} s
 
  TrieO []      f ix = []
  TrieO (C âˆ· D) f ix = TrieOC C f (Î» v x â†’ ix (injâ‚ x)) âˆ· TrieO D f (ix âˆ˜ injâ‚‚)

  TrieOC {f = f} (ğŸ™ {if = if} j) Ï• ix =                               -- if the number is constantly if here
    Î”Ïƒ (Î» { ((_ , A) , _) â†’ Vec A (Ï• .ğŸ™f if)}) f projâ‚                      -- add if A's here
    (ğŸ™ (Î» { ((_ , A) , w) â†’ ix w refl })                            -- the index is completely determined by the context
    (const refl)) Î» p â†’ refl  
    
  TrieOC {f = f} (Ï {if = if} j g C) Ï• ix =                           -- if the number is recursively if * r + n here
    Î”Ïƒ (const (Î¼ D' tt tt)) (f âˆ˜ projâ‚) id                          -- for an index r
    (Ï (projâ‚‚ âˆ˜ projâ‚‚) (Î» { (_ , A) â†’ _ , Vec A (Ï• .Ïf if) })               -- keep the recursive field at r with parameter A^k
    (TrieOC C Ï• Î» { (w , r) n â†’ ix w (r , n) } )                      -- and compute the rest of the OD, the index is constructed from r and the context
    (Î» p â†’ refl) Î» p â†’ refl) Î» p â†’ refl
    
  TrieOC {f = f} (Ïƒ S {if = if} h C) Ï• ix =
    Ïƒ S id (h âˆ˜ VxfO-â–· f S)
    (Î”Ïƒ (Î» { ((_ , A) , _ , s) â†’ Vec A (Ï• .Ïƒf _ if _ s) }) (h âˆ˜ _) id
    (TrieOC C Ï• Î» { ((w , s) , x) n â†’ ix w (s , n) })
    Î» p â†’ refl) (Î» p â†’ refl)

  TrieOC {f = f} (Î´ {if = if} {iff = iff} j g R h C) Ï• ix with Ï• .Î´f _ _ if
  ... | refl , refl , if =
    Î”Ïƒ (const (Î¼ R tt tt)) (f âˆ˜ projâ‚) id
    (Î”Ïƒ (const (Î¼ D' tt tt)) (f âˆ˜ projâ‚ âˆ˜ projâ‚) id
    (âˆ™Î´ (Î» { ((_ , A) , ((w , r) , n)) â†’ _ , Vec A if }) (projâ‚‚ âˆ˜ projâ‚ âˆ˜ projâ‚‚)
    (TrieOC C Ï• Î» { (w , r) x â†’ ix w (r , x) })
    (TrieO-1 R (Ï• âˆ˜InfoF iff)) (projâ‚ âˆ˜ projâ‚) (Î» _ _ â†’ refl) (Î» _ _ â†’ refl) Î» { {p'} (((p , q) , r) , s) â†’ cong (Î» q â†’ h (f p , q)) (TrieO-forget R Ï• q s) })
    Î» p â†’ refl) Î» p â†’ refl

  TrieO-forget R Ï• (con q) (con s) = {!!}

TrieO-1 D f = TrieO {D' = D} D f con
-}

