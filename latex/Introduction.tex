There is a close relation between \emph{number systems} and \emph{datastructures} containing certain numbers of elements. Examples of datastructures designed to resemble a number system, are explored in Okasaki's Purely Functional Data Structures (\cite{purelyfunctional}, chapter 9) as \emph{numerical representations}, relating some known datastructures to their underlying number system.

To illustrate such an example, consider the binary numbers in their bijective, or zeroless, form (least significant digit first):
\ExecuteMetaData[Tex/Introduction]{Bin}
This definition declares that a binary number is either formed by \AIC{0b}, or by prepending either \AIC{1b} or \AIC{2b}. Here, \AIC{0b} represents the number 0, while \AIC{1b}\ \AV{n} corresponds to \AV{2n + 1}, representing the positive odd numbers, and \AIC{2b} corresponds to \AV{2n + 2}, representing the positive even numbers. As a \emph{positional number system}, \AD{Bin} has digits 1 and 2; counting from the left, starting at 0, the weight of a digit at the \AV{i}th position is $2^i$. For example, the number 5 is represented by \AIC{1b}\ \AIC{2b}\ \AIC{0b}, since $1 \cdot 2^0 + 2 \cdot 2^1 + 0 \cdot 2^2 = 5$.

Compare this to the type of random-access lists (complete binary trees) in their \emph{nested} (non-uniformly recursive) form (\cite{purelyfunctional}, subsections 9.2.2 and 10.1.2):
\ExecuteMetaData[Tex/Introduction]{Random}
Similarly, a random-access list can be formed by \AIC{Zero}, or by prepending \AIC{One}\ \AV{x} for some \AV{x} in \AV{A}, or by \AIC{Two}\ \AV{x}\ \AV{y} with both \AV{x} and \AV{y} in \AV{A}. Note that in the recursive fields of \AIC{One} and \AIC{Two}, we pass the type of pairs \AV{A}\ \AD{×}\ \AV{A} as the parameter rather than simply \AV{A} (hence the non-uniformity). In this recursive field, a \AIC{One} would thus ask for two values of \AV{A}, and another level deeper for four, and so on.

By forgetting that a random-access list \AV{xs} has fields, we find a binary number \AF{size}\ \AV{xs} again:
\ExecuteMetaData[Tex/Introduction]{size}
For example, applying \AF{size} to \AIC{One}\ \AV{\_}\ (\AIC{Two}\ \AV{\_}\ \AV{\_} \AIC{Zero}) gives us back \AIC{1b}\ \AIC{2b}\ \AIC{0b}. Additionally, this number given by \AF{size} coincides with the number of elements in \AV{xs}: evidently, the \AF{size} and number of elements of \AIC{Zero} are both zero. On the other hand, suppose that \AV{xs} of type \AD{Random}\ (\AV{A}\ \AD{×}\ \AV{A}) has size \AV{n}. Since \AV{A}\ \AD{×}\ \AV{A} contains two values of \AV{A}, we have doubled the weight of \AV{xs}, so that it actually contains \AV{2n} values of \AV{A}. Consequently, \AIC{One}\ \AV{x}\ \AV{xs} contains \AV{2n + 1} values, and \AIC{Two}\ \AV{x}\ \AV{y}\ \AV{xs} contains \AV{2n + 2} values, so in general any \AV{ys} contains \AF{size}\ \AV{ys} values.

In fact, if we remove the fields from random-access lists, binary numbers and random-access lists are essentially the same datatype. Conversely, we can describe random-access lists as binary numbers \emph{decorated} with fields. Exactly such ``informal human observations'' can be made more precise and general using the language of \emph{ornaments} as described by McBride \cite{algorn}. This language effectively describes up to which modifications, such as adding or deleting fields, one datatype can be seen as a more elaborate version of another. Using ornaments, we can formulate random-access lists as a patch on top of binary numbers, and get \AF{size} for free as the forgetful function.

Datastructures with relations to number systems occur more commonly, which raises the questions of how we can make this relation explicit in more general cases, but also which number systems have associated numerical representations, and which numerical representations arise from ornaments.

In this thesis we will explore how, for a certain generalization of positional number systems, we can construct all numerical representations as ornaments, and how some known examples of numerical representations fit into this framework, making the following contributions:
\begin{enumerate}
    \item We define a \emph{universe} in which we will encode number systems and numerical representations. This universe allows annotations, non-uniform datatypes, and composite datatypes. By encoding those datatypes in the universe, we gain the ability to write \emph{generic programs} over them.
    \item Then, we adapt ornaments to this universe, which lets us relate datatypes up to insertion of fields, nesting, and refinement of parameters, indices, and variables.
    \item Finally, we prove the existence of two variants of numerical representations by implementing generic functions from number systems to ornaments, establishing that each number system has a numerical representation of the same structure.
\end{enumerate}
As far as we are aware, a universe construction with this particular combination of features had not been studied before, hopefully allowing for further exploration of the interaction between features like non-uniform recursion and ornaments, and how incorporating generalized metadata can support more precise generic programming. 

We formalize our work using the dependently typed proof assistant Agda \cite{agda}. We use the unsafe \href{https://agda.readthedocs.io/en/latest/language/universe-levels.html}{\AV{--type-in-type} option (manual page)} so that the presented code is not diluted by the level variables, although our constructions can be modified to work without this flag \cite{practgen}. We also use \AV{--with-K}\footnote{In \ref{app:withoutk}~Appendix B, we explain a variant on the universe which is compatible \AV{--without-K}.} and omit some type variables using \href{https://agda.readthedocs.io/en/v2.6.4.1/language/generalization-of-declared-variables.html}{variable generalization (manual page)}.