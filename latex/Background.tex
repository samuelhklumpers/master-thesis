\section{Agda}\label{sec:background-agda}
We formalize our work in the programming language Agda \cite{agda}. While we will only occasionally reference Haskell, those more familiar with Haskell might understand (the reasonable part of) Agda as the subset of total Haskell programs \cite{agda2hs}.

Agda is a total functional programming language with dependent types. Here, totality means that functions of a given type always terminate in a value of that type, ruling out non-terminating (and not obviously terminating) programs. Using dependent types we can use Agda as a proof assistant, allowing us to state and prove theorems about our datastructures and programs. 

In this section, we will explain and highlight some parts of Agda which we use in the later sections. 
Many of the types we use in this section are also described and explained in most Agda tutorials (\cite{ulftutorial}, \cite{plfa}, etc.), and can be imported from the standard library \cite{agdastdlib}.

Note that we use \texttt{--type-in-type} to keep the explanations more readable. 
%and \texttt{--with-K}
% Even though the former makes Agda inconsistent, and the latter is not strictly necessary, we know that our work can be ported to a setting with neither option \autoref{app:withoutK}.


\section{Data in Agda}\label{sec:background-data}
At the level of generalized algebraic datatypes Agda is close to Haskell. In both languages, one can define objects using data declarations, and interact with them using function declarations. For example, we can define the type of \emph{booleans}:
\ExecuteMetaData[Tex/Background]{Bool}
The constructors of this type state that we can make values of \AD{Bool} in exactly two ways: \AIC{false} and \AIC{true}. We can then define functions on \AD{Bool} by pattern matching. As an example, we can define the conditional operator as
\ExecuteMetaData[Tex/Background]{conditional}
When \emph{pattern matching}, the coverage checker ensures we define the function on all cases of the type matched on, and thus the function is completely defined. % mark: shuffle

We can also define a type representing the natural numbers
\ExecuteMetaData[Tex/Background]{Nat}
Here, \bN{} always has a \AF{zero} element, and for each element $n$ the constructor \AIC{suc} expresses that there is also an element representing $n + 1$. Hence, \bN{} represents the \textit{naturals} by encoding the existential axioms of the Peano axioms. By pattern matching and recursion on \bN{}, we define the less-than operator:
\ExecuteMetaData[Tex/Background]{lt}
One of the cases contains a recursive instance of \bN{}, so termination checker also verifies that this recursion indeed terminates, ensuring that we still define \AV{n}\ \AF{<?} \AV{m} for all possible combinations of \AV{n} and \AV{m}. %Essentially, the coverage and termination checker make sure that any valid definition by pattern matching corresponds to a valid proof by cases and induction.
In this case the recursion is valid, since both arguments decrease before the recursive call, meaning that at some point \AV{n} or \AV{m} hits \AIC{zero} and the recursion terminates.

Like in Haskell, we can \emph{parametrize} a datatype over other types to make \emph{polymorphic} type, which we can use to define lists of values for all types:
\ExecuteMetaData[Tex/Background]{List} 
A list of \AV{A} can either be empty \AIC{[]}, or contain an element of \AV{A} and another list via \AIC{\_âˆ·\_}. In other words, \AD{List} is a type of \emph{finite sequences} in \AV{A} (in the sense of sequences as an abstract type \cite{purelyfunctional}).

Using polymorphic functions, we can manipulate and inspect lists by inserting or extracting elements. For example, we can define a function to look up the value at some position \AV{n} in a list
\ExecuteMetaData[Tex/Background]{lookup-list}
However, this function \emph{partial}, as we are relying on the type
\ExecuteMetaData[Tex/Background]{Maybe}
to handle the case where the position falls outside the list and we cannot return an element. 
If we know the length of the list \AV{xs}, then we also know for which positions \AF{lookup} will succeed, and for which it will not. We define 
\ExecuteMetaData[Tex/Background]{length}
so that we can test whether the position \AV{n} lies inside the list by checking \AV{n}\ \AF{<?}\ \AF{length}\ \AV{xs}. If we declare \AF{lookup} as a dependent function consuming a proof of \AV{n}\ \AF{<?}\ \AF{length}\ \AV{xs}, then \AF{lookup} always succeeds. However, this actually only moves the burden of checking whether the output was \AIC{nothing} afterwards to proving that \AV{n}\ \AF{<?}\ \AF{length}\ \AV{xs} beforehand.

We can avoid both by defining an \emph{indexed type} representing numbers below an upper bound
\ExecuteMetaData[Tex/Background]{Fin}
Like parameters, indices add a variable to the context of a datatype, but unlike parameters, indices can influence the availability of constructors. The type \AD{Fin} is defined such that a variable of type \AD{Fin}\ \AV{n} represents a number less than \AV{n}. Since both constructors \AIC{zero} and \AIC{suc} dictate that the index is the \AIC{suc} of some natural \AV{n}, we see that \AD{Fin}\ \AIC{zero} has no values. On the other hand, \AIC{suc} gives a value of \AD{Fin}\ (\AIC{suc}\ \AV{n}) for each value of \AD{Fin}\ \AV{n}, and \AIC{zero} gives exactly one additional value of \AD{Fin}\ (\AIC{suc}\ \AV{n}) for each \AV{n}. By induction (externally), we find that \AD{Fin}\ \AV{n} has exactly \AV{n} closed terms, each representing a number less than \AV{n}.

To complement \AD{Fin}, we define another indexed type representing lists of a known length, also known as vectors:
\ExecuteMetaData[Tex/Background]{Vec}
The \AIC{[]} constructor of this type produces the only term of type \AD{Vec}\ \AV{A}\ \AIC{zero}. The \AIC{\_âˆ·\_} constructor ensures that a \AD{Vec}\ \AV{A}\ (\AIC{suc}\ \AV{n}) always consists of an element of \AV{A} and a \AD{Vec}\ \AV{A}\ \AV{n}. By induction, we find that a \AD{Vec}\ \AV{A}\ \AV{n} contains exactly \AV{n} elements of \AV{A}. Thus, we conclude that \AD{Fin}\ \AV{n} is exactly the type of positions in a \AD{Vec}\ \AV{A}\ \AV{n}. In comparison to \AD{List}, we can say that \AD{Vec} is a type of arrays (in the sense of arrays as the abstract type of sequences of a fixed length). Furthermore, knowing the index of a term \AV{xs} of type \AV{Vec}\ \AV{A}\ \AV{n} uniquely determines the the constructor it was formed by. Namely, if \AV{n} is \AIC{zero}, then \AV{xs} is \AIC{[]}, and if \AV{n} is \AIC{suc} of \AV{m}, then \AV{xs} is formed by \AIC{\_âˆ·\_}. 

Using this, we define a variant of \AF{lookup} for \AD{Fin} and \AD{Vec}, taking a vector of length \AV{n} and a position below \AV{n}:
\ExecuteMetaData[Tex/Background]{lookup}
The case in which we would return \AIC{nothing} for lists, which is when \AV{xs} is \AIC{[]}, is omitted. This happens because \AV{x} of type \AD{Fin}\ \AV{n} is either \AIC{zero} or \AIC{suc}\ \AV{i}, and both cases imply that \AV{n} is \AIC{suc}\ \AV{m} for some \AV{m}. As we saw above, a \AD{Vec}\ \AV{A}\ (\AIC{suc} \AV{m}) is always formed by \AIC{\_âˆ·\_}, making the case in which \AV{xs} is \AIC{[]} impossible. Consequently, lookup always succeeds for vectors,
% demonstrating that vectors are correct-by-construction. 
however, this does not yet prove that \AF{lookup} necessarily returns the right element, we will need some more logic to verify this.

\section{Proving in Agda}\label{sec:background-proving}
To describe equality of terms we define a new type
\ExecuteMetaData[Tex/Background]{equiv}
If we have a value \AV{x} of \AV{a}\ \AD{â‰¡}\ \AV{b}, then, as the only constructor of \AD{\_â‰¡\_} is \AIC{refl}, we must have that \AV{a} is equal to \AV{b}. We can use this type to describe the behaviour of functions like \AF{lookup}: If we insert elements into a vector with
\ExecuteMetaData[Tex/Background]{insert}
we can express the correctness of \AF{lookup} as
\ExecuteMetaData[Tex/Background]{lookup-insert-type}
stating that we expect to find an element where we insert it.

% When we use pattern matching in a function, the coverage and termination checker ensure that the resulting function is total and defined by well-founded recursion\cite{?}. If we are proving some statement by constructing a function as a proof, this means that we can interpret a function definition by (dependent) pattern matching and well-founded recursion as a proof by well-founded induction\cite{?}.

%So, to 
To prove the statement, we proceed as when defining any other function. 
By simultaneous induction on the position and vector, we prove
\ExecuteMetaData[Tex/Background]{lookup-insert}
In the first two cases, where we \AF{lookup} the first position, \AF{insert}\ \AV{xs}\ \AIC{zero}\ \AV{y} simplifies to \AV{y}\ \AF{âˆ·}\ \AF{xs}, so the lookup immediately returns \AV{y} as wanted. In the last case, we have to prove that \AF{lookup} is correct for \AV{x}\ \AF{âˆ·}\ \AF{xs}, so we use that the \AF{lookup} ignores the term \AV{x} and we appeal to the correctness of \AF{lookup} on the smaller list \AV{xs} to complete the proof.

Like \AD{\_â‰¡\_}, we can encode many other logical operations into datatypes, which establishes a correspondence between types and formulas, known as the Curry-Howard isomorphism. For example, we can encode disjunctions (the logical `or' operation) as
\ExecuteMetaData[Tex/Background]{uplus}

The other components of the isomorphism are as follows. Conjunction (logical `and') can be represented by\footnote{We use a record here, rather than a datatype with a constructor \AV{A â†’ B â†’}\ \AV{A}\ \AD{Ã—}\ \AV{B}. The advantage of using a record is that this directly gives us projections like \ARF{fst}\ \AV{:}\ \AV{A}\ \AD{Ã—}\ \AV{B}\ \AV{â†’ A}, and lets us use eta equality, making $(a, b) = (c , d) \iff a = c \land b = d$ holds automatically.}
\ExecuteMetaData[Tex/Background]{product}
True and false are respectively represented by
\ExecuteMetaData[Tex/Background]{true}
so that always \AIC{tt}\ \AV{:}\ \AD{âŠ¤}, and 
\ExecuteMetaData[Tex/Background]{false}
The body of \AD{âŠ¥} is not accidentally left out: because \AD{âŠ¥} has no constructors, there is no proof of false\footnote{If we did not use \AV{--type-in-type}, and even in that case I can only hope.}.

Because we identify function types with logical implications, we can also define the negation of a formula \AV{A} as ``\AV{A} implies false'':
\ExecuteMetaData[Tex/Background]{not}
The logical quantifiers $\forall$ and $\exists$ act on formulas with a free variable in a specific domain of discourse. We represent closed formulas by types, so we can represent a formula with a free variable of type \AV{A} by a function values of \AV{A} to types \AV{A}\ \AV{â†’}\ \AD{Type}, also known as a predicate. The universal quantifier $\forall a P(a)$ is true when for all $a$ the formula $P(a)$ is true, so we represent the universal quantification of a predicate \AV{P} as a dependent function type \AV{(a : A) â†’ P a}, producing for each \AV{a} of type \AV{A} a proof of \AV{P}\ \AV{a}. The existential quantifier $\exists a P(a)$ is true when there is some $a$ such that $P(a)$ is true, so we represent the existential quantification as
\ExecuteMetaData[Tex/Background]{exists}
so that we have \AD{Î£}\ \AV{A}\ \AV{P} iff we have an element \AV{fst} of \AV{A} and a proof \AV{snd} of \AV{P}\ \AV{a}. To avoid the need for lambda abstractions in existentials, we define the syntax
\ExecuteMetaData[Tex/Background]{sigma-syntax}
letting us write \AD{Î£[}\ \AV{a}\ \AD{âˆˆ}\ \AV{A}\ \AD{]}\ \AV{P a} for $\exists a P(a)$.

\section{Descriptions}\label{sec:background-descriptions}
In the previous sections we completed a quadruple of types (\bN{}, \AD{List}, \AD{Vec}, \AD{Fin}), 
%, even computing the latter two from \bN{}.
which have nice interactions (\AF{length}, \AF{lookup}). Similar to the type of \AF{length}\ \AV{:}\ \AD{List}\ \AV{A}\ \AV{â†’}\ \bN{}, we can define
\ExecuteMetaData[Tex/Background]{toList}
converting vectors back to lists. In the other direction, we can also promote a list to a vector by recomputing its index:
\ExecuteMetaData[Tex/Background]{toVec}
We claim that is not a coincidence, but rather happens because \bN{}, \AD{List}, and \AD{Vec} have the same ``shape''.

But what is the shape of a datatype? In this section, we will explain a framework of datatype descriptions and ornaments, allowing us to describe the shapes of datatypes and use these for generic programming \cite{ulftutorial, genericsamm, effectfully, practgen}. Recall that while polymorphism allows us to write one program for many types at once, those programs act parametrically \cite{reynolds1983types, wadlerfree}: polymorphic functions must work for all types, thus they cannot inspect values of their type argument. Generic programs, by design, do use the structure of a datatype, allowing for more complex functions that do inspect values\footnote{Think of JSON encoding types with encodable fields \cite{truesop}, or deriving functor instances for a broad class of types \cite{haskellderiving}.}.

Using datatype descriptions we can then relate \bN{}, \AD{List} and \AD{Vec}, explaining how \AF{length} and \AF{toList} are instances of a generic construction. Let us walk through some ways of defining descriptions. We will start from simpler descriptions, building our way up to more general types, until we reach a framework in which we can describe \bN{}, \AD{List}, \AD{Vec} and \AD{Fin}. 
%, which, as a bonus, gives some insight into the meaning of datatypes.


\subsection{Finite types}\label{ssec:background-fin}
A datatype description, which are datatypes of which each value again represents a datatype, consist of two components. Namely, a type of descriptions \AV{U}, also referred to as codes, and an interpretation \AV{U}\ \AV{â†’}\ \AD{Type}, decoding descriptions to the represented types. In the terminology of Martin-L{\"{o}}f type theory (MLTT)\cite{levitation}, %\todo{No citation for MLTT? Agda is a rather loose extension, none of the original papers really match.}
where types of types like \AD{Type} are called universes, we can think of a type of descriptions as an internal universe.

As a start, we define a basic universe with two codes \AIC{ðŸ˜} and \AIC{ðŸ™}, respectively representing the types \AD{âŠ¥} and \AD{âŠ¤}, and the requirement that the universe is closed under sums and products:
\ExecuteMetaData[Tex/Background]{U-fin}
The meaning of the codes in this universe is then assigned by the interpretation
\ExecuteMetaData[Tex/Background]{int-fin}
which indeed sends \AIC{ðŸ˜} to \AD{âŠ¥}, \AIC{ðŸ™} to \AD{âŠ¤}, sums to sums and products to products\footnote{One might recognize that \AF{âŸ¦\_âŸ§fin} is a morphism between the rings (\AD{U-fin}, \AIC{âŠ•}, \AIC{âŠ—}) and (\AD{Type}, \AD{âŠŽ}, \AD{Ã—}). Similarly, \AD{Fin} also gives a ring morphism from \bN{} with \AF{+} and \AF{Ã—} to \AD{Type}, and in fact \AF{âŸ¦\_âŸ§fin} factors through \AD{Fin} via the map sending the expressions in \AD{U-fin} to their value in \bN{}.}.

In this universe, we can encode the type of booleans simply as 
\ExecuteMetaData[Tex/Background]{BoolD}
The types \AIC{ðŸ˜} and \AIC{ðŸ™} are finite, and sums and products of finite types are also finite, which is why we call \AD{U-fin} the universe of finite types. Consequently, the type of naturals \bN{} cannot fit in \AD{U-fin}.

\subsection{Recursive types}\label{ssec:background-rec}
To accommodate \bN{}, we need to be able to express recursive types. By adding a code \AIC{Ï} to \AD{U-fin} representing recursive type occurrences, we can express those types: 
\ExecuteMetaData[Tex/Background]{U-rec}
However, the interpretation cannot be defined like in the previous example: when interpreting \AIC{ðŸ™}\ \AIC{âŠ•}\ \AIC{Ï}, we need to know that the whole type was \AIC{ðŸ™}\ \AIC{âŠ•}\ \AIC{Ï} while processing \AIC{Ï}. As a consequence, we have to split the interpretation in two phases. First, we interpret the descriptions into polynomial functors
\ExecuteMetaData[Tex/Background]{int-rec}
Then, by viewing such a functor as a type with a free type variable, the functor can model a recursive type by setting the variable to the type itself:
\ExecuteMetaData[Tex/Background]{mu-rec}
Recall the definition of \bN{}, which can be read as the declaration that \AD{â„•} is a fixpoint: \AD{â„•}\ \AD{â‰¡}\ \AV{F}\ \AD{â„•} for \AV{F X = âŠ¤ âŠŽ X}. This makes representing \bN{} as simple as:
\ExecuteMetaData[Tex/Background]{NatD}

\subsection{Sums of products}\label{ssec:background-sop}
A downside of \AD{U-rho} is that the definitions of types do not mirror their equivalent definitions in user-written Agda. We can define a similar universe using that polynomials can always be canonically written as sums of products. For this, we split the descriptions into a stage in which we can form sums, on top of a stage where we can form products.
\ExecuteMetaData[Tex/Background]{U-sop}
When doing this, we can also let the left-hand side of a product be any type, allowing us to represent ordinary fields:
\ExecuteMetaData[Tex/Background]{Con-sop}
The interpretation of this universe, while analogous to the one in the previous section, is also split into two parts:
\ExecuteMetaData[Tex/Background]{int-sop}
In this universe, we can define the type of lists as a description quantified over a type:
\ExecuteMetaData[Tex/Background]{ListD-bad}
Using this universe requires us to split functions on descriptions into multiple parts, but makes interconversion between representations and concrete types straightforward.

\subsection{Parametrized types}\label{ssec:background-par}
The encoding of fields in \AD{U-sop} makes the descriptions large in the following sense: by letting \AV{S} in \AIC{Ïƒ} be an infinite type, we can get a description referencing infinitely many other descriptions. As a consequence, we cannot inspect an arbitrary description in its entirety. We will introduce parameters in such a way that we recover the finiteness of descriptions as a bonus.

In the last section, we saw that we could define the parametrized type \AD{List} by quantifying over a type. However, in some cases, we will want to be able to inspect or modify the parameters belonging to a type. % mark: why
%footnote{For example, deriving Traversable for parametrized types as functions would not be possible (without macros), as one could not decide whether the signature of a type in a field is compatible.}
To represent the parameters of a type, we will need a new gadget.

In a naive attempt, we can represent the parameters of a type as \AD{List}\ \AD{Type}. However, this cannot represent many useful types, of which the parameters depend on each other. For example, in the existential quantifier \AD{Î£\_}, the type \AV{A}\ \AV{â†’}\ \AD{Type} of second parameter \AV{B} references back to the first parameter \AV{A}.

In a general parametrized type, parameters can refer to the values of all preceding parameters. The parameters of a type are thus a sequence of types depending on each other, which we call telescopes \cite{practgen, sijsling, telescopes} (also known as contexts in MLTT). We define telescopes using induction-recursion:
\ExecuteMetaData[Tex/Background]{Tel-simple}
A telescope can either be empty, or be formed from a telescope and a type in the context of that telescope. Here, we used the meaning of a telescope \AF{âŸ¦\_âŸ§tel} to define types in the context of a telescope. This meaning represents the valid assignment of values to parameters:
\ExecuteMetaData[Tex/Background]{int-simple}
interpreting a telescope into the dependent product of all the parameter types.

This definition of telescopes would let us write down the type of \AD{Î£}:
\ExecuteMetaData[Tex/Background]{sigma-tel}
but is not sufficient to define \AD{Î£}, as we need to be able to bind a value \AV{a} of \AV{A} and reference it in the field \AV{P}\ \AV{a}. By quantifying telescopes over a type \cite{practgen}, we can represent bound arguments using almost the same setup:
\ExecuteMetaData[Tex/Background]{Tel-type}
A \AD{Tel}\ \AV{P} then represents a telescope for each value of \AV{P}, which we can view as a telescope in the context of \AV{P}. For readability, we redefine values in the context of a telescope as:
\ExecuteMetaData[Tex/Background]{entails}
so we can define telescopes and their interpretations as:
\ExecuteMetaData[Tex/Background]{Tel-def}
By setting \AV{P}\ \AV{=}\ \AD{âŠ¤}, we recover the previous definition of parameter-telescopes. We can then define an extension of a telescope as a telescope in the context of a parameter telescope:
\ExecuteMetaData[Tex/Background]{ExTel}
representing a telescope of variables over the fixed parameter-telescope \AV{Î“}, which can be extended independently of \AV{Î“}. Extensions can be interpreted by interpreting the variable part given the interpretation of the parameter part:
\ExecuteMetaData[Tex/Background]{int-ExTel}
We will name maps \AV{Î” â†’ Î“} of telescopes \AF{Cxf}\ \AV{Î”}\ \AV{Î“}. Given such a map \AV{g}, name maps \AV{W â†’ V} between extensions \AF{Vxf}\ \AV{g}\ \AV{W}\ \AV{V}:
\ExecuteMetaData[Tex/Background]{tele-helpers} %mark: map-var
We also defined two functions we will use extensively later: \AF{varâ†’par} states that a map of extensions extend to a map of the whole telescope, and \AF{Vxf-â–·} lets us extend a map of extensions by acting as the identity on a new variable. 

In the descriptions directly relay the parameter telescope to the constructors, resetting the variable telescope to \AIC{âˆ…} for each constructor:
\ExecuteMetaData[Tex/Background]{U-par}
Of the constructors we only modify the \AIC{Ïƒ} to request a type \AV{S} in the context of \AV{V}, and to extend the context for the subsequent fields by \AV{S}:
\ExecuteMetaData[Tex/Background]{Con-par}
Replacing the function \AV{S â†’}\ \AD{U-sop} by \AD{Con-par}\ (\AV{V}\ \AIC{â–·}\ \AV{S}) allows us to bind the value of \AV{S} while avoiding the higher order argument. The interpretation of the universe is then:
\ExecuteMetaData[Tex/Background]{int-par}
In particular, we provide \AV{X} the parameters and variables in the \AIC{Ïƒ} case, and extend context by \AV{s} before passing to the rest of the interpretation.

In this universe, we can describe lists using a one-type telescope:
\ExecuteMetaData[Tex/Background]{ListD}
This description declares that \AD{List} has two constructors, one with no fields, corresponding to \AIC{[]}, and the second with one field and a recursive field, representing \AIC{\_âˆ·\_}. In the second constructor, we used pattern lambdas to deconstruct the telescope\footnote{Due to a quirk in the interpretation of telescopes, the \AIC{âˆ…} part always contributes a value \ARF{tt} we explicitly ignore, which also explicitly needs to be provided when passing parameters and variables.} and extract the type \AV{A}.
Using the variable bound in \AIC{Ïƒ}, we can also define the existential quantifier:
\ExecuteMetaData[Tex/Background]{SigmaD}
having one constructor with two fields. Here, the first field of type \AV{A} adds a value \AV{a} to the variable telescope, which we recover in the second field by pattern matching, before passing it to \AV{B}.


\subsection{Indexed types}\label{ssec:background-ix}
Lastly, we can integrate indexed types \cite{iir} into the universe by abstracting over indices
\ExecuteMetaData[Tex/Background]{U-ix}
Recall that in native Agda datatypes, a choice of constructor can fix the indices of the recursive fields and the resultant type, so we encode:
\ExecuteMetaData[Tex/Background]{Con-ix}
%In most cases, the index is simply threaded through the interpretation, allowing for a choice in the relevant codes.
If we are constructing a term of some indexed type, then the previous choices of constructors and arguments build up the actual index of this term. This actual index must then match the index we expected in the declaration of this term. This means that in the case of a leaf, we have to replace the unit type with the necessary equality between the expected and actual indices \cite{algorn}:
\ExecuteMetaData[Tex/Background]{int-ix}
In a recursive field, the expected index can be chosen based on parameters and variables. % mark: wording

In this universe, we can define finite types and vectors as:
\ExecuteMetaData[Tex/Background]{FinD}
and
\ExecuteMetaData[Tex/Background]{VecD}
These are equivalent, but since we do not model implicit fields, they are slightly different in use compared to \AD{Fin} and \AD{Vec}. In the first constructor of \AF{VecD} we report an actual index of \AIC{zero}. In the second, we have a field \bN{} to bring the index \AV{n} into scope, which is used to request a recursive field with index \AV{n}, and report the actual index of \AIC{suc}\ \AV{n}. 

Let us also show how the definitions of naturals and lists from earlier sections can be replicated in \AD{U-ix}
\ExecuteMetaData[Tex/Background]{new-Nat-List}
Writing the descriptions \AF{NatD}, \AF{ListD} and \AF{VecD} next to each other makes it easy to see the similarities: \AF{ListD} is the same as \AF{NatD} with a type parameter and one more \AIC{Ïƒ}. Likewise, \AF{VecD} is the same as \AF{ListD}, but now indexing over \bN{} and with yet one more \AIC{Ïƒ} of \bN{}. This kind of analysis is the focus of \autoref{sec:background-ornaments}.

\subsubsection{Generic Programming}
As a bonus, we can also use \AD{U-ix} for generic programming. For example, by a long construction which can be found in \autoref{app:gfold}, we can define the generic \AF{fold} operation:
\ExecuteMetaData[Tex/Background]{fold-type}
Let us describe how \AF{fold} works intuitively. We can interpret a term of \AF{âŸ¦}\ \AV{D}\ \AF{âŸ§D}\ \AV{X} as a term of \AF{Î¼-ix}\ \AV{D}, where the recursive positions hold values of \AV{X} rather than values of \AF{Î¼-ix}\ \AV{D}. Then \AF{fold} states that a function collapsing such terms into values of \AV{X} extends to a function collapsing \AF{Î¼-ix}\ \AV{D} into \AV{X}, recursively collapsing applications of \AIC{con} from the bottom up.

As a more concrete example, when instantiating \AF{fold} to \AF{ListD}, the type \AF{âŸ¦}\ \AV{ListD}\ \AF{âŸ§D}\ \AV{X} reduces (up to equivalence) to \AD{âŠ¤}\ \AD{âŠŽ}\ (\AV{A}\ \AD{Ã—}\ \AV{X}\ \AV{A})\ \AF{â†’}\ \AV{X}\ \AV{A}, and \AF{fold} becomes
\ExecuteMetaData[Tex/Background]{foldr-type}
which, much like the familiar \AF{foldr} operation lets us consume a \AD{List}\ \AV{A} to produce a value \AV{X A}, provided a value \AV{X A} in the empty case, and a means to convert a pair (\AV{A}, \AV{X A}) to \AV{X A}.

Do note that this version takes a polymorphic function as an argument, as opposed to the usual fold which has the quantifiers on the outside:
\ExecuteMetaData[Tex/Background]{usual-fold}
Like a couple of constructions we will encounter in later sections, we can recover the usual fold into a type \AV{C} by generalizing \AV{C} to some kind of maps into \AV{C}. For example, by letting \AV{X} be continuation-passing computations into \bN{}, we can recover
\ExecuteMetaData[Tex/Background]{foldr-sum}


\section{Ornaments}\label{sec:background-ornaments}
In this section we will introduce a simplified definition of ornaments, which we will use to compare descriptions. Purely looking at their descriptions, \bN{} and \AD{List} are rather similar, except that \AD{List} has a parameter and an extra field \bN{} does not have. We could say that we can form the type of lists by starting from \bN{} and adding this parameter and field, while keeping everything else the same. In the other direction, we see that each list corresponds to a natural by stripping this information. Likewise, the type of vectors is almost identical to \AD{List}, can be formed from it by adding indices, and each vector corresponds to a list by dropping the indices.

Observations like these can be generalized using ornaments \cite{algorn, progorn, sijsling}, which define a binary relation describing which datatypes can be formed by ``decorating'' others. Conceptually, a type can be decorated by adding or modifying fields, extending its parameters, or refining its indices.

Essential to the concept of ornaments is the ability to convert back, forgetting the extra structure. After all, if there is an ornament from \AV{A} to \AV{B}, then \AV{B} is \AV{A} with extra fields and parameters, and more specific indices. In that case, we should also be able to discard those extra fields, parameters, and more specific indices, obtaining a conversion from \AV{B} to \AV{A}. If \AV{A} is a \AD{U-ix}\ \AV{Î“}\ \AV{I} and \AV{B} is a \AD{U-ix}\ \AV{Î”}\ \AV{J}, then a conversion from \AV{B} to \AV{A} presupposes a function \AV{re-par :}\ \AF{Cxf}\ \AV{Î”}\ \AV{Î“} for re-parametrization, and a function \AV{re-index :}\ \AV{J}\ \AV{â†’}\ \AV{I} for re-indexing.

In the same way that descriptions in \AD{U-ix} are lists of constructor descriptions, ornaments are lists of constructor ornaments. We define the type of ornaments reparametrizing with \AV{re-par} and reindexing with \AV{re-index} as a type indexed over \AD{U-ix}:
\ExecuteMetaData[Tex/Background]{Orn}
The conversion between types induced by an ornament is then embodied by the forgetful map
\ExecuteMetaData[Tex/Background]{bimap}
\ExecuteMetaData[Tex/Background]{ornForget-type}
which will revert the modifications made by the constructor ornaments, and restores the original indices and parameters.

The allowed modifications are controlled by the definition of constructor ornaments \AD{ConOrn}. We must keep in mind that each constructor of \AD{ConOrn} also has to be reverted by \AF{ornForget}, accordingly, some modifications have preconditions, which are in this case always pointwise equalities:
\ExecuteMetaData[Tex/Background]{htpy}
Since constructors exist in the context of variables, we let constructor ornaments transform variables with \AV{re-var}, in addition to parameters and indices.

The first three constructors of \AD{ConOrn} represent the operations which copy the corresponding constructors of \AD{Con-ix}\footnote{Viewing \AD{ConOrn} as a binary relation on \AD{Con-ix}, these represent the preservation of \AD{ConOrn} by \AIC{ðŸ™}, \AIC{Ï}, and \AIC{Ïƒ}, up to parameters, variables, and indices.}. The \AIC{Î”Ïƒ} constructors allows one to add fields which are not present on the original datatype.
\ExecuteMetaData[Tex/Background]{ConOrn}
% yes re-par can be implicit most of the time
% when you actually start using ornaments generically, it will come back to bite you though
The commuting square \AF{re-index}\ \AF{âˆ˜}\ \AV{j}\ \AF{âˆ¼}\ \AV{i}\ \AF{âˆ˜}\ \AF{varâ†’par}\ \AV{re-var} in the first two constructors ensures that the indices on both sides are indeed related, up to \AV{re-index} and \AV{re-var}.

Now, we can show that lists are indeed naturals decorated with fields:
\ExecuteMetaData[Tex/Background]{NatD-ListD}
This ornament preserves most structure of \bN{}, only adding a field using \AIC{âˆ†Ïƒ}\footnote{Note that \AV{S}, and some later arguments we provide to ornaments, are implicit argument: Agda would happily infer them from \AF{ListD} and later \AF{VecD} had we omitted them.}. As \bN{} has no parameters or indices, \AD{List} has more specific parameters, namely a single type parameter. Consequently, all commuting squares factor through the unit type and can be satisfied with \AV{Î»}\ \AV{\_}\ \AV{â†’}\ \AIC{refl}. 

We can also ornament lists to get vectors by reindexing them over \bN{}
\ExecuteMetaData[Tex/Background]{ListD-VecD}
We bind a new field of \bN{} with \AIC{âˆ†Ïƒ}, extracting it in \AIC{ðŸ™} and \AIC{Ï} to declare that the constructor corresponding to \AIC{\_âˆ·\_} takes a vector of length \AV{n} and returns a vector of length \AIC{suc}\ \AV{n}. 

The conversions from lists to naturals, and from vectors to lists are given by \AF{ornForget}. We define \AF{ornForget} as a \AF{fold} over an algebra that erases a single layer of decorations
\ExecuteMetaData[Tex/Background]{ornForget}
Recursively applying this algebra, which reinterprets values of \AV{E} as values of \AV{D}, lets us take apart a value in the fixpoint \AD{Î¼-ix}\ \AV{E} and rebuild it to a value of \AF{Î¼-ix}\ \AV{D}. This algebra
\ExecuteMetaData[Tex/Background]{ornAlg}
is a special case of the erasing function, which undecorates interpretations of arbitrary types \AV{X}:
\ExecuteMetaData[Tex/Background]{ornErase}
Reading off the ornament, we see which bits of \AV{CE} are new and which are copied from \AV{CD}, and consequently which parts of a term \AV{x} under an interpretation of \AV{CE} need to be forgotten, and which needs to be copied or translated. Specifically, the first three cases of \AF{conOrnErase} correspond to the structure-preserving ornaments, and merely translate equivalent structures from \AV{CE} to \AV{CD}.

For example, in the first case the ornament \AIC{ðŸ™}\ \AV{sq} copies leaves, telling us that \AV{CD} is \AIC{ðŸ™ i'} and \AV{CE} is \AIC{ðŸ™ j'}. The interpretation \AV{âŸ¦ ðŸ™ j' âŸ§C \_ p j} of a leaf \AV{ðŸ™ j'} at parameters \AV{p} and index \AV{j} is simply the equality of expected and actual indices \AV{j â‰¡ (j' p)}. The term \AV{x} of \AV{j â‰¡ (j' p)}, then only has to be converted to the corresponding proof of equality on the \AV{CD} side: \AV{re-index j â‰¡ (i' (varâ†’par re-var p))}. This is precisely accomplished by applying \AF{re-index} to both sides and composing with the square \AV{sq} at \AV{p}.

Likewise, in the case of \AIC{Ï} we only have to show that \AV{x} can be converted from one \AIC{Ï} to the other \AIC{Ï} by translating its parameters, and in the \AIC{Ïƒ} case the field is directly copied. The only other ornament \AIC{Î”Ïƒ} adding fields, is easily undone by removing those fields. 

Thus, \AF{ornForget} establishes that \AV{E} in an ornament \AD{Orn}\ \AV{g}\ \AV{i}\ \AV{D}\ \AV{E} is an adorned version of \AV{D} by associating to each value of \AV{E} its an underlying value in \AV{D}. Additionally, \AF{ornForget} makes it simple to relate functions between related types. For example, instantiating \AF{ornForget} for \AF{NatD-ListD} yields \AF{length}. Hence, the statement that \AF{length} sends concatenation \AF{\_++\_} to addition \AF{\_+\_}, i.e. \AV{length (xs ++ ys) â‰¡ length xs + length ys}, is equivalent to the statement that \AF{\_++\_} and \AF{\_+\_} are related, or that \AF{\_++\_} is a lifting of \AF{\_+\_} \cite{orntrans}. \marker{Ik hoop dat dit minder wazig is en de mental typechecking load wat reduceert.}

% remark, ornForget is not epi in general because of âˆ†Ïƒ âŠ¥

\section{Ornamental Descriptions}\label{sec:background-ornamental-descriptions}
By defining the ornaments \AF{NatD-ListD} and \AF{ListD-VecD} we could show that lists are numbers with fields and vectors are lists with fixed lengths. Even though we had to give \AF{ListD} before we could define \AF{NatD-ListD}, the value of \AF{NatD-ListD} actually forces the right-hand side to be \AF{ListD}.

This means we can also use an ornament to represent a description as a patch on top of another description, if we leave out the right-hand side of the ornament. Ornamental descriptions are precisely defined as ornaments without the right-hand side, and effectively bundle a description and an ornament to it\footnote{Consequently, \AD{OrnDesc}\ \AV{Î”}\ \AV{J}\ \AV{g}\ \AV{i}\ \AV{D} must simply be a convenient representation of \AD{Î£}\ (\AD{U-ix}\ \AV{Î”}\ \AV{J})\ (\AD{Orn}\ \AV{g}\ \AV{i}\ \AV{D}).}. Their definition is analogous to that of ornaments, making the arguments which would only appear in the new description explicit:
\ExecuteMetaData[Tex/Background]{OrnDesc}
\ExecuteMetaData[Tex/Background]{ConOrnDesc}
Using \AD{OrnDesc} we can describe lists as the patch on \AF{NatD} which inserts a \AIC{Ïƒ} in the constructor corresponding to \AIC{suc}:
\ExecuteMetaData[Tex/Background]{NatOD}
To extract \AF{ListD} from \AF{NatOD}, we can use the projection applying the patch in an ornamental description:
\ExecuteMetaData[Tex/Background]{toDesc}
The other projection reconstructs the ornament \AF{NatD-ListD} from \AF{NatOD}:
\ExecuteMetaData[Tex/Background]{toOrn}
As a consequence, \AD{OrnDesc} enjoys the features of both \AD{Desc} and \AD{Orn}, such as interpretation into a datatype by \AF{Î¼} and the conversion to the underlying type by \AF{ornForget}, by factoring through these projections.

In later sections, %mark: precisely?
we will routinely use \AD{OrnDesc} to view triples like (\AF{NatD}, \AF{ListD}, \AF{VecD}) as a base type equipped with two patches in sequence.


% exercise to reader: show OrnDesc AD ~ Exist[ BD in Desc ] Orn AD BD  