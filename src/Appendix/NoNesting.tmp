\begin{code}
{-# OPTIONS --type-in-type #-}

module Appendix.NoNesting where

open import Agda.Primitive
  using    ( Level
           ; SSet )
  renaming ( lzero to â„“-zero
           ; lsuc  to â„“-suc
           ; _âŠ”_   to â„“-max
           ; Set   to Type
           ; SetÏ‰  to TypeÏ‰ )

open import Relation.Binary.PropositionalEquality hiding (J)

open import Data.Unit
open import Data.Empty
open import Data.Product renaming (projâ‚ to fst; projâ‚‚ to snd)
open import Data.Sum
open import Data.Nat


open import Function.Base

private variable
  I J K L : Type
  A B C X Y Z : Type
  P Pâ€² : Type

infixr 5 _âˆ·_
infixr 10 _â–·_

data Tel (P : Type) : Type
âŸ¦_âŸ§tel : (Î“ : Tel P) â†’ P â†’ Type

_âŠ¢_ : (Î“ : Tel P) â†’ Type â†’ Type
Î“ âŠ¢ A = Î£ _ âŸ¦ Î“ âŸ§tel â†’ A

data Tel P where
  âˆ…   : Tel P
  _â–·_ : (Î“ : Tel P) (S : Î“ âŠ¢ Type) â†’ Tel P

âŸ¦ âˆ…     âŸ§tel p = âŠ¤
âŸ¦ Î“ â–· S âŸ§tel p = Î£ (âŸ¦ Î“ âŸ§tel p) (S âˆ˜ (p ,_)) 

ExTel : Tel âŠ¤ â†’ Type
ExTel Î“ = Tel (âŸ¦ Î“ âŸ§tel tt)

private variable
    Î“ Î” Î˜ : Tel P
    U V W : ExTel Î“

_âŠ§_ : (V : Tel P) â†’ V âŠ¢ Type â†’ Type
V âŠ§ S = âˆ€ p â†’ S p

_â–·â€²_ : (Î“ : Tel P) (S : Type) â†’ Tel P
Î“ â–·â€² S = Î“ â–· Î» _ â†’ S

_&_âŠ¢_ : (Î“ : Tel âŠ¤) â†’ ExTel Î“ â†’ Type â†’ Type
Î“ & V âŠ¢ A = V âŠ¢ A

âŸ¦_&_âŸ§tel : (Î“ : Tel âŠ¤) (V : ExTel Î“) â†’ Type
âŸ¦ Î“ & V âŸ§tel = Î£ (âŸ¦ Î“ âŸ§tel tt) âŸ¦ V âŸ§tel

Cxf : (Î“ Î” : Tel âŠ¤) â†’ Type
Cxf Î“ Î” = âŸ¦ Î“ âŸ§tel tt â†’ âŸ¦ Î” âŸ§tel tt

Vxf : (Î“ : Tel âŠ¤) (V W : ExTel Î“) â†’ Type
Vxf Î“ V W = âˆ€ {p} â†’ âŸ¦ V âŸ§tel p â†’ âŸ¦ W âŸ§tel p

Vxf : (f : Cxf Î“ Î”) (V : ExTel Î“) (W : ExTel Î”) â†’ Type
Vxf f V W = âˆ€ {p} â†’ âŸ¦ V âŸ§tel p â†’ âŸ¦ W âŸ§tel (f p)

over : {f : Cxf Î“ Î”} â†’ Vxf f V W â†’ âŸ¦ Î“ & V âŸ§tel â†’ âŸ¦ Î” & W âŸ§tel
over g (p , v) = _ , g v

Vxf-â–· : (f : Vxf Î“ V W) (S : W âŠ¢ Type) â†’ Vxf Î“ (V â–· (S âˆ˜ over f)) (W â–· S)
Vxf-â–· f S (p , v) = f p , v
\end{code}


\begin{code}
data Con-ix (Î“ : Tel âŠ¤) (V : ExTel Î“) (I : Type) : Type
data U-ix (Î“ : Tel âŠ¤) (I : Type) : Type where
  []   : U-ix Î“ I
  _âˆ·_  : Con-ix Î“ âˆ… I â†’ U-ix Î“ I â†’ U-ix Î“ I

data Con-ix Î“ V I where
  ğŸ™   : V âŠ¢ I â†’ Con-ix Î“ V I
  Ï   : V âŠ¢ I â†’ Con-ix Î“ V I â†’ Con-ix Î“ V I
  Ïƒ   : (S : V âŠ¢ Type) â†’ Con-ix Î“ (V â–· S) I â†’ Con-ix Î“ V I
\end{code}


\begin{code}
data U-nest (Î“ : Tel âŠ¤) (J : Type) : Type
data Con-nest (Î“ : Tel âŠ¤) (V : ExTel Î“) (J : Type) : Type 

data U-nest Î“ J where
  []   : U-nest Î“ J
  _âˆ·_  : Con-nest Î“ âˆ… J â†’ U-nest Î“ J â†’ U-nest Î“ J
  
data Con-nest Î“ V J where
  ğŸ™  :  (j : Î“ & V âŠ¢ J) â†’ Con-nest Î“ V J
  
  Ï  :  (j : Î“ & V âŠ¢ J) (g : Cxf Î“ Î“) (C : Con-nest Î“ V J)
     â†’  Con-nest Î“ V J
     
  Ïƒ  :  (S : V âŠ¢ Type) (C : Con-nest Î“ (V â–· S) J)
     â†’  Con-nest Î“ V J
\end{code}


\begin{code}
{-
U-Tree : U-nest Î“ I â†’ Type
Con-Tree : Con-nest Î“ V I â†’ Type â†’ Type 

data Î¼-Tree (C : Con-nest Î“ V I) : Type where
  con : Con-Tree C (Î¼-Tree C) â†’ Î¼-Tree C

U-Tree []      = âŠ¥
U-Tree (C âˆ· D) = Î¼-Tree C âŠ U-Tree D

Con-Tree (ğŸ™ j)     X = âŠ¤
Con-Tree (Ï j g C) X = X âŠ Con-Tree C X
Con-Tree (Ïƒ S C)   X = âŠ¤ âŠ Con-Tree C X

act : (D : U-nest Î“ I) â†’ U-Tree D â†’ Cxf Î“ Î“
actC : (C : Con-nest Î“ V I) â†’ Î¼-Tree C â†’ Cxf Î“ Î“

act (C âˆ· D) (injâ‚ x) p = {!actC C x p!}
act (C âˆ· D) (injâ‚‚ y) p = act D y p

actC (ğŸ™ j) (con tt)    p = p
actC (Ï j g C) (con x) p = {!!}
actC (Ïƒ S C) (con (injâ‚ x)) p = {!!}
actC (Ïƒ S C) (con (injâ‚‚ y)) p = {!!}

regularize : (D : U-nest Î“ I) â†’ (U-Tree D â†’ X) â†’ U-ix Î“ (I Ã— X)
Con-reg : (C : Con-nest Î“ V I) (v : Vxf Î“ W V) â†’ (Î¼-Tree C â†’ X) â†’ Con-ix Î“ W (I Ã— X)

regularize []      F = []
regularize (C âˆ· D) F = Con-reg C id (F âˆ˜ injâ‚) âˆ· regularize D (F âˆ˜ injâ‚‚)

postulate
  fold : (C : Con-nest Î“ V I) (X : Type) â†’ (Con-Tree C X â†’ X) â†’ Î¼-Tree C â†’ X

Con-reg (ğŸ™ j)      v F  = ğŸ™ Î» { (p , w) â†’ j (p , v w) , F (con tt) }
Con-reg (Ï j g C)  v F  = Ïƒ (Î» _ â†’ Î¼-Tree (Ï j g C))
                        ( Ï (Î» { (p , w , x) â†’ j (p , v w) , F (con (injâ‚ x)) })
                        ( Con-reg C (v âˆ˜ fst) Î» x â†’ F (fold C (Î¼-Tree (Ï j g C)) (Î» x â†’ con (injâ‚‚ x)) x)) )
Con-reg (Ïƒ S C)    v F  = Ïƒ (Î» { (p , w) â†’ S (p , {!F!}) })
                        ( Con-reg C (Vxf-â–· v S) Î» x â†’ F (fold C (Î¼-Tree (Ïƒ S C)) (Î» x â†’ con {!!}) x)) -}


U-reg : (D : U-nest Î“ I) â†’ U-ix Î“ (I Ã— Cxf Î“ Î“)
Con-reg : (C : Con-nest Î“ V I) (h : V âŠ¢ Cxf Î“ Î“) â†’ {!!} â†’ Con-ix Î“ W (I Ã— Cxf Î“ Î“)

U-reg []               = []
U-reg {Î“ = Î“} (C âˆ· D)  = Ïƒ (Î» _ â†’ Cxf Î“ Î“) {!!}
                       âˆ· U-reg D

Con-reg {Î“ = Î“} (ğŸ™ j)     h v = {!ğŸ™ Î» { (p , w) â†’ j (h p , v w) , h }!}
Con-reg {Î“ = Î“} (Ï j g C) h v = {!Ï (Î» { (p , w) â†’ j (h p , v w) , h âˆ˜ g }) (Con-reg C h v)!}
Con-reg (Ïƒ S C)           h v = {!Ïƒ (Î» { (p , w) â†’ S (h p , v w) }) (Con-reg C h Î» { (w , s) â†’ v w , s })!}
\end{code}
