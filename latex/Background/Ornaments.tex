By giving datatypes as descriptions, we can inspect and use their structure for generic programming. We can also relate datatypes by structure using ornaments. Ornaments, as a binary relation on \AgdaDatatype{Desc}, encode (informally) the relation of being at least as informative as another type.

We encode the bulk of this relation at the level of constructors, lifting it to \AgdaDatatype{Desc} by taking lists.
\ExecuteMetaData[Tex/Desc.tex]{orn-type}
If \texttt{E} is more informative than \texttt{D}, we must be able to convert the parameters and indices of \texttt{E} to those of \texttt{D}, and also values of \texttt{E} to \texttt{D}. We ask for \texttt{g} and \texttt{i} to witness the former, while the latter forces us to keep the ornaments sufficiently small. This means that we have to be able to implement
\ExecuteMetaData[Tex/Desc.tex]{orn-forget-type}
We will do this by folding over the values using the algebra
\ExecuteMetaData[Tex/Desc.tex]{eraseCon-type}
which executes a single step of \AgdaFunction{ornForget}.

We can encode ``reflexivity'' for leaves into the ornaments
\ExecuteMetaData[Tex/Desc.tex]{pres-1}
stating we can preserve a leaf from \texttt{D} in \texttt{E}; provided the equality, which expresses that the indices in both leaves agree up to \texttt{g} and \texttt{i}, holds. This equality allows us to erase leaves
\ExecuteMetaData[Tex/Desc.tex]{erase-pres-1}
The relation preserving recursive fields and the like
\[ ... \] 
give congruence under their respective formers.

If \texttt{E} has more fields, then we can always go back to \texttt{D} by dropping them, so we also encode relations for adding both kinds of fields
\[ ... \]
Likewise, \texttt{E} can skip a field of \texttt{D} by providing a default value
\[ ... \]

The preconditions in these relations precisely make sure that \AgdaFunction{ornForget} goes right.
\[ ... \]

\todo{Adapt this}
\begin{verbatim}
Now we can show that the descriptions we gave in \autoref{ssec:desc} are related. The ornament between naturals and lists is
\ExecuteMetaData[Ornament/Orn]{NatD-ListD}
We use \AgdaFunction{!} to convert parameters, naturals have no parameters, so we can map every parameter of lists to the empty sequence. The index conversion is \AgdaFunction{id}, since neither type has an index. All structure is preserved; we just have to note that lists have an added field using \AgdaInductiveConstructor{Δσ}, and all commutativity squares are trivial, since naturals have neither parameters nor indices.
\end{verbatim}