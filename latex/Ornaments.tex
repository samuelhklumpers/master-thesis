%outline:
%we explained why descriptions and ornaments are crucial to achieve our goals
%however, the descriptions we explained earlier are not powerful enough to house finger trees


%To capture finger trees as an ornament over a number system, we will need to describe ornaments over nested datatypes. In this section we will work out descriptions and ornaments suitable for nested datatypes.
If we are going to simplify working with complex containers %, such as finger trees,
by instantiating generic programs to them, we should first make sure that these types fit into the descriptions.

We construct descriptions for nested datatypes by extending the encoding of parametric and indexed datatypes from \autoref{ssec:background-ix} with three features: information bundles, parameter transformation, and description composition. Also, to make sharing constructors easier, we introduce variable transformations. Transforming variables before they are passed to child descriptions allows both aggressively hiding variables and introducing values as if by let-constructs.

We base the encoding of off existing encodings \cite{sijsling,practgen}. The descriptions take shape as sums of products, enforce indices at leaf nodes, and have explicit parameter and variable telescopes. Unlike some other encodings \cite{effectfully, practgen}, we do not allow higher-order inductive arguments. 

We use \texttt{--type-in-type} and \texttt{--with-K} to simplify the presentation, noting that these can be eliminated respectively by moving to \AD{Typeœâ} and by implementing interpretations as datatypes, as described in \autoref{app:withoutk}.



\section{The descriptions}\label{ssec:desc}
To describe a numerical representation, we must of course first describe a number. We will focus on number systems as trees (that is, arbitrary unindexed types with no parameters) which evaluate nodes by addition and potentially multiplication by a constant (more about these in \autoref{part:numrep}). To avoid duplication, we will generalize our universe over bundles of information, rather than defining a new type of descriptions of number systems. Given a certain kind of information, a description will additionally provide a piece of that kind of information at each code. %for now we leave them out, we give them under descriptions.

We also need to take care that the resulting numerical representation indeed fits in our universe. The final universe \AD{U-ix} in \autoref{sec:background}, while already quite general, still leaves out many interesting datastructures. In particular, the encoding of parameters forces the recursive type occurrences to have the same applied parameters, ruling out nested datatypes such as (binary) random-access lists \cite{calcdata,purelyfunctional}:
\changed{Redo (or check) the Agda snippets below here.}
\[ code \]
and finger trees \cite{ralf}:
\[ code \]
Moreover, finger trees also reveal another set of quirks in \AD{U-ix}. Because adding non-recursive fields changes the variable telescope, it becomes hard to reuse parts of a description in different places. Apart from that, the number of constructors needed to describe finger trees and similar types also grows quickly when adding fields like \AD{Digit}. To resolve these issues and fit finger trees into the universe, we make three big changes.

First, by allowing parameters to be transformed before passing to recursive fields, we directly include nested types. Second, by allowing variables to be transformed before passing to subsequent fields, we make sharing constructors possible. Finally, by adding a variant of \AIC{œÉ} specialized to descriptions, we can describe composite datatypes more succinctly.

To present the descriptions, we will use telescopes identical to those in \autoref{ssec:bg-desc}.
% we explain by example.
\changed{Somewhat final version above, draft/notes/rough comments/outline below.}
\changed{Note to self: add more citations and then double check them below here}
The descriptions are, again, given in two stages where the outer is analogous
\[ desci \]
The constructor descriptions are then:
\[ coni \]




We use telescopes identical to those in \autoref{ssec:bg-desc}:
\ExecuteMetaData[Ornament/Desc]{telescopes}
Recall that a \AgdaDatatype{Tel} represents a sequence of types, which can depend on the external type $P$. This lets us represent a telescope succeeding another using \AgdaDatatype{ExTel}. A term of the interpretation \AgdaFunction{‚ü¶\_‚üßtel} is then a sequence of terms of all the types in the telescope.

We use some shorthands
\ExecuteMetaData[Ornament/Desc]{tele-shorthands}
\ExecuteMetaData[Ornament/Desc]{shorthands}

As we will see in \autoref{sec:trieo}, some generics require descriptions augmented with more information. For example, a number system needs to describe both a datatype and its interpretation into naturals. This can be incorporated into a description by allowing description formers to query specific pieces of information. We will control where and when which pieces get queried by parametrizing descriptions over information bundles  
\ExecuteMetaData[Ornament/Desc]{Info}
Here a bundle declares for example that \AgdaField{ùüôi} is the type of information has to be provided at a \AgdaInductiveConstructor{ùüô} former. Remark that in \AgdaField{œÉi}, the bundle can ask for something depending on the type of the field. In \AgdaField{Œ¥i}, the bundle can ask something regarding the parameters and indices (e.g., it can force only unindexed subdescriptions.).

\begin{example}
    For example, we can encode a class of number systems using the information 
    \ExecuteMetaData[Ornament/Numerical]{Number}
    (refer to \autoref{sec:trieo}). If we then define the unit type, when viewed as a \AgdaFunction{Number}
    \ExecuteMetaData{Ornament/Numerical}{Unit}
    we have to provide the information that the only value of the unit type evaluates to 1.
\end{example}

We can recover the conventional descriptions by providing the plain bundle:
\ExecuteMetaData[Ornament/Desc]{Plain}
We define the ``down-casting'' of information as
\ExecuteMetaData[Ornament/Desc]{InfoF}
allowing us to reuse more specific descriptions in less specific ones, so that e.g., a number system can be used in a plain datatype.

We can now define the descriptions, which should represent a mapping between parametrized indexed functors
\ExecuteMetaData[Ornament/Desc]{PIType}
Recall that a description 
\ExecuteMetaData[Ornament/Desc]{DescI}
is simply a list of constructor descriptions
\ExecuteMetaData[Ornament/Desc]{Con}
The interpretations \hyperlink{desc-desc-interpretation}{\AgdaFunction{‚ü¶\_‚üß}} of the formers can be found below.

Leaves are formed by
\ExecuteMetaData[Ornament/Desc]{Con-1}
Here \AgdaBoundFontStyle{if} queries information according to \texttt{If}, and \AgdaBoundFontStyle{j} computes the index of the leaf from the parameters and variables.

A recursive field is formed by
\ExecuteMetaData[Ornament/Desc]{Con-rho}
where \AgdaBoundFontStyle{j} now determines the index of the recursive field. The function \AgdaBoundFontStyle{g} represents a parameter transform: the parameters of the recursive field can now changed at each recursive level, allowing us to describe nested datatypes. The remainder of the fields are described by \AgdaBoundFontStyle{C}. Note that a recursive field is intentionally not brought into scope: making use of it requires induction-recursion anyway!

A non-recursive field is formed similarly to a recursive field
\ExecuteMetaData[Ornament/Desc]{Con-sigma}
The type of the field is given by \AgdaBoundFontStyle{S}, which may depend on the values of the preceding fields. We bring the field into scope, so we continue the description in an extended context. However, we allow the remainder of the description to provide a conversion from \texttt{V ‚ñ∑ S} into \texttt{W} to select a new context. This makes it possible to hide fields which are unused in the remainder.

Almost analogously, we make composition of descriptions internal by a variant of \AgdaInductiveConstructor{œÉ}
\ExecuteMetaData[Ornament/Desc]{Con-delta}
This takes a description \texttt{R}, and acts like the \AgdaInductiveConstructor{œÉ} of \texttt{Œº R}, only with more ceremony. This will allow us to form descriptions by composing other descriptions, avoiding multiplying the number of constructors of composite datatypes.

Similar to \AgdaInductiveConstructor{œÅ}, the functions \AgdaBoundFontStyle{j} and \AgdaBoundFontStyle{g} control indices and parameters, only now of the applied description. As we allow the description \AgdaBoundFontStyle{R} of the field to have a different kind of information bundle \AgdaBoundFontStyle{If‚Ä≤}, we must ask that we can down-cast it into \AgdaBoundFontStyle{If} via \AgdaBoundFontStyle{iff}. 

Descriptions and constructor descriptions can then be interpreted to appropriate kind of functor, constructor descriptions also taking variables
\hypertarget{desc-desc-interpretation}{}
\ExecuteMetaData[Ornament/Desc]{interpretation}
We see that a leaf becomes a constraint between expected index and the actual index. A recursive field passes down a transformation of the current parameters and the expected index computed from the variables, before interpreting the remainder of the description. Likewise, a non-recursive field adds a field with type depending on variables, but also adds this field to the variables, which are then transformed and passed on to the remainder. The composite field is analogous, only adding a field from a description rather than a type. Finally, the list of constructor descriptions are interpreted as alternatives.

The fixpoint can then be taken over the interpretation of a description
\ExecuteMetaData[Ornament/Desc]{fpoint}
giving the datatype represented by the description.

We can then give a generic fold for the represented datatypes
\ExecuteMetaData[Ornament/Desc]{fold}
which descends the description, mapping itself over all recursive fields before applying the folding function.
\begin{remark}
    The situation of \AgdaFunction{fold} is very common when dealing with different kinds of recursive interpretations: functions from the fixpoint are generally defined from functions out of the interpretation, generalizing over the inner description while pattern matching on the outer description. 
\end{remark}
Note that the fold requires a rather general function, limiting its usefulness: because of the parameter transformations, we cannot instantiate the fold to a single parameter. Defining, e.g., the vector sum, would require us to inspect the description, and ask that a vector of naturals can be converted into a vector of naturals, which is trivial in this case.

\todo{Sigma plus/minus}

Let's look at some examples. We can encode the naturals as a type parametrized by \AgdaInductiveConstructor{‚àÖ} and indexed by \AgdaDatatype{‚ä§}
\ExecuteMetaData[Ornament/Desc]{NatD}
Lists can be encoded similarly, but this time using the telescope
\ExecuteMetaData[Ornament/Desc]{ListTel}
declaring that lists have a single type parameter. Compared to the naturals, the description now also asks for a field in the second case
\ExecuteMetaData[Ornament/Desc]{ListD}
Since the type parameter is at the top of the parameter telescope, the type of the field is given as \AgdaBoundFontStyle{par top}.

Vectors are described using the same structure, but have indices in \bN{}.
\ExecuteMetaData[Ornament/Desc]{VecD}
In the first case, the index is fixed at 0. The second case declares that to construct a vector of length \AgdaBoundFontStyle{suc ‚àò top}, the recursive field must have length \AgdaFunction{top}. Note that unlike index-first types, we cannot know the expected index from inside the description, so much like native indexed types, we must add a field choosing an index.

Recall the type of finger trees. Using parameter transformations and composition, we can give a description of full-fledges finger trees! First, we describe the digits
\ExecuteMetaData[Ornament/Desc]{DigitD}
and define the nodes\footnote{We could give the nodes as a description, but in this case we only use them in the recursive fields, so we would take the fixpoint without looking at their description anyway.}
\ExecuteMetaData[Ornament/Desc]{Node}
We encode finger trees as
\ExecuteMetaData[Ornament/Desc]{FingerD}
In the third case, we have digits which are passed the parameters on both sides in composite fields, and a recursive field in the middle. The recursive field has a parameter transformation, turning the type parameter \AgdaBoundFontStyle{A} into a \AgdaBoundFontStyle{Node A} in the recursive child.



\section{The ornaments}
\begin{outline}    
we could ditch removal of fields: we don't use it. downside: ornament over ornament is the same as field removal for deltas

:warning: match everything, add/remove field, add/remove recursive field, add/remove description field, ornament over ornament
\end{outline}
    

\towrite{Put something that isn't yet in \autoref{ssec:bg-orn} here.}

\ExecuteMetaData[Ornament/Orn]{Orn-type}
\ExecuteMetaData[Ornament/Orn]{ornForget-type}

We will walk through the constructor ornaments
\ExecuteMetaData[Ornament/Orn]{ConOrn-type}
again, an ornament between datatypes is just a list of ornaments between their constructors
\ExecuteMetaData[Ornament/Orn]{Orn}
Note that all ornaments completely ignore information bundles! They cannot affect the existence of \AgdaFunction{ornForget} after all.

Copying parts from one description to another, up to parameter and index refinement, corresponds to reflexivity. Preservation of leaves follows the rule
\ExecuteMetaData[Ornament/Orn]{Orn-1}
We can see that this commuting square (\texttt{e (k p) ‚â° j (over f p)}) is necessary: take a value of \texttt{E} at \texttt{p, i}, where \texttt{i} is given as \texttt{k p}. Then \AgdaFunction{ornForget} has to convert this to a value of \texttt{D} at \texttt{f p , e i}, but since \texttt{e i} must match \texttt{j (f p)}, this is only possible if \texttt{e (k p) = j (f p)}.

Preserving a recursive field similarly requires a square of indices and conversions to commute
\ExecuteMetaData[Ornament/Orn]{Orn-rho}
additionally requiring the recursive parameters to commute with the conversion. \todo{Does adding the derivations for the squares everywhere make this section clearler?}

Preservation of non-recursive fields and description fields is analogous
\ExecuteMetaData[Ornament/Orn]{Orn-sigma-delta}
differing only in that non-recursive fields appears transformed on the right hand, while description fields have their conversions modified instead. For this rule, we need that the variable transformations fit into a commuting square with the parameter conversions. The condition on indices for descriptions, which is a commuting triangle, is encoded in the return type\footnote{Should this become a problem like with \AgdaInductiveConstructor{œÅ}, modifying the rule to require a triangle is trivial.}.

Ornaments would not be very interesting if they only related identical structures. The left-hand side can also have more fields than the right-hand side, in which case \AgdaFunction{ornForget} will simply drop the fields which have no counterpart on the right-hand side. As a consequence, the description extending rules have fewer conditions than the description preserving rules: 
\ExecuteMetaData[Ornament/Orn]{Orn-+-rho}
Note that this extension\footnote{Kind of breaking the ``ornaments relate types with similar recursive structure'' interpretation.} with a recursive field has no conditions.

Extending by a non-recursive field or a description field again only requires the variable transform to interact well with the parameter conversion
\ExecuteMetaData[Ornament/Orn]{Orn-+-sigma-delta}

In the other direction, the left-hand side can also omit a field which appears on the right-hand side, provided we can produce a default value
\ExecuteMetaData[Ornament/Orn]{Orn---sigma-delta}
These rules let us describe the basic set of ornaments between datatypes.

Intuitively we also expect a conversion to exist when two constructors have description fields which are not equal, but are only related by an ornament. Such a composition of ornaments takes two ornaments, one between the field, and one between the outer descriptions. This composition rule reads:\todo{The implicits kind of get out of control here, but the rule is also unreadable without them. I might hide the rule altogether and only run an example with it.}
\ExecuteMetaData[Ornament/Orn]{Orn-comp}
We first require two commuting squares, one relating the parameters of the fields to the inner and outer parameter conversions, and one relating the indices of the fields to the inner index conversion and the outer parameter conversion. Then, the last square has a rather complicated equation, which merely states that the variable transforms for the remainder respect the outer parameter conversion.

We will construct \AgdaFunction{ornForget} as a \AgdaFunction{fold}. Using
\ExecuteMetaData[Ornament/Orn]{erase-type}
we can define the algebra which forgets the added structure of the outer layer
\ExecuteMetaData[Ornament/Orn]{ornAlg}
Folding over this algebra gives the wanted function
\ExecuteMetaData[Ornament/Orn]{ornForget}

\todo{NatD was removed here}

We can also relate lists and vectors
\ExecuteMetaData[Ornament/Orn]{ListD-VecD}
Now the parameter conversion is the identity, since both have a single type parameter. The index conversion is \AgdaFunction{!}, since lists have no indices. Again, most structure is preserved, we only note that vectors have an added field carrying the length.

Instantiating \AgdaFunction{ornForget} to these ornaments, we now get the functions \AgdaFunction{length} and \AgdaFunction{toList} for free!

%\investigate{Having a function of the same type as \AgdaFunction{ornForget} is not sufficient to deduce an ornament. An obstacle is that the usual empty type (no constructors) and the non-wellfounded empty type (only a recursive field) don't have an ornament. Also, while the leaf-preservation case spells itself out, the substitutions obviously don't give us a way to recover the equalities.}


\section{Ornamental descriptions}
A description can say ``this is how you make this datatype'', an ornament can say ``this is how you go between these types''. However, an ornament needs its left-hand side to be predefined before it can express the relation, while we might also interpret an ornament as a set of instructions to translate one description into another. A slight variation on ornaments can make this kind of usage possible: ornamental descriptions.

An ornamental description drops the left-hand side when compared to an ornament, and interprets the remaining right-hand side as the starting point of the new datatype:
\ExecuteMetaData[Ornament/OrnDesc]{ConOrnDesc-type}
The definition of ornamental descriptions can be derived in a straightforward manner from ornaments, removing all mentions of the LHS and making all fields which then no longer appear in the indices explicit\footnote{One might expect to need less equalities, alas, this is difficult because of \autoref{rem:orn-lift}.}. We will show the leaf-preserving rule as an example, the others are derived analogously:
\ExecuteMetaData[Ornament/OrnDesc]{OrnDesc-1}
As we can see, the only change we need to make is that \AgdaBoundFontStyle{k} becomes explicit and fully annotated.

Almost by construction, we have that an ornamental description can be decomposed into a description of the new datatype
\ExecuteMetaData[Ornament/OrnDesc]{toDesc}
and an ornament between the starting description and this new description
\ExecuteMetaData[Ornament/OrnDesc]{toOrn}
