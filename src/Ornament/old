
{- -- older, direct attempt at indexed tries
TrieO-1  : (D : DescI If ∅ ⊤) → InfoF If Number → OrnDesc Plain (∅ ▷ const Type) ! (μ D tt _) ! D

module _ {D' : DescI If ∅ ⊤} where
  TrieO  : (D : DescI If ∅ ⊤) → InfoF If Number → (⟦ D ⟧ (μ D') tt _ → μ D' tt _) → OrnDesc Plain (∅ ▷ const Type) ! (μ D' tt _) ! D
  TrieOC : ∀ {V} {W : ExTel (∅ ▷ const Type)} {f : VxfO ! W V} (C : ConI If ∅ ⊤ V) → InfoF If Number → (∀ {p} w → ⟦ C ⟧ (μ D') (tt , f {p = p} w) _ → μ D' tt _) → ConOrnDesc Plain {W = W} {K = μ D' tt _} f ! C
  TrieO-forget : ∀ {If′} {iff : InfoF If′ If} (R : DescI If′ ∅ ⊤) {p' : Σ ⊤ (λ x → Type)} (ϕ : InfoF If Number) (q : μ R tt tt) {if : ℕ} s →
                 q ≡ ornForget (toOrn (TrieO-1 R (ϕ ∘InfoF iff))) (tt , Vec (proj₂ p') if) {i = q} s
 
  TrieO []      f ix = []
  TrieO (C ∷ D) f ix = TrieOC C f (λ v x → ix (inj₁ x)) ∷ TrieO D f (ix ∘ inj₂)

  TrieOC {f = f} (𝟙 {if = if} j) ϕ ix =                               -- if the number is constantly if here
    Δσ (λ { ((_ , A) , _) → Vec A (ϕ .𝟙f if)}) f proj₁                      -- add if A's here
    (𝟙 (λ { ((_ , A) , w) → ix w refl })                            -- the index is completely determined by the context
    (const refl)) λ p → refl  
    
  TrieOC {f = f} (ρ {if = if} j g C) ϕ ix =                           -- if the number is recursively if * r + n here
    Δσ (const (μ D' tt tt)) (f ∘ proj₁) id                          -- for an index r
    (ρ (proj₂ ∘ proj₂) (λ { (_ , A) → _ , Vec A (ϕ .ρf if) })               -- keep the recursive field at r with parameter A^k
    (TrieOC C ϕ λ { (w , r) n → ix w (r , n) } )                      -- and compute the rest of the OD, the index is constructed from r and the context
    (λ p → refl) λ p → refl) λ p → refl
    
  TrieOC {f = f} (σ S {if = if} h C) ϕ ix =
    σ S id (h ∘ VxfO-▷ f S)
    (Δσ (λ { ((_ , A) , _ , s) → Vec A (ϕ .σf _ if _ s) }) (h ∘ _) id
    (TrieOC C ϕ λ { ((w , s) , x) n → ix w (s , n) })
    λ p → refl) (λ p → refl)

  TrieOC {f = f} (δ {if = if} {iff = iff} j g R h C) ϕ ix with ϕ .δf _ _ if
  ... | refl , refl , if =
    Δσ (const (μ R tt tt)) (f ∘ proj₁) id
    (Δσ (const (μ D' tt tt)) (f ∘ proj₁ ∘ proj₁) id
    (∙δ (λ { ((_ , A) , ((w , r) , n)) → _ , Vec A if }) (proj₂ ∘ proj₁ ∘ proj₂)
    (TrieOC C ϕ λ { (w , r) x → ix w (r , x) })
    (TrieO-1 R (ϕ ∘InfoF iff)) (proj₁ ∘ proj₁) (λ _ _ → refl) (λ _ _ → refl) λ { {p'} (((p , q) , r) , s) → cong (λ q → h (f p , q)) (TrieO-forget R ϕ q s) })
    λ p → refl) λ p → refl

  TrieO-forget R ϕ (con q) (con s) = {!!}

TrieO-1 D f = TrieO {D' = D} D f con
-}

