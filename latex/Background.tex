\section{Agda}
We formalize our work in Agda \cite{agda}, a functional programming language with dependent types. Using dependent types we can use Agda as a proof assistant, allowing us to state and prove theorems about our datastructures and programs. These proofs can then be run as algorithms, or in some cases be extracted to other languages like Haskell\footnote{Or JavaScript, if you want.}.

Syntactically Agda is reminiscent of Haskell. One difference is that Agda allows most characters and words in identifiers with only a small set of exceptions. For example, we can write
\ExecuteMetaData[Tex/Background]{ternary}
Another is that datatypes are always either given as generalized algebraic datatypes (GADTs) or record types. For example, the definition of booleans
\begin{verbatim}
    data Bool = True | False
\end{verbatim}
can be written in Agda as
\ExecuteMetaData[Tex/Background]{bool}
The unit type
\begin{verbatim}
    data Unit = Unit
\end{verbatim}
becomes\footnote{One can also write the unit type as a datatype with one constructor. However, in Agda, records (can) benefit from eta-expansion. In our case, all terms of \AgdaDatatype{⊤} are definitionally equal.}
\ExecuteMetaData[Tex/Background]{true}

The type system of Agda is an extension of (intensional) Martin-Löf type theory (MLTT), a constructive type theory in which we can interpret intuitionistic logic: the Curry-Howard isomorphism states that certain formulas correspond to certain types, and proofs of a formula correspond to terms of the corresponding type. The atomic formula true can be represented by \AgdaDatatype{⊤}, so that \AgdaFunction{tt} always proves true. False can be represented by a datatype with no constructors
\ExecuteMetaData[Tex/Background]{false}
since there is (hopefully) no way to make get a term of \AgdaDatatype{⊥} without inconsistent assumptions. The logical implication $A \implies B$ corresponds to the type of functions $A \to B$: a proof of $A$ can be converted to a proof of $B$. Using implication, we can define the negation $\lnot A$ of a formula $A$ as the type $A \to \bot$. Disjunction (logical or) is described by a sum type $A + B$:
\ExecuteMetaData[Tex/Background]{either}
if we have either $A$ or $B$, we can prove $A + B$. Conjunction (logical and) is given as a product type:
\ExecuteMetaData[Tex/Background]{pair}
we need both $A$ and $B$ to prove $A \times B$. Using the correspondence, we can reason in propositional logic by writing functional programs. As an example, consider the proof of the tautology 
\ExecuteMetaData[Tex/Background]{distr}

Compared to Haskell, Agda allows the type of the codomain of a function to vary with the applied value:
given a function $P$ from $A$ into \AgdaPrimitiveType{Type}, a type family over $A$, we can form the dependent function type $(a : A) \to P\ a$. Applying a function $f: (a : A) \to P\ a$ to a value $a : A$ then will have type $f\ a : P\ a$. Similarly, the type of a field in a record type can depend on values of earlier fields, e.g.,
\ExecuteMetaData[Tex/Background]{exists}
The presence of these dependent types enriches the interpretation of logic into programs. To interpret first-order logic we need to describe formulas containing variables, which are called predicates. Predicates correspond to functions%into \AgdaDatatype{Type}
\ExecuteMetaData[Tex/Background]{predicate}
Using predicates, we can interpret quantifiers as the dependent types above. Universal quantification (for all) is a dependent function type 
\ExecuteMetaData[Tex/Background]{forall}
since for each $a : A$, we have a proof of $P\ a$. Likewise, existential quantification (exists) is the dependent pair type $\exists$, since this gives an $a : A$ and a proof $P\ a$. 

Whereas the parameters of a type are fixed beforehand, an index can be fixed during construction. We can define the finite types as
\ExecuteMetaData[Tex/Background]{fin}
In each constructor, we pick an $n$ and set the index to $n+1$, ensuring that \texttt{Fin (suc n)} always has one element more than \texttt{Fin n}, and \texttt{Fin 0} has zero.

Predicates can also be expressed using indexed datatypes. E.g., equality of elements of a type $A$ can then be interpreted as the type
\ExecuteMetaData[Tex/Background]{eq}
Closed terms of this type can only be constructed for definitionally equal elements, but crucially, variables of this type can contain equalities between different elements. As the second argument is an index, pattern matching on \AgdaFunction{refl} unifies the elements, such that properties like substitution follow
\ExecuteMetaData[Tex/Background]{subst}

Unlike most languages, Agda rules out non-terminating functions by restricting their definitions to structural recursion. The termination checker (together with other restrictions which we will encounter in due time) prevents trivial proofs which would be tolerated in Haskell, like
\ExecuteMetaData[Tex/Background]{loop}
This ensures that all our interpretations mentioned above remain consistent.

\begin{comment}
With this, we can do maths. For example, we could define natural numbers as an inductive type
\[ \dots \]
and prove some properties of prime numbers. But to get the same results to binary numbers (without duplicating the proofs), we need a bit more. The usual notion of equalities of types are isomorphisms: two types $A, B$ are isomorphic if there are functions $A \to B$ and $B \to A$, which are mutually inverse 
\[ \dots \]
In ordinary Agda, we cannot directly apply these to transport along like we can for equalities, however.
\end{comment}


\section{Generic programming}\label{ssec:bg-desc}
%outline:
%we expound on generic programming
%we use this later to automate the construction of datastructures and proofs

%The deriving-mechanism in Haskell can take writing functions which consist primarily of boilerplate out of the hands of the programmer by deriving default implementations. Using reflection we can write similar macros and generic programs inside the type-checking monad; with it one can quote types or values, inspect their definitions, and unquote terms them to inject them into the code as if they were written manually.
%However, programming in this monad is generally not pleasant, as terms enjoy none of the safety we are used to from Agda, and type errors are only detected when applying macros as opposed to when writing them. That is not to say that effective generic programming is impossible in Agda, and quite the opposite is true \cite{practgen}\todo{And more}. We will take a closer look at constructions which we can use for datatype generic programming. 
\subsection{Descriptions}
\input{Background/Desc.tex}

\subsection{Ornaments}
\input{Background/Ornaments.tex}


\section{Cubical Agda}
%outline:
%all our isomorphisms are nice, but not very powerful without a simple way to apply them
%our ideas generally work without axiom K, provided we take some precautions

Intuitively, one expects that like how isomorphic groups share the same group-theoretical properties, isomorphic types also share the same type-theoretical properties. Meta-theoretically, this is known as \emph{representation independence}, and is evident. Inside (ordinary) Agda this is not so practical, as this independence only holds when applied to concrete types, and is then only realized by manually substituting along the isomorphism. On the other hand, in Cubical Agda, the Structure Identity Principle internalizes a kind of representation independence \cite{iri}.

Cubical Agda modifies the type theory of Agda to a kind of homotopy type theory, looking at equalities as paths between terms rather than the equivalence relation generated by reflexivity. In cubical type theories, the role played by pattern matching on \AgdaFunction{refl} or by axiom J, in MLTT and ``Book HoTT'' respectively, is instead acted out by directly manipulating cubes\footnote{Under the analogy where a term is a point, an equality between points is a line, a line between lines is a square.}. %In Cubical Agda, univalence
%\[ ... \]
%is not an axiom but a theorem.

To give an understanding of the basics of Cubical Agda \cite{cuagda} and the Structure Identity Principle (SIP), we walk through the steps to transport proofs about addition on Peano naturals to Leibniz naturals. %We give an overview of some features of Cubical Agda, such as that paths give the primitive notion of equality, until the simplified statement of univalence.
%We do note that Cubical Agda has two downsides relating to termination checking and universe levels, which we encounter in later sections.

\subsection{Paths}
In Cubical Agda, the primitive notion of equality arises not (directly) from the indexed inductive definition we are used to, but rather from the presence of the interval type \AgdaPrimitiveType{I}. This type represents a set of two points \AgdaInductiveConstructor{i0} and \AgdaInductiveConstructor{i1}, which are considered ``identified'' in the sense that they are connected by a path. To define a function out of this type, we also have to define the function on all the intermediate points, which is why we call such a function a ``path''. Terms of other types are then considered identified when there is a path between them.

Paths between types are incredibly useful, as they effectively let us directly transport properties between isomorphic structures. However, they do not come without downsides, such as that the negation of axiom K complicates both some termination checking and some universe levels.\footnote{In particular, this prompts rather far-reaching (but not fundamental) changes to the code of previous work, such as to the machinery of ornaments \cite{progorn} in \autoref{sec:userfriendly}.} %Furthermore, if we use certain homotopical constructions, and we wish to eliminate from our types as if they were sets, then we will also have to prove that they are indeed sets.

We will discuss how to deal with these issues in later sections, so let us not be distracted from what we \emph{can} do with paths. For example, the different perspective gives intuitive interpretations to some proofs of equality, like
\ExecuteMetaData[Tex/CubicalAndBinary]{sym}
where \AgdaFunction{∼\_} is the interval reversal, swapping \AgdaInductiveConstructor{i0} and \AgdaInductiveConstructor{i1}, so that \AgdaFunction{sym} simply reverses the given path.

Also, because we can now interpret paths in record and function types in a new way, we get a host of ``extensionality'' for free. For example, a path in $A \to B$ is indeed a function which takes each $i$ in \AgdaPrimitiveType{I} to a function $A \to B$. Using this, function extensionality becomes tautological 
\ExecuteMetaData[Tex/CubicalAndBinary]{funExt}


\subsection{Univalence}
Finally, equivalences, the HoTT-compatible variant of bijections, have the univalence theorem 
\ExecuteMetaData[Tex/CubicalAndBinary]{ua}
stating that ``equivalent types are identified'', such that equivalences like $1 \to A \simeq A$ become paths $1 \to A \equiv A$, making it so that we can transport proofs along them. We will demonstrate this by a more practical example in the next section.

%\towrite{Why circles are points with K. Why circles are not points with univalence}

\subsection{The Structure Identity Principle}\label{ssec:leibniz}
%Starting by defining the unary Peano naturals and the binary Leibniz naturals, we prove that they are isomorphic by interpreting them into each other. We observe how the interpretations are mutual inverses by proving lemmas stating that both interpretations ``respect the constructors'' of the types. Next, we demonstrate how this isomorphism can be promoted into an equivalence or an equality, and remark that this is sufficient to transport intrinsic properties, such as having decidable equality, from one natural to the other.

%Noting that transporting unary addition to binary addition is possible but not efficient, we define binary addition while ensuring that it corresponds to unary addition. We present a variant on refinement types as a syntax to recover definition from chains of equality reasoning, allowing one to rewrite definitions while preserving equalities.

%We clarify that to transport proofs referring to addition from unary to binary naturals, we indeed require that these are meaningfully related. Then, we observe that in this instance, the pairs of ``type and operation'' are actually equated as magmas, and explain that this is an instance of the SIP.

%Finally, we describe the use case of the SIP, how it generalizes our observation about magmas, and how it can calculate the minimal requirements to equate to implementations of an interface. This is demonstrated by transporting associativity from unary addition to binary addition, noting that this would save many lines of code provided there is much to be transported.

\input{CubicalAndBinary}

