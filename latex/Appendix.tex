
\begin{outline}
    :warning: The other way of parameters-indices
\end{outline}

\appendix

\section{Without K but with universe hierarchies}\label{app:withoutk}
See \cite{practgen} and the small blurb rewriting interpretations as datatypes.

\section{Big sigma}\label{app:large-sigma}

\section{gfold}\label{app:gfold}
\todo{maybe explain why this does not give you foldr or sum for lists}

\section{ornForget}\label{app:ornforget}

\section{Finger trees}
%\input{Fingertrees}

\section{Heterogenization}
%\input{Heterogenization.tex}


\section{More equivalences for less effort}\label{sec:userfriendly}
Noting that constructing equivalences directly or from isomorphisms as in \autoref{ssec:leibniz} can quickly become challenging when one of the sides is complicated, we work out a different approach making use of the initial semantics of W-types instead. We claim that the functions in the isomorphism of \autoref{ssec:leibniz} were partially forced, but this fact was unused there.

First, we explain that if we assume that one of the two sides of the equivalence is a fixpoint or initial algebra of a polynomial functor (that is, the \AgdaDatatype{μ} of a \AgdaDatatype{Desc′}), this simplifies giving an equivalence to showing that the other side is also initial.

We describe how we altered the original ornaments \cite{progorn} to ensure that \AgdaDatatype{μ} remains initial for its base functor in Cubical Agda, explaining why this fails otherwise, and how defining base functors as datatypes avoids this issue.

In a subsection focussing on the categorical point of view, we show how we can describe initial algebras (and truncate the appropriate parts) in such a way that the construction both applies to general types (rather than only sets), and still produces an equivalence at the end. We explain how this definition, like the usual definition, makes sure that a pair of initial objects always induces a pair of conversion functions, which automatically become inverses. Finally, we explain that we can escape our earlier truncation by appealing to the fact that ``being an equivalence'' is a proposition.

Next, we describe some theory, using which other types can be shown to be initial for a given algebra. This is compared to the construction in \autoref{ssec:leibniz}, observing that intuitively, initiality follows because the interpretation of the zero constructor is forced by the square defining algebra maps, and the other values are forced by repeatedly applying similar squares. This is clarified as an instance of recursion over a polynomial functor.

To characterize when this recursion is allowed, we define accessibility with respect to polynomial functors as a mutually recursive datatype as follows. This datatype is constructed using the fibers of the algebra map, defining accessibility of elements of these fibers by cases over the description of the algebra. Then we remark that this construction is an atypical instance of well-founded recursion, and define a type as well-founded for an algebra when all its elements are accessible.

We interpret well-foundedness as an upper bound on the size of a type, leading us to claim that injectivity of the algebra map gives a lower bound, which is sufficient to induce the isomorphism. We sketch the proof of the theorem, relating part of this construction to similar concepts in the formalization of well-founded recursion in the Standard Library. In particular, we prove an irrelevance and an unfolding lemma, which lets us show that the map into any other algebra induced by recursion is indeed an algebra map. By showing that it is also unique, we conclude initiality, and get the isomorphism as a corollary. 

The theorem is applied and demonstrated to the example of binary naturals. We remark that the construction of well-foundedness looks similar to view-patterns. After this, we conclude that this example takes more lines that the direct derivation in \autoref{ssec:leibniz}, but we argue that most of this code can likely be automated.

\towrite{Merge}

%\input{UserFriendly}