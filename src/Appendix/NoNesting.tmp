\begin{code}
{-# OPTIONS --type-in-type #-}

module Appendix.NoNesting where

open import Agda.Primitive
  using    ( Level
           ; SSet )
  renaming ( lzero to ℓ-zero
           ; lsuc  to ℓ-suc
           ; _⊔_   to ℓ-max
           ; Set   to Type
           ; Setω  to Typeω )

open import Relation.Binary.PropositionalEquality hiding (J)

open import Data.Unit
open import Data.Empty
open import Data.Product renaming (proj₁ to fst; proj₂ to snd)
open import Data.Sum
open import Data.Nat


open import Function.Base

private variable
  I J K L : Type
  A B C X Y Z : Type
  P P′ : Type

infixr 5 _∷_
infixr 10 _▷_

data Tel (P : Type) : Type
⟦_⟧tel : (Γ : Tel P) → P → Type

_⊢_ : (Γ : Tel P) → Type → Type
Γ ⊢ A = Σ _ ⟦ Γ ⟧tel → A

data Tel P where
  ∅   : Tel P
  _▷_ : (Γ : Tel P) (S : Γ ⊢ Type) → Tel P

⟦ ∅     ⟧tel p = ⊤
⟦ Γ ▷ S ⟧tel p = Σ (⟦ Γ ⟧tel p) (S ∘ (p ,_)) 

ExTel : Tel ⊤ → Type
ExTel Γ = Tel (⟦ Γ ⟧tel tt)

private variable
    Γ Δ Θ : Tel P
    U V W : ExTel Γ

_⊧_ : (V : Tel P) → V ⊢ Type → Type
V ⊧ S = ∀ p → S p

_▷′_ : (Γ : Tel P) (S : Type) → Tel P
Γ ▷′ S = Γ ▷ λ _ → S

_&_⊢_ : (Γ : Tel ⊤) → ExTel Γ → Type → Type
Γ & V ⊢ A = V ⊢ A

⟦_&_⟧tel : (Γ : Tel ⊤) (V : ExTel Γ) → Type
⟦ Γ & V ⟧tel = Σ (⟦ Γ ⟧tel tt) ⟦ V ⟧tel

Cxf : (Γ Δ : Tel ⊤) → Type
Cxf Γ Δ = ⟦ Γ ⟧tel tt → ⟦ Δ ⟧tel tt

Vxf : (Γ : Tel ⊤) (V W : ExTel Γ) → Type
Vxf Γ V W = ∀ {p} → ⟦ V ⟧tel p → ⟦ W ⟧tel p

Vxf : (f : Cxf Γ Δ) (V : ExTel Γ) (W : ExTel Δ) → Type
Vxf f V W = ∀ {p} → ⟦ V ⟧tel p → ⟦ W ⟧tel (f p)

over : {f : Cxf Γ Δ} → Vxf f V W → ⟦ Γ & V ⟧tel → ⟦ Δ & W ⟧tel
over g (p , v) = _ , g v

Vxf-▷ : (f : Vxf Γ V W) (S : W ⊢ Type) → Vxf Γ (V ▷ (S ∘ over f)) (W ▷ S)
Vxf-▷ f S (p , v) = f p , v
\end{code}


\begin{code}
data Con-ix (Γ : Tel ⊤) (V : ExTel Γ) (I : Type) : Type
data U-ix (Γ : Tel ⊤) (I : Type) : Type where
  []   : U-ix Γ I
  _∷_  : Con-ix Γ ∅ I → U-ix Γ I → U-ix Γ I

data Con-ix Γ V I where
  𝟙   : V ⊢ I → Con-ix Γ V I
  ρ   : V ⊢ I → Con-ix Γ V I → Con-ix Γ V I
  σ   : (S : V ⊢ Type) → Con-ix Γ (V ▷ S) I → Con-ix Γ V I
\end{code}


\begin{code}
data U-nest (Γ : Tel ⊤) (J : Type) : Type
data Con-nest (Γ : Tel ⊤) (V : ExTel Γ) (J : Type) : Type 

data U-nest Γ J where
  []   : U-nest Γ J
  _∷_  : Con-nest Γ ∅ J → U-nest Γ J → U-nest Γ J
  
data Con-nest Γ V J where
  𝟙  :  (j : Γ & V ⊢ J) → Con-nest Γ V J
  
  ρ  :  (j : Γ & V ⊢ J) (g : Cxf Γ Γ) (C : Con-nest Γ V J)
     →  Con-nest Γ V J
     
  σ  :  (S : V ⊢ Type) (C : Con-nest Γ (V ▷ S) J)
     →  Con-nest Γ V J
\end{code}


\begin{code}
{-
U-Tree : U-nest Γ I → Type
Con-Tree : Con-nest Γ V I → Type → Type 

data μ-Tree (C : Con-nest Γ V I) : Type where
  con : Con-Tree C (μ-Tree C) → μ-Tree C

U-Tree []      = ⊥
U-Tree (C ∷ D) = μ-Tree C ⊎ U-Tree D

Con-Tree (𝟙 j)     X = ⊤
Con-Tree (ρ j g C) X = X ⊎ Con-Tree C X
Con-Tree (σ S C)   X = ⊤ ⊎ Con-Tree C X

act : (D : U-nest Γ I) → U-Tree D → Cxf Γ Γ
actC : (C : Con-nest Γ V I) → μ-Tree C → Cxf Γ Γ

act (C ∷ D) (inj₁ x) p = {!actC C x p!}
act (C ∷ D) (inj₂ y) p = act D y p

actC (𝟙 j) (con tt)    p = p
actC (ρ j g C) (con x) p = {!!}
actC (σ S C) (con (inj₁ x)) p = {!!}
actC (σ S C) (con (inj₂ y)) p = {!!}

regularize : (D : U-nest Γ I) → (U-Tree D → X) → U-ix Γ (I × X)
Con-reg : (C : Con-nest Γ V I) (v : Vxf Γ W V) → (μ-Tree C → X) → Con-ix Γ W (I × X)

regularize []      F = []
regularize (C ∷ D) F = Con-reg C id (F ∘ inj₁) ∷ regularize D (F ∘ inj₂)

postulate
  fold : (C : Con-nest Γ V I) (X : Type) → (Con-Tree C X → X) → μ-Tree C → X

Con-reg (𝟙 j)      v F  = 𝟙 λ { (p , w) → j (p , v w) , F (con tt) }
Con-reg (ρ j g C)  v F  = σ (λ _ → μ-Tree (ρ j g C))
                        ( ρ (λ { (p , w , x) → j (p , v w) , F (con (inj₁ x)) })
                        ( Con-reg C (v ∘ fst) λ x → F (fold C (μ-Tree (ρ j g C)) (λ x → con (inj₂ x)) x)) )
Con-reg (σ S C)    v F  = σ (λ { (p , w) → S (p , {!F!}) })
                        ( Con-reg C (Vxf-▷ v S) λ x → F (fold C (μ-Tree (σ S C)) (λ x → con {!!}) x)) -}


U-reg : (D : U-nest Γ I) → U-ix Γ (I × Cxf Γ Γ)
Con-reg : (C : Con-nest Γ V I) (h : V ⊢ Cxf Γ Γ) → {!!} → Con-ix Γ W (I × Cxf Γ Γ)

U-reg []               = []
U-reg {Γ = Γ} (C ∷ D)  = σ (λ _ → Cxf Γ Γ) {!!}
                       ∷ U-reg D

Con-reg {Γ = Γ} (𝟙 j)     h v = {!𝟙 λ { (p , w) → j (h p , v w) , h }!}
Con-reg {Γ = Γ} (ρ j g C) h v = {!ρ (λ { (p , w) → j (h p , v w) , h ∘ g }) (Con-reg C h v)!}
Con-reg (σ S C)           h v = {!σ (λ { (p , w) → S (h p , v w) }) (Con-reg C h λ { (w , s) → v w , s })!}
\end{code}
