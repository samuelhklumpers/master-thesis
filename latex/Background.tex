\subsection{Agda}
We formalize our work in Agda \cite{agda}, a functional programming language with dependent types. Using dependent types we can use Agda as a proof assistant, allowing us to state and prove theorems about our datastructures and programs. These proofs can then be run as algorithms, or in some cases be extracted to a Haskell program\footnote{Or JavaScript, if you want.}.

The type system of Agda is an extension of (intensional) Martin-LÃ¶f type theory (MLTT), a constructive type theory in which we can interpret intuitionistic logic. Compared to Haskell, which extends a polymorphic lambda calculus with inductive types, MLTT allows the type of the codomain of a function to vary with the values in the domain and the type of the second field of a pair type to vary with the value of the first. The interpretation of logic into programs is known as the Curry-Howard isomorphism: propositions or logical formulas are related to types, such that a term of a type constitutes a proof of the related proposition.

Syntactically Agda is similar to Haskell, with a few notable differences. One is that Agda allows most characters and words in identifiers with only a small set of exceptions. For example, we can write
\ExecuteMetaData[Tex/Snippets]{ternary}
The other is that datatypes are given either as generalized algebraic datatypes (GADTs) or record types in Haskell.

An essential semantical difference is that Agda rules out non-termination by restricting function definitions to structural recursion. The termination checker (together with other restrictions which we will encounter in due time) ensures that the logic interpreted in Agda remains consistent, and does not allow trivial proofs which would be tolerated in Haskell, like
\ExecuteMetaData[Tex/Snippets]{loop}
The propositional part of the Curry-Howard correspondence can then be formulated by the usual type formers. The atomic formulas, true and false, can be represented respectively as the empty record: there always is a proof \AgdaFunction{tt} of true
\ExecuteMetaData[Tex/Snippets]{true}
and the type with no constructors: there is no way to make a proof of false
\ExecuteMetaData[Tex/Snippets]{false}
Implication $A \implies B$ corresponds to function types $A \to B$: a proof of $A$ can be converted to a proof of $B$. Implication also gives an interpretation of negation as functions into false $A \to \bot$. Disjunction (logical or) is described by a sum type $A + B$: either of $A$ or $B$ can prove $A + B$
\ExecuteMetaData[Tex/Snippets]{either}
Conjunction (logical and) is given as a product type: having both $A$ and $B$ proves $A \times B$
\ExecuteMetaData[Tex/Snippets]{pair}
Predicates, formulas containing variables, correspond to functions into the type of formulas
\ExecuteMetaData[Tex/Snippets]{predicate}
allowing interpretations of higher-order logic. Quantifiers are interpreted via dependent types, universal quantification (for all) is a dependent function type: for each $a : A$, give a proof of $P\ a$
\ExecuteMetaData[Tex/Snippets]{forall}
Likewise, existential quantification (exists) is a dependent pair type: there is an $a : A$ and a proof $P\ a$
\ExecuteMetaData[Tex/Snippets]{exists}
Predicates can also be expressed using indexed datatypes, in which the choice of constructor can influence the index, whereas parameters must be constant over all constructors. Equality of elements of a type $A$ can then be interpreted as the type
\ExecuteMetaData[Tex/Snippets]{eq}
Closed terms of this type can only be constructed for definitionally equal elements, but crucially, variables can contain equalities between different elements. As the second argument is an index, pattern matching on \AgdaFunction{refl} unifies the elements, such that properties like substitution follow
\ExecuteMetaData[Tex/Snippets]{subst}
\towrite{Isomorphisms}

\subsection{Cubical Agda}
\towrite{Gluing everything together, making representation independence run.}

The methods described in later sections yield type isomorphisms. One might expect that like how isomorphic groups share the same group-theoretical properties, isomorphic types also share the same type-theoretical properties. Meta-theoretically, this is known as \emph{representation independence}, and is evident: if $e: A \simeq B$, simply modify the type by substituting all variables $x : B$ with $e x'$ for $x' : A$, and replacing the resulting terms $t : B$ by $e^{-1} t$. Then the proof term can be recovered by substituting along the equalities $e^{-1}(e x) \equiv x$ as needed.

Inside (ordinary) Agda this is not so practical, as this independence only holds when applied to concrete types, and is then only realized by manually performing these substitutions. On the other hand, in Cubical Agda, the Structure Identity Principle internalizes a kind of representation independence \cite{iri}.

Cubical Agda modifies the type theory of Agda to a kind of homotopy type theory, looking at equalities as paths between terms rather than the equivalence relation generated by reflexivity. In cubical type theories, the role played by pattern matching on \AgdaFunction{refl} or by axiom J, in MLTT and ``Book HoTT'' respectively, is instead acted out by directly manipulating cubes\footnote{Under the analogy where a term is a point, an equality between points is a line, a line between lines is a square.}. In Cubical Agda, univalence
% ua
is not an axiom but a theorem.

% Why circles are points with K

% Why circles are not points with univalence

\subsection{Numerical representations}
\towrite{Generalizing the observation that lists look like unary naturals and Braun trees look like binary naturals.}

\subsection{Generic programming and ornaments}
\towrite{Taking the writing out of our hands, formalizing the ``looks like relation''.}

