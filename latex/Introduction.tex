%\todo[inline, color=red]{Spend some more time on the context}
Agda \cite{agda} is a functional programming language and a proof assistant, taking inspiration from languages like Haskell and other proof assistants such as Coq. We can write programs as we would in Haskell, and then express and prove their properties all inside Agda. This allows us to demonstrate the correctness of programs by formal proof rather than by testing. However, this level of formality also trades-off the uncertainty of testing for a time-investment to produce these proofs. In this thesis, we will explore a variety of methods of proving properties of our programs, focusing on the problems that one may encounter, presenting solutions as they arise. Let us sketch some of these problems.

First, merely adapting a program to Agda may already require changes to the datatypes used in it; for example, if a program manipulating a \AgdaDatatype{List} uses the unsafe \AgdaFunction{head} function, then one is forced to replace the \AgdaDatatype{List} by a datatype that ensures non-emptiness, such as a \AgdaDatatype{NonEmpty} list or a length-aware vector \AgdaDatatype{Vec}. On the other hand, there might be sections of a program where the concrete length is not relevant for correctness and only gets in the way. As a result, one might find themselves duplicating common functions like concatenation \AgdaFunction{\_++\_} to only alter their signatures.

However, the ``new'' datatype (\AgdaDatatype{Vec}) is typically a simple variation on the old datatype (\AgdaDatatype{List}) making small adjustments to the existing constructors; in this case, we decorate the nil and cons constructors with natural numbers representing the length. This kind of modification of types falls in the framework of \textit{ornamentation} \cite{progorn}; if two types are reified to their \textit{descriptions}, then \textit{ornaments} express whether the types are ``similar'' by acting as a recipe to produce one type from the other. By restricting the operations to the copying of corresponding parts, and the introduction of fields or dropping of indices, the existence of such an ornament ensures that the types have the same recursive structure. In general, ornaments allow us to introduce invariants into existing types, so that, as an example, one can derive ordered versions of lists or trees from their ordinary variants. Furthermore, using \textit{patches} \cite{orntrans}, we can in one direction ensure that \AgdaFunction{\_++\_} on \AgdaDatatype{Vec} agrees with its version for \AgdaDatatype{List} under the ornament; in the other direction, a patch can also help us while defining this lifted variant.

Using ornaments, we can organize similar datatypes using ornaments; but we will also make use of relations between dissimilar datatypes. It is conventional to prototype a program using simpler types or implementations, and only replace these with more performant alternatives in critical places. %knowing that this is eventually going to happen, one might as well prepare for it.
While this may quickly turn into a refactoring nightmare in the general case, we can hope for a more satisfying transition if we restrict our attention to a narrower scope. As an example, we might start programming using \AgdaDatatype{List}s, but replace this with a \AgdaDatatype{Tree} if we notice that the program spends most of its time in \AgdaFunction{lookup} operations. To gain a speedup, we will have to reimplement the operations on \AgdaDatatype{Tree}. This would also double the number of necessary proofs; however, we have two ways to avoid this problem. 

We will look at the more specific solution first. This solution is guided by the realization that even though \AgdaDatatype{List} and \AgdaDatatype{Tree} have different recursive structures, they have one commonality; namely, both resemble a number system. Lists and Braun trees\footnote{Braun trees are a kind of binary tree, of which the shape is determined by its size.} can both be presented by deriving them from unary and binary numbers respectively, as is made formal by Hinze and Swierstra \cite{calcdata}. One can then apply this \textit{numerical representation} \cite{purelyfunctional} to simplify or trivialize properties of these datastructures. We will also see that we can interpret numerical interpretations more literally, and construct the representation directly as an ornament.

In the general case, we can apply representation independence. Equality of indiscernables ensures that substituting terms for equal terms cannot change the behaviour of a program, and, as types are terms, the same should hold for types. If we consider two types implementing a given interface, with an operation-preserving isomorphism, then representation independence tells us that the implementations must be functionally equivalent. In the case of trees and lists, this states that since converting a list to a tree preserves \AgdaFunction{lookup}, the outcome of a program that only uses \AgdaFunction{lookup} cannot change when substituting trees for lists. While a proof of this statement usually either exists in the meta-theory, or is produced by manually weaving the conversions through our proofs, Cubical Agda allows us to internalize this independence \cite{iri}.  

We will first take a closer look at SIP \cite{iri} and give concrete examples of proof transport, which we can use to characterize equivalences of flexible two-sided arrays. Then we recall the constructions of numerical representations \cite{calcdata} and ornamentation \cite{progorn}, illustrating how we can define arrays from simpler types by providing interpretations into naturals. We will test these methods by using them to simplify the presentation of finger trees\footnote{A finger tree is a nested type representing a sequence, designed to support amortized constant time en-/dequeueing at both ends, and logarithmic time concatenation and lookup.} \cite{fingertrees}. After that, we will investigate other generic operations, such as the presentation of certain type transformations as ornaments, and the fair enumeration of recursive datatypes.


%\section{\toremove{Introduction}}
%The dependently typed functional programming language Agda \cite{agda} can, when restricted to its reasonable parts, be translated into readable and safe Haskell \cite{agda2hs}. However, the intrinsic safety of languages like Agda can also lead to code duplication by encouraging the use of multiple variants of the same datatype. As an example, the coverage check forces the \AgdaFunction{head} function on \AgdaDatatype{List} to return a \AgdaDatatype{Maybe}. This \AgdaDatatype{Maybe} can be avoided by moving to the length-indexed list type \AgdaDatatype{Vec}, at the cost of duplicating functions like \AgdaFunction{\_++\_}, which we need at both types.

%Something similar happens when replacing an implementation with a more efficient one. For example, when implementing binary trees as a more efficient alternative to lists, the proofs of the same properties will differ between list and tree, and tend to be more difficult for the latter. Switching between implementations of an interface not only duplicates code, but also (and sometimes more than) doubles the effort required to verify both.\todo[inline, color=red]{concrete example?}

%There is plenty of prior work dealing with problems like these. The work in \cite{orntrans} and \cite{progorn} provides the means to relate similar datatypes, such as lists and vectors, using the mechanism of ornamentation, letting us organize variants of the same datatype in a rigid framework.  %This leads them to define the concept of patches, which can aid us when defining \AgdaFunction{\_++\_} for the second time by forcing the new version to be coherent.
%In fact, the algebraic nature of ornaments yields the definition of the vector type for free, provided we relate lists to natural numbers \cite{algorn}. %Such constructions rely heavily on descriptions of datastructures and often come with limitations in their expressiveness. These descriptions in turn impose additional ballast on the programmer, leading us to investigate reflection like in \cite{practgen} as a means to bring datatypes and descriptions closer when possible.

%Other work like \cite{calcdata}\todo[inline, color=red]{don't use \textbackslash cite as noun} simplifies the proofs relating to certain containers directly, formally executing the way of though of numerical representations as noted in \cite{purelyfunctional}.
%From another point of view, lists and trees are not so different at all, provided we look at them through the interface of one-sided flexible arrays; this idea noted in \cite{purelyfunctional} and formalized in \cite{calcdata} where both are shown to be instances of numerical representations by calculating them from a numeral system. 

%When two types are isomorphic and equivalent under an interface, proofs of properties of these implementations should be interconvertible. By using structured equivalences and univalence, \cite{iri} characterizes equivalences under interfaces.
%While this is achievable through meta-programming, substituting conversions to and from into the proof terms, this is internally expressible in Cubical Agda.

%We can liken the situation to movement on a plane, where ornamentation moves us vertically by modifying constructors or indices, and structured equivalences move us horizontally to and from equivalent but more equivalent implementations. In this paper, we will investigate a variety of means of moving around structures and proofs, and ways to make this more efficient or less intrusive.

%In \autoref{sec:leibniz}, we will follow \cite{iri}, and look at how proofs on unary naturals can be transported to the binary naturals. Then in \autoref{sec:numrep} we recall how numeral systems in particular induce container types in \cite{calcdata}, which we attempt to reformulate in the language of ornaments in \autoref{ssec:ornaments}, using the framework of \cite{progorn}. In \autoref{sec:userfriendly} we investigate how we can make the earlier methods more easily accessible to the user, and, ourselves, when we give a description of finger trees in \autoref{sec:fingertrees}.\todo[inline, color=red]{Ok, but make the research question more concrete}

