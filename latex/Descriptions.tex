\section{Numerical Representations}\label{sec:desc-numrep}
Before we dive into descriptions, let us revisit \bN{}, \AD{List} and \AD{Vec}. At first, we defined \AD{Vec} as the length-indexed variant of \AD{List}, such that \AF{lookup} becomes total, and satisfies nice properties like \AF{lookup-insert}. Abstractly, \AD{Vec} is an implementation of finite maps with domain \AD{Fin}, where finite maps are simply those types with operations like \AF{insert}, \AF{remove}, \AF{lookup}, and \AF{tabulate}\footnote{The function \AF{tabulate}\ \AV{:}\ (\AD{Fin}\ \AV{n}\ \AV{→}\ \AV{A})\ \AV{→}\ \AV{Vec}\ \AV{A}\ \AV{n} collects an assignment of elements \AV{f} into a vector \AF{tabulate}\ \AV{f}.}, satisfying relations or laws like \AF{lookup-insert} and \AF{lookup}\ \AF{∘}\ \AF{tabulate}\ \AD{≡}\ \AF{id}. 

For comparison, we can define a trivial implementation of finite maps, by reading \AF{lookup} as a prescript
\ExecuteMetaData[Tex/Descriptions/Numrep]{Lookup2}
Since \AF{lookup} is simply the identity function on \AF{Lookup}, this unsurprisingly satisfies the laws of finite maps, provided we define \AF{insert} and \AF{remove} correctly.

Predictably\footnote{Since \AF{lookup} is an isomorphism with \AF{tabulate} as inverse, as we see from the relations \AF{lookup}\ \AF{∘}\ \AF{tabulate}\ \AD{≡}\ \AF{id} and  \AF{tabulate}\ \AF{∘}\ \AF{lookup}\ \AD{≡}\ \AF{id}.}, \AD{Vec} is \emph{representable}, that is, we have that \AF{Lookup} and \AD{Vec} are equivalent, in the sense that there is an isomorphism between \AF{Lookup} and \AD{Vec}\footnote{Without further assumptions, we cannot use the equality type \AD{≡} for this notion of equivalence of types: a type with a different name but exactly the same constructors as \AD{Vec} would not be equal to \AD{Vec}.}
\ExecuteMetaData[Tex/Descriptions/Numrep]{Iso}
An \AD{Iso} from \AV{A} to \AV{B} is a map from \AV{A} to \AV{B} with a (two-sided) inverse\footnote{This is equivalent to the other notion of equivalence: there is a map $f : A \to B$, and for each \AV{b} in \AV{B} there is exactly one \AV{a} in \AV{A} for which $f(a) = b$.}. In terms of elements, this means that elements of \AV{A} and \AV{B} are in one-to-one correspondence.

We can also establish properties like \AF{lookup-insert} from this equivalence, rather than deriving it ourselves. Rather than finding the properties of \AD{Vec} that were already there, let us view \AD{Vec} as a consequence of the definition of \bN{} and \AF{lookup}. Turning the \AD{Iso} on its head, and starting from the equation that \AD{Vec} is equivalent to \AD{Lookup}, we derive a definition of \AD{Vec} as if solving that equation \cite{calcdata}. As a warm-up, we can also derive \AD{Fin} from the fact that \AD{Fin}\ \AV{n} should contain \AV{n} elements, and thus be isomorphic to \AV{Σ[ m ∈ ℕ ] m < n}.

To express such a definition by isomorphism, we define:
\ExecuteMetaData[Tex/Descriptions/Numrep]{Def}
using
\ExecuteMetaData[Tex/Descriptions/Numrep]{isigma}
The type \AD{Def}\ \AV{A} is deceptively simple, after all, there is (up to isomorphism) only one unique term in it! However, when using \AD{Def}initions, the implicit \AD{Σ'} extracts the right-hand side of a proof of an isomorphism, allowing us to reinterpret a proof as a definition.

To keep the resulting \AD{Iso}s readable, we construct them as chains of smaller \AD{Iso}s using a variant of ``equational reasoning'' \cite{agdastdlib, plfa}, which lets us compose \AD{Iso}s while displaying the intermediate steps. In the calculation of \AD{Fin}, we will use the following lemmas
\ExecuteMetaData[Tex/Descriptions/Numrep]{Fin-lemmas}
In the terminology of \autoref{sec:background-proving}, \AF{⊥-strict} states that ``if A is false, then A \emph{is} false'', if we allow reading isomorphisms as ``\emph{is}'', while \AF{<-split} states that the set of numbers below $n+1$ is 1 greater than the set of numbers below $n$.

Using these, we can calculate\footnote{Here we make non-essential use of \AF{cong} for type families. In the derivation of \AD{Vec} we use function extensionality, which has to be postulated, or can be obtained by using the cubical path types.}
\ExecuteMetaData[Tex/Descriptions/Numrep]{Fin-def}
This gives a different (but equivalent) definition of \AD{Fin} compared to \AF{FinD}: the description \AF{FinD} describes \AD{Fin} as an inductive family, whereas \AF{Fin-def} gives the same definition as a type-computing function \cite{progorn}.

This \AD{Def} then extracts to a definition of \AD{Fin}
\ExecuteMetaData[Tex/Descriptions/Numrep]{Fin}
To derive \AD{Vec}, we will use the isomorphisms
\ExecuteMetaData[Tex/Descriptions/Numrep]{Vec-lemmas}
which one can compare to the familiar exponential laws. These compose to calculate
\ExecuteMetaData[Tex/Descriptions/Numrep]{Vec-def}
which yields us a definition of vectors
\ExecuteMetaData[Tex/Descriptions/Numrep]{Vec}
and the \AD{Iso} to \AF{Lookup} in one go.

In conclusion, we just directly computed a type of finite maps (a numerical representation, here, \AD{Vec}) from a number system (\bN{}).


\section{Temporary}
\subsection{Number systems}

In order to describe more general numerical representations, we must also describe more general number systems. Let us first compare some number systems. For example, we have \bN{}, and the binary numbers
\ExecuteMetaData[Tex/Descriptions/Number]{Leibniz}
As a more exotic example, we have a number system which uses smaller ``number system''
\ExecuteMetaData[Tex/Descriptions/Number]{Phalanx}
and is defined by composing it in its structures
\ExecuteMetaData[Tex/Descriptions/Number]{Carpal}
We observe that across these systems, the interpretation of a number is computed by simple recursion. In particular leaves have associated constants, recursive fields correspond to multiplication and addition, while fields can defer to another function. If we describe the types in \AD{U-sop}, we can thus encode each of these systems by associating a single number to each \AIC{𝟙} and \AIC{ρ}, and a function to each \AIC{σ}, up to equivalence.

In essence, this encodes number systems as structures that at each node linearly combine values of subnodes, generalizing positional number systems in \emph{dense} representation\footnote{Consequently, this excludes the skew binary numbers \cite{oka95b} in their useful sparse representation, but this functionality can be regained by allowing for addition \emph{and} variable multiplication in a \AIC{σ}. While not worked out in this thesis, this extension is compatible with the later constructions.}.

Using a modified version of \AD{U-sop}, we can encode the examples we gave as follows. Note that in \bN{}, we have to insert fields of \AD{⊤}, so we can express that the second constructor acts as $x \mapsto x + 1$
\ExecuteMetaData[Tex/Descriptions/Number]{Nat-num}
marking all leaves as zero. The binary numbers admit a similar encoding, but multiply their recursive fields by two instead
\ExecuteMetaData[Tex/Descriptions/Number]{Leibniz-num}
The \AD{Carpal} system can be encoded by using the interpretation of \AD{Phalanx}
\ExecuteMetaData[Tex/Descriptions/Number]{Carpal-num}
\marker{End A}

\subsection{Nested types}
Returning to the numerical representations, we have to remark that our last universe \AD{U-ix} does not allow us to define all useful datatypes. Consider for example binary random-access lists.

\subsection{Composite types}

\subsection{Hiding variables}



\section{Augmented Descriptions}
\begin{outline}
    De definitie van number system (record Info) is nieuw en hangt vrij
   nauw samen met de universe die je gebruikt. Dat is (deels) te
   begrijpen -- je wilt datastructuren beschrijven als ornaments van
   numbers. Maar nu voelt de presentatie enigsinds backwards -- je
   definieert de Info type die precies past op je descriptions, ipv uit
   te leggen wat een number system is -- een soort specificatie
   opstellen die los staat van de implementatie adhv descriptions. Hoe
   zou je Peano/binary numbers/skew binary numbers/enz beschrijven
   hiermee? En waarom is dit de juiste abstractie voor number systems?
   (En kun je die vraag beantwoorden zonder te refereren aan
   descriptions)
\end{outline}
\mark{Ik denk dat de vorm die een getalsysteem kan hebben (i.e., universe), sterk gekoppeld is aan hoe deze geinterpreteerd kan worden, en hoe die geabstraheerd kan worden. Specificaties van ``wat is een getalsysteem'' zijn in die zin vrij fragiel, zouden we pure positional number systems definieren, dan vallen fingertrees buiten de boot, zouden we sparse skew binary numbers willen encoderen, dan moeten we ineens weer reeksen waarden als variabele factoren moeten interpreteren. Daarom denk ik dat een uitleg vanuit de gedachtengang ``we hebben descriptions, en kijk hoe weinig we hoeven aan te passen om daar ook getallen mee te beschrijven'' een betere aanleiding geeft voor wat er later in ieder geval met Info aan zit te komen.}


\marker{Rewrite}
For there to be an ornament between a number system and its numerical representation, the descriptions of both need to live in the same universe. Hence, we will generalize the type of descriptions over information such as multipliers later, rather than defining a new universe of number systems here. The information needed to describe a number system can be separated between the type-formers. Namely, a leaf \AIC{𝟙} requires a constant in \bN{}, a recursive field \AIC{ρ} requires a multiplier in \bN{}, while a field \AIC{σ} will need a function to convert values to \bN{}.

To facilitate marking type-formers with specific bits of information, we define \todo{Compare this with the usual metadata in generics like in Haskell, but then a bit more wild. Also think of annotations on fingertrees.}
\ExecuteMetaData[Ornament/Desc]{Info}
to record the type of information corresponding to each type-former. We can summarize the information which makes a description into a number system as the following \AD{Info}:
\ExecuteMetaData[Ornament/Numerical]{Number} 
which will then ensure that each \AIC{𝟙} and \AIC{ρ} both are assigned a number \bN{}, and each \AIC{σ} is assigned a function that converts values of the type of its field to \bN{}.

On the other hand, we can also declare that a description needs no further information by:
\ExecuteMetaData[Ornament/Desc]{Plain}
By making the fields of information implicit in the type of descriptions, we can ensure that descriptions from \AD{U-ix} can be imported into the generalized universe without change.

%In a more interesting example, we can define
%\ExecuteMetaData[Ornament/Desc]{Countable}
%so that to define a \AD{DescI}\ \AF{Countable}, one has to provide a proof that each field is countable, which could be used to prove that each type represented by a \AD{DescI}\ \AF{Countable} is in turn also countable.

In the descriptions, the \AIC{δ} type-former, which we will discuss in closer detail in the next section, represents the inclusion of one description in a larger description. When we include another description, this description will also be equipped with extra information, which we allow to be different from the kind of information in the description it is included in. When this happens, we ask that the information on both sides is related by a transformation:
\ExecuteMetaData[Ornament/Desc]{InfoF}
which makes it possible to downcast (or upcast) between different types of information. This, for example, allows the inclusion of a number system \AD{DescI}\ \AF{Number} into an ordinary datatype \AD{Desc} without rewriting the former as a \AD{Desc} first.


\section{The Universe}\label{ssec:desc}
We also need to take care that the numerical representations we will construct indeed fit in our universe. The final universe \AD{U-ix} of \autoref{ssec:background-ix}, while already quite general, still excludes many interesting datastructures. In particular, the encoding of parameters forces recursive type occurrences to have the same applied parameters, ruling out nested datatypes such as (binary) random-access lists \cite{calcdata,purelyfunctional}\todo{Kun je aannemelijk maken dat er geen dependently typed encoding
bestaat van Finger Trees? Voor binary random access lijsten, perfect
trees, en lambda termen bestaan die wel... Of is de constructie te
omslachtig?}:
\ExecuteMetaData[Tex/DescOrn]{random-access}
and finger trees \cite{fingertrees}:
\ExecuteMetaData[Tex/DescOrn]{finger-tree}
Even if we could represent nested types in \AD{U-ix} we would find it still struggles with finger trees: Because adding non-recursive fields modifies the variable telescope, it becomes hard to reuse parts of a description in different places. Apart from that, the number of constructors needed to describe finger trees and similar types also grows quickly when adding fields like \AD{Digit}.

We will resolve these issues as follows. We can describe nested types by allowing parameters to be transformed before they are passed to recursive fields \cite{initenough}. By transforming variables before they are passed to subsequent fields, it becomes possible to hide fields that are not referenced later and to share or reuse constructor descriptions. Finally, by adding a variant of \AIC{σ} specialized to descriptions, we can describe composite datatypes more succinctly\todo{Compare this to Haskell, in which representations are type classes, which directly refer to other types (even to the type itself in a recursive instance). (But that's also just there because in Haskell the type always already exists and they do not care about positivity and termination).}.

\begin{outline}
    Ik merk dat ik -- door de afstand in tijd (een poosje geleden) en
   ruimte (best een paar blzs terug) -- moeite heb om zo'n grote data
   type als DescI te begrijpen. Kun je misschien toch iets meer uitleg
   geven? Wat is er veranderd? Welke indices zijn toegevoegd/aangepast?
   Er blijft ook een hoop hetzelfde: descriptions zijn lijsten van
   constructors. Iets meer uitleg hier is echt nodig om de code te
   begrijpen.
\end{outline}
Combining these changes, we define the following universe:
\ExecuteMetaData[Ornament/Desc]{Desc}
where the constructors are defined as:
\ExecuteMetaData[Ornament/Desc]{Con}
From this definition, we can recover the ordinary descriptions as
\ExecuteMetaData[Ornament/Desc]{Plain-synonyms}
%and first explain the differences in type-formers compared to \AD{U-ix}, and how these 
Let us explain this universe by discussing some of the old and new datatypes we can describe using it. Some of these datatypes do not make use of the full generality of this universe, so we define some shorthands to emulate the simpler descriptions. Using 
\ExecuteMetaData[Ornament/Desc]{sigma-pm}
(and the analogues for \AIC{δ}) we emulate unbound and bound fields respectively, and with 
\ExecuteMetaData[Ornament/Desc]{rho-zero}
we emulate an ordinary (as opposed to nested) recursive field. We can then describe \bN{} and \AD{List} as before
\ExecuteMetaData[Ornament/Desc]{NatD}
\ExecuteMetaData[Ornament/Desc]{ListD}
by replacing \AIC{σ} with \AF{σ-} and \AIC{ρ} with \AIC{ρ0}.

On the other hand, we bind the length of a vector as a field when defining vectors, so there we use \AF{σ+} instead:
\ExecuteMetaData[Ornament/Desc]{VecD}
With the nested recursive field \AIC{ρ}, we can define the type of binary random-access arrays. Recall that for random-access arrays, we have that an array with parameter \AV{A} contains zero, one, or two values of \AV{A}, but the recursive field must contain an array of twice the weight. Hence, the parameter passed to the recursive field is \AV{A times A}, for which we define
\ExecuteMetaData[Ornament/Desc]{Pair}
Passing \AF{Pair} to \AIC{rho} we can define random access lists:  
\ExecuteMetaData[Ornament/Desc]{RandomD}
To represent finger trees, we first represent the type of digits \AD{Digit}: \todo{reminder to cite this here if I end up not referencing finger trees earlier.}
\ExecuteMetaData[Ornament/Desc]{DigitD}
We can then define finger trees as a composite type from \AD{Digit}:
\ExecuteMetaData[Ornament/Desc]{FingerD}
Here, the fact that the first \AIC{δ-} drops its field from the telescope makes it possible to reuse of \AD{Digit} in the second \AIC{δ-}.

These descriptions can be instantiated as before by taking the fixpoint\footnote{Note that these (obviously?) ignore the \AD{Info} of a description.}
\ExecuteMetaData[Ornament/Desc]{fpoint}
of their interpretations as functors
\ExecuteMetaData[Ornament/Desc]{interpretation}
In this universe, we also need to insert the transformations of parameters \AV{f} in \AIC{ρ} and the transformations of variables \AV{h} in \AIC{σ} and \AIC{δ}.

%Like for \AD{U-ix}, we can give the generic \AF{fold} for \AD{DescI}\todo{But why}
%\ExecuteMetaData[Ornament/Desc]{fold-type}

