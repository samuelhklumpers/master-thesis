%outline:
%we explained why descriptions and ornaments are crucial to achieve our goals
%however, the descriptions we explained earlier are not powerful enough to house finger trees


%To capture finger trees as an ornament over a number system, we will need to describe ornaments over nested datatypes. In this section we will work out descriptions and ornaments suitable for nested datatypes.
If we are going to simplify working with complex containers %, such as finger trees,
by instantiating generic programs to them, we should first make sure that these types fit into the descriptions.

We construct descriptions for nested datatypes by extending the encoding of parametric and indexed datatypes from \autoref{ssec:bg-desc} with three features: information bundles, parameter transformation, and description composition. Also, to make sharing constructors easier, we introduce variable transformations. Transforming variables before they are passed to child descriptions allows both aggressively hiding variables and introducing values as if by let-constructs.

We base the encoding of off existing encodings \cite{sijsling,practgen}. The descriptions take shape as sums of products, enforce indices at leaf nodes, and have explicit parameter and variable telescopes. Unlike some encodings \cite{effectfully, practgen}, we do not allow higher-order inductive arguments. 

We use type-in-type and with-K to simplify the presentation, noting that these can be eliminated respectively by moving to Typeœâ and by implementing interpretations as datatypes.

\section{The descriptions}\label{ssec:desc}
We use telescopes identical to those in \autoref{ssec:bg-desc}:
\ExecuteMetaData[Ornament/Desc]{telescopes}
Recall that a \AgdaDatatype{Tel} represents a sequence of types, which can depend on the external type $P$. This lets us represent a telescope succeeding another using \AgdaDatatype{ExTel}. A term of the interpretation \AgdaFunction{‚ü¶\_‚üßtel} is then a sequence of terms of all the types in the telescope.

We use some shorthands
\ExecuteMetaData[Ornament/Desc]{tele-shorthands}
\ExecuteMetaData[Ornament/Desc]{shorthands}

As we will see in \autoref{sec:trieo}, some generics require descriptions augmented with more information. For example, a number system needs to describe both a datatype and its interpretation into naturals. This can be incorporated into a description by allowing description formers to query specific pieces of information. We will control where and when which pieces get queried by parametrizing descriptions over information bundles  
\ExecuteMetaData[Ornament/Desc]{Info}
Here a bundle declares for example that \AgdaField{ùüôi} is the type of information has to be provided at a \AgdaInductiveConstructor{ùüô} former. Remark that in \AgdaField{œÉi}, the bundle can ask for something depending on the type of the field. In \AgdaField{Œ¥i}, the bundle can ask something regarding the parameters and indices (e.g., it can force only unindexed subdescriptions.).

\begin{example}
    For example, we can encode a class of number systems using the information 
    \ExecuteMetaData[Ornament/Numerical]{Number}
    (refer to \autoref{sec:trieo}). If we then define the unit type, when viewed as a \AgdaFunction{Number}
    \ExecuteMetaData{Ornament/Numerical}{Unit}
    we have to provide the information that the only value of the unit type evaluates to 1.
\end{example}

We can recover the conventional descriptions by providing the plain bundle:
\ExecuteMetaData[Ornament/Desc]{Plain}
We define the ``down-casting'' of information as
\ExecuteMetaData[Ornament/Desc]{InfoF}
allowing us to reuse more specific descriptions in less specific ones, so that e.g., a number system can be used in a plain datatype.

We can now define the descriptions, which should represent a mapping between parametrized indexed functors
\ExecuteMetaData[Ornament/Desc]{PIType}
Recall that a description 
\ExecuteMetaData[Ornament/Desc]{DescI}
is simply a list of constructor descriptions
\ExecuteMetaData[Ornament/Desc]{Con}
The interpretations \hyperlink{desc-desc-interpretation}{\AgdaFunction{‚ü¶\_‚üß}} of the formers can be found below.

Leaves are formed by
\ExecuteMetaData[Ornament/Desc]{Con-1}
Here \AgdaBoundFontStyle{if} queries information according to \texttt{If}, and \AgdaBoundFontStyle{j} computes the index of the leaf from the parameters and variables.

A recursive field is formed by
\ExecuteMetaData[Ornament/Desc]{Con-rho}
where \AgdaBoundFontStyle{j} now determines the index of the recursive field. The function \AgdaBoundFontStyle{g} represents a parameter transform: the parameters of the recursive field can now changed at each recursive level, allowing us to describe nested datatypes. The remainder of the fields are described by \AgdaBoundFontStyle{C}. Note that a recursive field is intentionally not brought into scope: making use of it requires induction-recursion anyway!

A non-recursive field is formed similarly to a recursive field
\ExecuteMetaData[Ornament/Desc]{Con-sigma}
The type of the field is given by \AgdaBoundFontStyle{S}, which may depend on the values of the preceding fields. We bring the field into scope, so we continue the description in an extended context. However, we allow the remainder of the description to provide a conversion from \texttt{V ‚ñ∑ S} into \texttt{W} to select a new context. This makes it possible to hide fields which are unused in the remainder.

Almost analogously, we make composition of descriptions internal by a variant of \AgdaInductiveConstructor{œÉ}
\ExecuteMetaData[Ornament/Desc]{Con-delta}
This takes a description \texttt{R}, and acts like the \AgdaInductiveConstructor{œÉ} of \texttt{Œº R}, only with more ceremony. This will allow us to form descriptions by composing other descriptions, avoiding multiplying the number of constructors of composite datatypes.

Similar to \AgdaInductiveConstructor{œÅ}, the functions \AgdaBoundFontStyle{j} and \AgdaBoundFontStyle{g} control indices and parameters, only now of the applied description. As we allow the description \AgdaBoundFontStyle{R} of the field to have a different kind of information bundle \AgdaBoundFontStyle{If‚Ä≤}, we must ask that we can down-cast it into \AgdaBoundFontStyle{If} via \AgdaBoundFontStyle{iff}. 

Descriptions and constructor descriptions can then be interpreted to appropriate kind of functor, constructor descriptions also taking variables
\hypertarget{desc-desc-interpretation}{}
\ExecuteMetaData[Ornament/Desc]{interpretation}
We see that a leaf becomes a constraint between expected index and the actual index. A recursive field passes down a transformation of the current parameters and the expected index computed from the variables, before interpreting the remainder of the description. Likewise, a non-recursive field adds a field with type depending on variables, but also adds this field to the variables, which are then transformed and passed on to the remainder. The composite field is analogous, only adding a field from a description rather than a type. Finally, the list of constructor descriptions are interpreted as alternatives.

The fixpoint can then be taken over the interpretation of a description
\ExecuteMetaData[Ornament/Desc]{fpoint}
giving the datatype represented by the description.

We can then give a generic fold for the represented datatypes
\ExecuteMetaData[Ornament/Desc]{fold}
which descends the description, mapping itself over all recursive fields before applying the folding function.
\begin{remark}
    The situation of \AgdaFunction{fold} is very common when dealing with different kinds of recursive interpretations: functions from the fixpoint are generally defined from functions out of the interpretation, generalizing over the inner description while pattern matching on the outer description. 
\end{remark}
Note that the fold requires a rather general function, limiting its usefulness: because of the parameter transformations, we cannot instantiate the fold to a single parameter. Defining, e.g., the vector sum, would require us to inspect the description, and ask that a vector of naturals can be converted into a vector of naturals, which is trivial in this case.

\todo{Sigma plus/minus}

Let's look at some examples. We can encode the naturals as a type parametrized by \AgdaInductiveConstructor{‚àÖ} and indexed by \AgdaDatatype{‚ä§}
\ExecuteMetaData[Ornament/Desc]{NatD}
Lists can be encoded similarly, but this time using the telescope
\ExecuteMetaData[Ornament/Desc]{ListTel}
declaring that lists have a single type parameter. Compared to the naturals, the description now also asks for a field in the second case
\ExecuteMetaData[Ornament/Desc]{ListD}
Since the type parameter is at the top of the parameter telescope, the type of the field is given as \AgdaBoundFontStyle{par top}.

Vectors are described using the same structure, but have indices in \bN{}.
\ExecuteMetaData[Ornament/Desc]{VecD}
In the first case, the index is fixed at 0. The second case declares that to construct a vector of length \AgdaBoundFontStyle{suc ‚àò top}, the recursive field must have length \AgdaFunction{top}. Note that unlike index-first types, we cannot know the expected index from inside the description, so much like native indexed types, we must add a field choosing an index.

Recall the type of finger trees. Using parameter transformations and composition, we can give a description of full-fledges finger trees! First, we describe the digits
\ExecuteMetaData[Ornament/Desc]{DigitD}
and define the nodes\footnote{We could give the nodes as a description, but in this case we only use them in the recursive fields, so we would take the fixpoint without looking at their description anyway.}
\ExecuteMetaData[Ornament/Desc]{Node}
We encode finger trees as
\ExecuteMetaData[Ornament/Desc]{FingerD}
In the third case, we have digits which are passed the parameters on both sides in composite fields, and a recursive field in the middle. The recursive field has a parameter transformation, turning the type parameter \AgdaBoundFontStyle{A} into a \AgdaBoundFontStyle{Node A} in the recursive child.

%\investigate{Making \AgdaDatatype{Desc} coinductive would do a couple of things. First, recursion and composition become identical. Second, nesting of both types becomes easier to describe, but potentially impossible to prove strictly positive.}

%\investigate{We intentionally dodge having index telescopes (or having the index type depend on the parameters and values). Does this really change anything?}



\section{The ornaments}
\towrite{Put something that isn't yet in \autoref{ssec:bg-orn} here.}

\ExecuteMetaData[Ornament/Orn]{Orn-type}
\ExecuteMetaData[Ornament/Orn]{ornForget-type}
%Thus, the relation should be precise enough pairs of \AgdaBoundFontStyle{E} and \AgdaBoundFontStyle{D} for which we could not define \AgdaFunction{ornForget}.

We will walk through the constructor ornaments
\ExecuteMetaData[Ornament/Orn]{ConOrn-type}
again, an ornament between datatypes is just a list of ornaments between their constructors
\ExecuteMetaData[Ornament/Orn]{Orn}
Note that all ornaments completely ignore information bundles! They cannot affect the existence of \AgdaFunction{ornForget} after all.

Copying parts from one description to another, up to parameter and index refinement, corresponds to reflexivity. Preservation of leaves follows the rule
\ExecuteMetaData[Ornament/Orn]{Orn-1}
We can see that this commuting square (\texttt{e (k p) ‚â° j (over f p)}) is necessary: take a value of \texttt{E} at \texttt{p, i}, where \texttt{i} is given as \texttt{k p}. Then \AgdaFunction{ornForget} has to convert this to a value of \texttt{D} at \texttt{f p , e i}, but since \texttt{e i} must match \texttt{j (f p)}, this is only possible if \texttt{e (k p) = j (f p)}.

Preserving a recursive field similarly requires a square of indices and conversions to commute
\ExecuteMetaData[Ornament/Orn]{Orn-rho}
additionally requiring the recursive parameters to commute with the conversion. \todo{Does adding the derivations for the squares everywhere make this section clearler?}

Preservation of non-recursive fields and description fields is analogous
\ExecuteMetaData[Ornament/Orn]{Orn-sigma-delta}
differing only in that non-recursive fields appears transformed on the right hand, while description fields have their conversions modified instead. For this rule, we need that the variable transformations fit into a commuting square with the parameter conversions. The condition on indices for descriptions, which is a commuting triangle, is encoded in the return type\footnote{Should this become a problem like with \AgdaInductiveConstructor{œÅ}, modifying the rule to require a triangle is trivial.}.

Ornaments would not be very interesting if they only related identical structures. The left-hand side can also have more fields than the right-hand side, in which case \AgdaFunction{ornForget} will simply drop the fields which have no counterpart on the right-hand side. As a consequence, the description extending rules have fewer conditions than the description preserving rules: 
\ExecuteMetaData[Ornament/Orn]{Orn-+-rho}
Note that this extension\footnote{Kind of breaking the ``ornaments relate types with similar recursive structure'' interpretation.} with a recursive field has no conditions.

Extending by a non-recursive field or a description field again only requires the variable transform to interact well with the parameter conversion
\ExecuteMetaData[Ornament/Orn]{Orn-+-sigma-delta}

In the other direction, the left-hand side can also omit a field which appears on the right-hand side, provided we can produce a default value
\ExecuteMetaData[Ornament/Orn]{Orn---sigma-delta}
These rules let us describe the basic set of ornaments between datatypes.

Intuitively we also expect a conversion to exist when two constructors have description fields which are not equal, but are only related by an ornament. Such a composition of ornaments takes two ornaments, one between the field, and one between the outer descriptions. This composition rule reads:\todo{The implicits kind of get out of control here, but the rule is also unreadable without them. I might hide the rule altogether and only run an example with it.}
\ExecuteMetaData[Ornament/Orn]{Orn-comp}
We first require two commuting squares, one relating the parameters of the fields to the inner and outer parameter conversions, and one relating the indices of the fields to the inner index conversion and the outer parameter conversion. Then, the last square has a rather complicated equation, which merely states that the variable transforms for the remainder respect the outer parameter conversion.

We will construct \AgdaFunction{ornForget} as a \AgdaFunction{fold}. Using
\ExecuteMetaData[Ornament/Orn]{erase-type}
we can define the algebra which forgets the added structure of the outer layer
\ExecuteMetaData[Ornament/Orn]{ornAlg}
Folding over this algebra gives the wanted function
\ExecuteMetaData[Ornament/Orn]{ornForget}

\todo{NatD was removed here}

We can also relate lists and vectors
\ExecuteMetaData[Ornament/Orn]{ListD-VecD}
Now the parameter conversion is the identity, since both have a single type parameter. The index conversion is \AgdaFunction{!}, since lists have no indices. Again, most structure is preserved, we only note that vectors have an added field carrying the length.

Instantiating \AgdaFunction{ornForget} to these ornaments, we now get the functions \AgdaFunction{length} and \AgdaFunction{toList} for free!

%\investigate{Having a function of the same type as \AgdaFunction{ornForget} is not sufficient to deduce an ornament. An obstacle is that the usual empty type (no constructors) and the non-wellfounded empty type (only a recursive field) don't have an ornament. Also, while the leaf-preservation case spells itself out, the substitutions obviously don't give us a way to recover the equalities.}


\section{Ornamental descriptions}
A description can say ``this is how you make this datatype'', an ornament can say ``this is how you go between these types''. However, an ornament needs its left-hand side to be predefined before it can express the relation, while we might also interpret an ornament as a set of instructions to translate one description into another. A slight variation on ornaments can make this kind of usage possible: ornamental descriptions.

An ornamental description drops the left-hand side when compared to an ornament, and interprets the remaining right-hand side as the starting point of the new datatype:
\ExecuteMetaData[Ornament/OrnDesc]{ConOrnDesc-type}
The definition of ornamental descriptions can be derived in a straightforward manner from ornaments, removing all mentions of the LHS and making all fields which then no longer appear in the indices explicit\footnote{One might expect to need less equalities, alas, this is difficult because of \autoref{rem:orn-lift}.}. We will show the leaf-preserving rule as an example, the others are derived analogously:
\ExecuteMetaData[Ornament/OrnDesc]{OrnDesc-1}
As we can see, the only change we need to make is that \AgdaBoundFontStyle{k} becomes explicit and fully annotated.

Almost by construction, we have that an ornamental description can be decomposed into a description of the new datatype
\ExecuteMetaData[Ornament/OrnDesc]{toDesc}
and an ornament between the starting description and this new description
\ExecuteMetaData[Ornament/OrnDesc]{toOrn}


\section{Temporary: future work}
\begin{remark}
    Note that this allows us to express datatypes like finger trees, but not rose trees. Such datatypes would need a way to place a functor ``around the \AgdaInductiveConstructor{œÅ}'', which then also requires a description of strictly positive functors. In our setup, this could only be encoded by separating general descriptions from strictly positive descriptions. The non-recursive fields of these strictly positive descriptions then need to be restricted to only allow compositions of strictly positive context functions. 
\end{remark} % \investigate{This setup does not allow nesting over recursive fields, which is necessary for structures like rose trees. This is actually kind of essential for enumeration. Nesting over a recursive field is problematic: we can incorporate it by adding ``this'' implicitly to a \AgdaInductiveConstructor{Œ¥}, but then the \AgdaBoundFontStyle{R} needs to be strictly positive in its last argument, meaning we need to split \AgdaDatatype{Desc} into a strictly positive part and normal part. The strictly positive part should then only allow strictly positive parameter transforms in recursive and non-recursive fields, requiring an embedding of transforms.}

\begin{remark}
    Variable transforms are not essential in these descriptions, but there are a couple of reasons for keeping them. In particular, they make it possible to reuse a description in multiple contexts, and save us from writing complex expressions in the indices of our ornaments. On the other hand, the transforms still make defining ornaments harder (the majority of the commuting squares are from variables). Isolating them into a single constructor of \AgdaDatatype{Desc}, call it \AgdaInductiveConstructor{v}, seems like a good middle ground, but raises some odd questions, like ``why is there no ornament between \AgdaBoundFontStyle{v (g ‚àò f) C} and \AgdaBoundFontStyle{v g (v f C)}''. (Furthermore, this also does not simplify the indices of ornaments).
\end{remark} %\investigate{Variable transforms are both less essential and less troublesome than I first thought. We can move variable transforms into a new former, and it probably simplifies the definition of ornaments a lot.}

\begin{remark}
    Rather, ornaments themselves could act as information bundles. If there was a description for \AgdaDatatype{Desc}, that is. Such a scheme of levitation would make it easier to switch between being able to actively manipulate information, and not having to interact with it at all. However, the complexity of our descriptions makes this a non-trivial task; since our \AgdaDatatype{Desc} is given by mutual recursion and induction-recursion, the descriptions, and the ornaments, would have to be amended to encode both forms of recursion as well.
\end{remark} % \investigate{If we levitate, then informed descriptions become ornaments over \AgdaDatatype{Desc}. This gives us the best of both worlds (modulo reflecting the description into a datatype): in plain descriptions, information does not even exist, and in informed descriptions, it is explicit. For levitation, we likely need induction-recursion and mutual recursion.}

\begin{remark}\label{rem:orn-lift}
    Rather than having the user provide two indices and show that the square commutes, we can ask for a ``lift'' $k$
    % https://q.uiver.app/#q=WzAsNCxbMCwwLCJcXGJ1bGxldCJdLFsxLDAsIlxcYnVsbGV0Il0sWzAsMSwiXFxidWxsZXQiXSxbMSwxLCJcXGJ1bGxldCJdLFswLDEsImUiXSxbMiwzLCJmIiwyXSxbMiwwLCJqIl0sWzMsMSwiaSIsMl0sWzMsMCwiayIsMV1d
    \[\begin{tikzcd}
        \bullet & \bullet \\
        \bullet & \bullet
        \arrow["e", from=1-1, to=1-2]
        \arrow["f"', from=2-1, to=2-2]
        \arrow["j", from=2-1, to=1-1]
        \arrow["i"', from=2-2, to=1-2]
        \arrow["k"{description}, from=2-2, to=1-1]
    \end{tikzcd}\]
    and derive the indices as $i = ek, j = kf$. However, this is more restrictive, unless $f$ is a split epi, as only then pairs $i,j$ and arrows $k$ are in bijection. In addition, this makes ornaments harder to work with, because we have to hit the indices definitionally, whereas asking for the square to commute gives us some leeway (i.e., the lift would require the user to transport the ornament). 
\end{remark}


%\investigate{Can these be simpler? Right now, these just construct the ornament and description on the fly, rather than actually asking for less.}
