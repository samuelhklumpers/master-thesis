@misc{agda,
  author       = {Agda Development Team},
  title        = {Agda},
  year         = {2023},
  url          = {https://agda.readthedocs.io/en/v2.6.3/}
}

@article{orntrans,
	doi = {10.1017/s0956796814000069},
  
	url = {https://doi.org/10.1017%2Fs0956796814000069},
  
	year = 2014,
	month = {4},
  
	publisher = {Cambridge University Press ({CUP})},
  
	volume = {24},
  
	number = {2-3},
  
	pages = {316--383},
  
	author={Pierre-{\'{E}}variste Dagand and Conor McBride},
  
	title = {Transporting functions across ornaments},
  
	journal = {Journal of Functional Programming}
}

@article{progorn,
    title = {Programming with ornaments},
    volume = {27},
    DOI={10.1017/S0956796816000307},
    journal={Journal of Functional Programming},
    publisher={Cambridge University Press},
    author={Ko, Hsiang-Shang and Gibbons, Jeremy},
    year={2016},
    pages={e2}
}

@inproceedings{algorn,
  title={Ornamental Algebras, Algebraic Ornaments},
  author={Conor McBride},
  year={2014}
}

@article{practgen,
author = {Escot, Lucas and Cockx, Jesper},
title = {Practical Generic Programming over a Universe of Native Datatypes},
year = {2022},
issue_date = {August 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {ICFP},
url = {https://doi.org/10.1145/3547644},
doi = {10.1145/3547644},
abstract = {Datatype-generic programming makes it possible to define a construction once and apply it to a large class of datatypes. It is often used to avoid code duplication in languages that encourage the definition of custom datatypes, in particular state-of-the-art dependently typed languages where one can have many variants of the same datatype with different type-level invariants. In addition to giving access to familiar programming constructions for free, datatype-generic programming in the dependently typed setting also allows for the construction of generic proofs. However, the current interfaces available for this purpose are needlessly hard to use or are limited in the range of datatypes they handle. In this paper, we describe the design of a library for safe and user-friendly datatype-generic programming in the Agda language. Generic constructions in our library are regular Agda functions over a broad universe of datatypes, yet they can be specialized to native Agda datatypes with a simple one-liner. Furthermore, we provide building blocks so that library designers can too define their own datatype-generic constructions.},
journal = {Proc. ACM Program. Lang.},
month = {8},
articleno = {113},
numpages = {25},
keywords = {Dependent types, Generic programming}
}

@InProceedings{calcdata,
author="Hinze, Ralf and Swierstra, Wouter",
editor="Komendantskaya, Ekaterina",
title="Calculating Datastructures",
booktitle="Mathematics of Program Construction",
year="2022",
publisher="Springer International Publishing",
address="Cham",
pages="62--101",
abstract="Where do datastructures come from? This paper explores how to systematically derive implementations of one-sided flexible arrays from a simple reference implementation. Using the dependently typed programming language Agda, each calculation constructs an isomorphic---yet more efficient---datastructure using only a handful of laws relating types and arithmetic. Although these calculations do not generally produce novel datastructures they do give insight into how certain datastructures arise and how different implementations are related.",
isbn="978-3-031-16912-0"
}

@misc{iri,
    title={Internalizing Representation Independence with Univalence}, 
    author={Carlo Angiuli and Evan Cavallo and Anders Mörtberg and Max Zeuner},
    year={2020},
    eprint={2009.05547},
    archivePrefix={arXiv},
    primaryClass={cs.PL}
}

@article{cuagda,
author = {Vezzosi, Andrea and M\"{o}rtberg, Anders and Abel, Andreas},
title = {Cubical Agda: A Dependently Typed Programming Language with Univalence and Higher Inductive Types},
year = {2019},
issue_date = {August 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {ICFP},
url = {https://doi.org/10.1145/3341691},
doi = {10.1145/3341691},
abstract = {Proof assistants based on dependent type theory provide expressive languages for both programming and proving within the same system. However, all of the major implementations lack powerful extensionality principles for reasoning about equality, such as function and propositional extensionality. These principles are typically added axiomatically which disrupts the constructive properties of these systems. Cubical type theory provides a solution by giving computational meaning to Homotopy Type Theory and Univalent Foundations, in particular to the univalence axiom and higher inductive types. This paper describes an extension of the dependently typed functional programming language Agda with cubical primitives, making it into a full-blown proof assistant with native support for univalence and a general schema of higher inductive types. These new primitives make function and propositional extensionality as well as quotient types directly definable with computational content. Additionally, thanks also to copatterns, bisimilarity is equivalent to equality for coinductive types. This extends Agda with support for a wide range of extensionality principles, without sacrificing type checking and constructivity.},
journal = {Proc. ACM Program. Lang.},
month = {7},
articleno = {87},
numpages = {29},
keywords = {Higher Inductive Types, Dependent Pattern Matching, Cubical Type Theory, Univalence}
}

@book{purelyfunctional,
author = {Okasaki, Chris},
title = {Purely Functional Data Structures},
year = {1998},
isbn = {0521631246},
publisher = {Cambridge University Press},
address = {USA}
}

@inproceedings{agda2hs,
author = {Cockx, Jesper and Melkonian, Orestis and Escot, Lucas and Chapman, James and Norell, Ulf},
title = {Reasonable Agda is Correct Haskell: Writing Verified Haskell Using Agda2hs},
year = {2022},
isbn = {9781450394383},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3546189.3549920},
doi = {10.1145/3546189.3549920},
abstract = {Modern dependently typed languages such as Agda can be used to statically enforce the correctness of programs. However, they still lack the large ecosystem of a more popular language like Haskell. To combine the strength of both approaches, we present agda2hs, a tool that translates an expressive subset of Agda to readable Haskell, erasing dependent types and proofs in the process. Thanks to Agda's support for erasure annotations, this process is both safe and transparent to the user. Compared to other tools for program extraction, agda2hs uses a syntax that is already familiar to functional programmers, allows for both intrinsic and extrinsic approaches to verification, and produces Haskell code that is easy to read and audit by programmers with no knowledge of Agda. We present a practical use case of agda2hs at IOG to verify properties of a program generator. While both agda2hs and its ecosystem are still young, our experiences so far show that this is a viable approach to make verified functional programming available to a broader audience. This paper is a literate Agda script, hence all rendered (Agda) code has been typechecked.},
booktitle = {Proceedings of the 15th ACM SIGPLAN International Haskell Symposium},
pages = {108–122},
numpages = {15},
keywords = {Dependent types, Program extraction, Agda, Formal verification},
location = {Ljubljana, Slovenia},
series = {Haskell 2022}
}

@article{hetbin,
title={Heterogeneous binary random-access lists},
volume={30},
DOI={10.1017/S0956796820000064},
journal={Journal of Functional Programming},
publisher={Cambridge University Press},
author={Swierstra,
WOUTER},
year={2020},
pages={e10}}

@article{fingertrees,
title={Finger trees: a simple general-purpose data structure},
volume={16},
DOI={10.1017/S0956796805005769},
number={2},
journal={Journal of Functional Programming},
publisher={Cambridge University Press},
author={Hinze, Ralf and Paterson, Ross},
year={2006},
pages={197–217}}

@inproceedings{glookup,
author = {Diehl, Larry and Sheard, Tim},
title = {Generic Lookup and Update for Infinitary Inductive-Recursive Types},
year = {2016},
isbn = {9781450344357},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2976022.2976031},
doi = {10.1145/2976022.2976031},
abstract = {The class of Infinitary inductive-recursive (InfIR) types is commonly used to model type theory within itself. While it is common and convenient to provide examples of values within an InfIR model, writing functions that manipulate InfIR types is an underexplored area due to their inherent complexity. Our goal in this work is to push the boundaries of programming with InfIR types by introducing two functions operating over them. The first is a lookup function to extract sub-components from an InfIR type, and the second is an update function to replace sub-components within an InfIR type. We start by considering how to write such functions for concrete examples of InfIR types, and then show how to write generic versions of the functions for any datatype definable in the universe of InfIR types. We actually write two versions of the generic functions, one where the universe is open and another where the universe is closed.},
booktitle = {Proceedings of the 1st International Workshop on Type-Driven Development},
pages = {1–12},
numpages = {12},
keywords = {Dependent types, generic programming, induction-recursion},
location = {Nara, Japan},
series = {TyDe 2016}
}

@inproceedings{hsip,
	doi = {10.1145/3373718.3394755},
  
	url = {https://doi.org/10.1145%2F3373718.3394755},
  
	year = 2020,
	month = {jul},
  
	publisher = {{ACM}
},
  
	author = {Benedikt Ahrens and Paige Randall North and Michael Shulman and Dimitris Tsementzis},
  
	title = {A Higher Structure Identity Principle},
  
	booktitle = {Proceedings of the 35th Annual {ACM}/{IEEE} Symposium on Logic in Computer Science}
}

@misc{tgalois,
      title={Transport via Partial Galois Connections and Equivalences}, 
      author={Kevin Kappelmann},
      year={2023},
      eprint={2303.05244},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@misc{coveringbases,
      title={Covering All the Bases: Type-Based Verification of Test Input Generators}, 
      author={Zhe Zhou and Ashish Mishra and Benjamin Delaware and Suresh Jagannathan},
      year={2023},
      eprint={2304.03393},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@misc{recschemes,
      title={Fantastic Morphisms and Where to Find Them: A Guide to Recursion Schemes}, 
      author={Zhixuan Yang and Nicolas Wu},
      year={2022},
      eprint={2202.13633},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@misc{amortcoind,
      title={Amortized Analysis via Coinduction}, 
      author={Harrison Grodin and Robert Harper},
      year={2023},
      eprint={2303.16048},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@InProceedings{initenough,
author="Johann, Patricia and Ghani, Neil",
editor="Della Rocca, Simona Ronchi",
title="Initial Algebra Semantics Is Enough!",
booktitle="Typed Lambda Calculi and Applications",
year="2007",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="207--222",
abstract="Initial algebra semantics is a cornerstone of the theory of modern functional programming languages. For each inductive data type, it provides a fold combinator encapsulating structured recursion over data of that type, a Church encoding, a build combinator which constructs data of that type, and a fold/build rule which optimises modular programs by eliminating intermediate data of that type. It has long been thought that initial algebra semantics is not expressive enough to provide a similar foundation for programming with nested types. Specifically, the folds have been considered too weak to capture commonly occurring patterns of recursion, and no Church encodings, build combinators, or fold/build rules have been given for nested types. This paper overturns this conventional wisdom by solving all of these problems.",
isbn="978-3-540-73228-0"
}


@article{quickcheck,
author = {Claessen, Koen and Hughes, John},
title = {QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs},
year = {2000},
issue_date = {Sept. 2000},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {35},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/357766.351266},
doi = {10.1145/357766.351266},
abstract = {Quick Check is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are described as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffices to obtain good coverage of the definition under test.},
journal = {SIGPLAN Not.},
month = {9},
pages = {268–279},
numpages = {12}
}

@article{feat,
author = {Dureg\r{a}rd, Jonas and Jansson, Patrik and Wang, Meng},
title = {Feat: Functional Enumeration of Algebraic Types},
year = {2012},
issue_date = {December 2012},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {47},
number = {12},
issn = {0362-1340},
url = {https://doi.org/10.1145/2430532.2364515},
doi = {10.1145/2430532.2364515},
abstract = {In mathematics, an enumeration of a set S is a bijective function from (an initial segment of) the natural numbers to S. We define "functional enumerations" as efficiently computable such bijections. This paper describes a theory of functional enumeration and provides an algebra of enumerations closed under sums, products, guarded recursion and bijections. We partition each enumerated set into numbered, finite subsets.We provide a generic enumeration such that the number of each part corresponds to the size of its values (measured in the number of constructors). We implement our ideas in a Haskell library called testing-feat, and make the source code freely available. Feat provides efficient "random access" to enumerated values. The primary application is property-based testing, where it is used to define both random sampling (for example QuickCheck generators) and exhaustive enumeration (in the style of SmallCheck). We claim that functional enumeration is the best option for automatically generating test cases from large groups of mutually recursive syntax tree types. As a case study we use Feat to test the pretty-printer of the Template Haskell library (uncovering several bugs).},
journal = {SIGPLAN Not.},
month = {9},
pages = {61–72},
numpages = {12},
keywords = {enumeration, memoisation, property-based testing}
}


@article{uqenum,
author = {van der Rest, Cas and Swierstra, Wouter},
title = {A Completely Unique Account of Enumeration},
year = {2022},
issue_date = {August 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {ICFP},
url = {https://doi.org/10.1145/3547636},
doi = {10.1145/3547636},
abstract = {How can we enumerate the inhabitants of an algebraic datatype? This paper explores a datatype generic solution that works for all regular types and indexed families. The enumerators presented here are provably both complete and unique—they will eventually produce every value exactly once—and fair—they avoid bias when composing enumerators. Finally, these enumerators memoise previously enumerated values whenever possible, thereby avoiding repeatedly recomputing recursive results.},
journal = {Proc. ACM Program. Lang.},
month = {8},
articleno = {105},
numpages = {27},
keywords = {property-based testing, Agda, datatype generic programming, dependently typed programming, interactive proof assistants}
}

@inproceedings{ftanew,
author = {Claessen, Koen},
title = {Finger Trees Explained Anew, and Slightly Simplified (Functional Pearl)},
year = {2020},
isbn = {9781450380508},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3406088.3409026},
doi = {10.1145/3406088.3409026},
abstract = {We explicitly motivate the subtle intricacies of Hinze and Paterson's Finger Tree datastructure, by step-wise refining a naive implementation. The result is a new explanation of how Finger Trees work and why they have the particular structure they have, and also a small simplification of the original implementation.},
booktitle = {Proceedings of the 13th ACM SIGPLAN International Symposium on Haskell},
pages = {31–38},
numpages = {8},
keywords = {finger trees, functional pearl, datastructures, amortized complexity},
location = {Virtual Event, USA},
series = {Haskell 2020}
}

@inproceedings{recursiveslowdown,
author = {Kaplan, Haim and Tarjan, Robert E.},
title = {Persistent Lists with Catenation via Recursive Slow-Down},
year = {1995},
isbn = {0897917189},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/225058.225090},
doi = {10.1145/225058.225090},
booktitle = {Proceedings of the Twenty-Seventh Annual ACM Symposium on Theory of Computing},
pages = {93–102},
numpages = {10},
location = {Las Vegas, Nevada, USA},
series = {STOC '95}
}

@article{sijsling,
  author          = {Yorick Sijsling},
  journal         = {Master’s thesis},
  title           = {Generic programming with ornaments and dependent types},
  year            = {2016}
}

@article{rest,
  author          = {Cas van der Rest},
  journal         = {Master’s thesis},
  title           = {Generating Constrained Test Data using Datatype Generic Programming},
  year            = {2019}
}

@inproceedings{levitation,
author = {Chapman, James and Dagand, Pierre-\'{E}variste and McBride, Conor and Morris, Peter},
title = {The Gentle Art of Levitation},
year = {2010},
isbn = {9781605587943},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1863543.1863547},
doi = {10.1145/1863543.1863547},
abstract = {We present a closed dependent type theory whose inductive types are given not by a scheme for generative declarations, but by encoding in a universe. Each inductive datatype arises by interpreting its description - a first-class value in a datatype of descriptions. Moreover, the latter itself has a description. Datatype-generic programming thus becomes ordinary programming. We show some of the resulting generic operations and deploy them in particular, useful ways on the datatype of datatype descriptions itself. Simulations in existing systems suggest that this apparently self-supporting setup is achievable without paradox or infinite regress.},
booktitle = {Proceedings of the 15th ACM SIGPLAN International Conference on Functional Programming},
pages = {3–14},
numpages = {12},
keywords = {metaprogramming, data structure, proof assistants, monads, type systems},
location = {Baltimore, Maryland, USA},
series = {ICFP '10}
}


@misc{effectfully,
  author          = {effectfully},
  url             = {https://github.com/effectfully/Generic},
  title           = {Generic},
  year            = {2020}
}

@book{mltt,
	author = {Per Martin{-}L\"{o}f},
	editor = {},
	publisher = {Bibliopolis},
	title = {Intuitionistic Type Theory},
	year = {1984}
}

@article{telescopes,
title = {Telescopic mappings in typed lambda calculus},
journal = {Information and Computation},
volume = {91},
number = {2},
pages = {189-204},
year = {1991},
issn = {0890-5401},
doi = {https://doi.org/10.1016/0890-5401(91)90066-B},
url = {https://www.sciencedirect.com/science/article/pii/089054019190066B},
author ="de Bruijn, N.G.",
abstract = {The paper develops notation for strings of abstractors in typed lambda calculus, and shows how to treat them more or less as single abstractors.}
}

@Inbook{ulftutorial,
author="Norell, Ulf",
editor="Koopman, Pieter
and Plasmeijer, Rinus
and Swierstra, Doaitse",
title="Dependently Typed Programming in Agda",
bookTitle="Advanced Functional Programming: 6th International School, AFP 2008, Heijen, The Netherlands, May 2008, Revised Lectures",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="230--266",
abstract="In Hindley-Milner style languages, such as Haskell and ML, there is a clear separation between types and values. In a dependently typed language the line is more blurry - types can contain (depend on) arbitrary values and appear as arguments and results of ordinary functions.",
isbn="978-3-642-04652-0",
doi="10.1007/978-3-642-04652-0_5",
url="https://doi.org/10.1007/978-3-642-04652-0_5"
}

@Book{plfa,
    author = {Philip Wadler and Wen Kokke and Jeremy G. Siek},
    title  = {Programming Language Foundations in {A}gda},
    year   = {2022},
    month  = aug,
    url    = {https://plfa.inf.ed.ac.uk/22.08/},
}

@software{agdastdlib,
author = {{The Agda Community}},
month = feb,
title = {{Agda Standard Library}},
url = {https://github.com/agda/agda-stdlib},
version = {1.7.2},
year = {2023}
}


@inbook{genericsamm,
author = {Altenkirch, Thorsten and McBride, Conor and Morris, Peter},
year = {2007},
month = {11},
pages = {209-257},
title = {Generic Programming with Dependent Types},
isbn = {978-3-540-76785-5},
doi = {10.1007/978-3-540-76786-2_4}
}

@inproceedings{reynolds1983types,
  title={Types, abstraction and parametric polymorphism},
  author={Reynolds, John C},
  booktitle={Information Processing 83, Proceedings of the IFIP 9th World Computer Congres},
  pages={513--523},
  year={1983}
}

@inproceedings{wadlerfree,
author = {Wadler, Philip},
title = {Theorems for Free!},
year = {1989},
isbn = {0897913280},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/99370.99404},
doi = {10.1145/99370.99404},
booktitle = {Proceedings of the Fourth International Conference on Functional Programming Languages and Computer Architecture},
pages = {347–359},
numpages = {13},
location = {Imperial College, London, United Kingdom},
series = {FPCA '89}
}

@article{haskellderiving,
author = {Magalh\~{a}es, Jos\'{e} Pedro and Dijkstra, Atze and Jeuring, Johan and L\"{o}h, Andres},
title = {A Generic Deriving Mechanism for Haskell},
year = {2010},
issue_date = {November 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {11},
issn = {0362-1340},
url = {https://doi.org/10.1145/2088456.1863529},
doi = {10.1145/2088456.1863529},
abstract = {Haskell's deriving mechanism supports the automatic generation of instances for a number of functions. The Haskell 98 Report only specifies how to generate instances for the Eq, Ord, Enum, Bounded, Show, and Read classes. The description of how to generate instances is largely informal. The generation of instances imposes restrictions on the shape of datatypes, depending on the particular class to derive. As a consequence, the portability of instances across different compilers is not guaranteed.We propose a new approach to Haskell's deriving mechanism, which allows users to specify how to derive arbitrary class instances using standard datatype-generic programming techniques. Generic functions, including the methods from six standard Haskell 98 derivable classes, can be specified entirely within Haskell 98 plus multi-parameter type classes, making them lightweight and portable. We can also express Functor, Typeable, and many other derivable classes with our technique. We implemented our deriving mechanism together with many new derivable classes in the Utrecht Haskell Compiler.},
journal = {SIGPLAN Not.},
month = {9},
pages = {37–48},
numpages = {12},
keywords = {type classes, datatype-generic programming, haskell}
}

@inproceedings{truesop,
author = {de Vries, Edsko and L\"{o}h, Andres},
title = {True Sums of Products},
year = {2014},
isbn = {9781450330428},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2633628.2633634},
doi = {10.1145/2633628.2633634},
abstract = {We introduce the sum-of-products (SOP) view for datatype-generic programming (in Haskell). While many of the libraries that are commonly in use today represent datatypes as arbitrary combinations of binary sums and products, SOP reflects the structure of datatypes more faithfully: each datatype is a single n-ary sum, where each component of the sum is a single n-ary product. This representation turns out to be expressible accurately in GHC with today's extensions. The resulting list-like structure of datatypes allows for the definition of powerful high-level traversal combinators, which in turn encourage the definition of generic functions in a compositional and concise style. A major plus of the SOP view is that it allows to separate function-specific metadata from the main structural representation and recombining this information later.},
booktitle = {Proceedings of the 10th ACM SIGPLAN Workshop on Generic Programming},
pages = {83–94},
numpages = {12},
keywords = {json, metadata, datatype-generic programming, generic views, lenses, sums of products, universes},
location = {Gothenburg, Sweden},
series = {WGP '14}
}

@phdthesis{kophd,
  edition = {},
  number = {},
  journal = {},
  pages = {},
  publisher = {Oxford University, UK},
  school = {Oxford University, UK},
  title = {Analysis and synthesis of inductive families},
  volume = {},
  author = {Ko, H},
  editor = {},
  year = {2014},
  series = {}
}
