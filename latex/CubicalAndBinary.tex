\subsubsection{Unary numbers are binary numbers}\label{ssec:binary}
Let us demonstrate an application of univalence and the SIP by exploiting the equivalence of the ``Peano'' naturals and the ``Leibniz'' naturals. Recall that the Peano naturals are defined as 
\ExecuteMetaData[Tex/CubicalAndBinary]{Peano}
This definition enjoys a simple induction principle and is well-covered in most libraries. However, the definition is also impractically slow, since most arithmetic operations defined on \bN{} have time complexity in the order of the value of the result.

As an alternative we can use binary numbers, for which for example addition has logarithmic time complexity. Standard libraries tend to contain few proofs about binary number properties, but this does not have to be a problem: the \bN{} naturals and the binary numbers should be equivalent after all!

Let us make this formal. We define the Leibniz naturals as follows:
\ExecuteMetaData[Leibniz/Base.tex]{Leibniz}
Here, the \AgdaInductiveConstructor{0b} constructor encodes 0, while the \AgdaInductiveConstructor{\_1b} and \AgdaInductiveConstructor{\_2b} constructors respectively add a 1 and a 2 bit, under the usual interpretation of binary numbers:
\ExecuteMetaData[Leibniz/Base.tex]{toN}
\ExecuteMetaData[Leibniz/Base.tex]{toN-2}
This defines one direction of the equivalence from \bN{} to \bL{}, for the other direction, we can interpret a number in \bN{} as a binary number by repeating the successor operation on binary numbers:
\ExecuteMetaData[Leibniz/Base.tex]{bsuc}
\ExecuteMetaData[Leibniz/Base.tex]{fromN}
To show that \AgdaFunction{toℕ} is an isomorphism, we have to show that it is the inverse of \AgdaFunction{fromℕ}. By induction on \bL{} and basic arithmetic on \bN{} we see that
\ExecuteMetaData[Leibniz/Properties.tex]{toN-suc}
so \AgdaFunction{toℕ} respects successors. Similarly, by induction on \bN{} we get
\ExecuteMetaData[Leibniz/Properties.tex]{fromN-1}
and % I can't get the code blocks to stick together lol
\ExecuteMetaData[Leibniz/Properties.tex]{fromN-2}
so that \AgdaFunction{fromℕ} respects even and odd numbers. We can then prove that applying \AgdaFunction{toℕ} and \AgdaFunction{fromℕ} after each other is the identity by repeating these lemmas
\ExecuteMetaData[Leibniz/Properties.tex]{N-iso-L}
This isomorphism can be promoted to an equivalence
\ExecuteMetaData[Leibniz/Properties.tex]{N-equiv-L}
which, finally, lets us identify \bN{} and \bL{} by univalence
\ExecuteMetaData[Leibniz/Properties.tex]{N-is-L}
The path \AgdaFunction{ℕ≡L} then allows us to transport properties from \bN{} directly to \bL{}; as an example, we have not yet shown that \bL{} is discrete, i.e., has decidable equality. Using substitution, we can quickly derive this\footnote{Of course, this gives a rather inefficient equality test, but for the homotopical consequences this is not a problem.}
\ExecuteMetaData[Leibniz/Properties.tex]{DiscreteL}
This can be generalized even further to transport proofs about operations from \bN{} to \bL{}.

\subsubsection{Functions from specifications}\label{ssec:useas}
As an example, we will define addition of binary numbers.\todo{This doesn't really belong here.} We could transport \AgdaFunction{\_+\_} as a binary operation
\ExecuteMetaData[Extra/Algebra]{BinOp}
from \bN to \bL to get
\ExecuteMetaData[Tex/CubicalAndBinary]{badplus}
But this is inefficient, incurring an $O(n + m)$ overhead when adding $n$ and $m$. It is more efficient to define addition on \bL{} directly, making use of the binary nature of \bL{}, while agreeing with the addition on \bN{}. Such a definition can be derived from the specification ``agrees with \AgdaFunction{\_+\_}'', so we implement a syntax for giving definitions by equational reasoning, inspired by the ``use-as-definition'' notation used by Hinze and Swierstra \cite{calcdata}: Using an implicit pair type
\ExecuteMetaData[Prelude/UseAs.tex]{isigma}
we define
\ExecuteMetaData[Prelude/UseAs.tex]{Def}
which extracts a definition as the right endpoint of a given path.
% \investigate{As of now, I am unsure if this reduces the effort of implementing a coherent function, or whether it is more typically possible to give a smarter or shorter proof by just giving a definition and proving an easier property of it\footnote{I will put the alternative in the appendix for now}}

With this we can define addition on \bL{} and show it agrees with addition on \bN{} in one motion
\ExecuteMetaData[Leibniz/Properties.tex]{plus-def}
Now we can easily extract the definition of \AgdaFunction{plus} and its correctness with respect to \AgdaFunction{\_+\_} 
\ExecuteMetaData[Leibniz/Properties.tex]{plus-good}

We remark that \AgdaFunction{Def} is close in concept to refinement types\footnote{À la \href{https://agda.github.io/agda-stdlib/Data.Refinement.html}{Data.Refinement}.}, but extracts the value from the proof, rather than requiring it before. \footnote{Unfortunately, normalizing an application of a \AgdaFunction{defined-by} function also causes a lot of unnecessary wrapping and unwrapping, so \AgdaFunction{Def} is mostly only useful for presentation. On the other hand, it should not be hard to write a macro to define a function rebuilding the case tree while replacing any \AgdaFunction{defined-by} by that function.}


\subsubsection{The Structure Identity Principle}
We point out that \bN{} with \AgdaFunction{N.+} and \bL{} with \AgdaFunction{plus} form magmas, that is, inhabitants of
\ExecuteMetaData[Extra/Algebra.tex]{Magma'}
Using that a path in a dependent pair corresponds to a dependent pair of paths, we get a path from (\bN{}, \AgdaFunction{N.+}) to (\bL{}, \AgdaFunction{plus}). %More generally, a magma is simply a type $X$ with some structure, which is a function $f: X \to X \to X$ in the case of a magma. We can see that paths between magmas correspond to paths $p$ between the underlying types $X$ and paths over $p$ between their operations $f$.
This observation is further generalized by the Structure Identity Principle (SIP) as a form of representation independence \cite{iri}. Given a structure, which in our case is just a binary operation
\ExecuteMetaData[Extra/Algebra.tex]{MagmaStr}
this principle produces an appropriate definition ``structured equivalence'' $\iota$. The $\iota$ is such that if structures $X, Y$ are $\iota$-equivalent, then they are identified. In the case of \AgdaFunction{MagmaStr}, the $\iota$ asks us to provide something with the same type as \AgdaFunction{plus-coherent}, so we have just shown that the \AgdaFunction{plus} magma on \bL{}
\ExecuteMetaData[Leibniz/Properties.tex]{magmaL}
and the \AgdaFunction{\_+\_} magma on \bN{} and are identical
\ExecuteMetaData[Leibniz/Properties.tex]{magma-equal}
As a consequence, properties of \AgdaFunction{\_+\_} directly yield corresponding properties of \AgdaFunction{plus}. For example,
\ExecuteMetaData[Leibniz/Properties.tex]{assoc-transport}\todo[inline, color=red]{Express what this accomplishes, and why this is impressive compared to without univalence}